<!DOCTYPE html>
<html lang="zh" data-darkmode="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的算法书 - 二叉查找树</title>
    <meta name="description" content="这是一本关于算法的书">
    <meta name="author" content="rainboy">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-web/1.520.0/style.min.css" integrity="sha512-VqbHLQtJ5icD77Z4HH8NsrtoRJlTAkOKdSrymwYZtZ1Ipbit8L/Pp8RIeHS2vpNk2bVOszUUDotVl7sK403sjw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/markdown.css">
    <link rel="stylesheet" href="/prism-theme/prism-tomorrow.css">
</head>
<body>
    <aside class="panel">
    <ul class="panel-list">
      <li><a href="/"><i class="fa fa-home"></i></a></li>
      <li><a href="javascript:void(0);" onclick="showMenuModal()"><i class="fa fa-list"></i></a></li>
    </ul>
    <ul class="panel-list">
      <li><input type="radio" class="J_darkMode" value="auto" name="darkmode" id="darkmode-auto" checked=""><label for="darkmode-auto"><i class="fa fa-adjust"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="light" name="darkmode" id="darkmode-light"><label for="darkmode-light"><i class="fa fa-sun-o"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="dark" name="darkmode" id="darkmode-dark"><label for="darkmode-dark"><i class="fa fa-moon-o"></i></label></li>
    </ul>
  </aside>
    <div id="modal-menu" class="modal-menu" style="display:none;">
  <div class="modal-menu-mask" onclick="hideMenuModal()"></div>
  <div class="modal-menu-content">
    <button class="modal-menu-close" onclick="hideMenuModal()">×</button>
    <h2>目录</h2>
    

<div class="chapter-list">
  
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="base">基础</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="base/double_point/index.html">双指针</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="base/binary_search/index.html">二分查找</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="base/sparse_table/index.html">ST稀疏表</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="tree-algo">树相关算法树</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="tree-algo/dfs-order">dfs序</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="chapter3">第三章 动态规划</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128"><path fill="#c62828" d="m31.37 26.45l.17-18.43L40 5.43l9.75 16.73z"/><path fill="#37474f" d="M36.76 20.48s-2.6-11.89.34-13.07c5.23-2.09 9.31 11.65 9.31 11.65z" opacity="0.59"/><path fill="#f44336" d="M20.59 32.81c-.09-1.63-2.29-14.63 1.05-21.88c1.53-3.31 7.81-5.51 13.43-6.76c1.39-.31 4.98-.51 7.21 2.05c2.01 2.31 4.98 7.37 7.91 15l-2.11 4.54s-2.91-7.7-5.82-14.06c-2.41-5.27-5.47-3.52-5.78-2.29c-.56 2.26 2.3 14.51 2.3 14.51c-4.16 1.77-18.19 8.89-18.19 8.89"/><path fill="#455a64" d="m42.36 17.37l1.75-8.5L51 4.88l8.29.02l6.9 5.59l1.91 10.9l-8.33-2.81l-1.13-7.81l-7.64-.19l-1.02 6.21z"/><path fill="#ff7555" d="M35.06 4.18c-5.62 1.24-11.27 3.03-13.43 6.76c-1.24 2.14-1.96 7.75-1.82 12.96c1.09-1.72 5.54-4.69 8.86-6.13c3.31-1.44 3.69-2.87 3.74-3.5c.25-2.86.01-5.22.85-7.24c1.06-2.56 2.57-2.88 3.45-3.01c-.67 0-1.26.07-1.65.16m4.53.28c-.54-.19-1.08-.31-1.6-.37c.54.14 1.07.32 1.6.37"/><path fill="none" stroke="#784d30" stroke-miterlimit="10" stroke-width="9.816" d="M89.99 109.24c14.88-3.95 19.32-20.76 23.54-22.17"/><path fill="#c62828" d="M104.48 74.9c1.09 7.09 3.23 7.62 6.96 7.43c5.65-.28 6.27-1.58 7.53-11.26c1.56-12.02-2.95-28.77-6.84-40.25c-2.06-6.08-1.85-10.25-6.44-14.89c-2.52-2.55-12.33-6.3-15.18-1.42c-1.96 3.36-.98 6.77.89 9.47c5.43 7.86 10.43 33.77 13.08 50.92"/><path fill="#37474f" d="M93.06 26.91c1.04 2.13 2.11 4.89 2.98 8c8.86-.27 18.46 3.98 18.46 3.72c0-.22-.75-5.99-3.19-11.71c-1.06-2.48-4.29-9.28-8.29-8.62c-5.03.84-9.96 8.61-9.96 8.61" opacity="0.59"/><path fill="#f44336" d="M85.95 39.19c2.61-5.58 12.26-19.78 17.81-20.24c2.75-.23 5.84 5.46 6.97 8.57c3.17 8.73 6.62 22.43 7.63 36.73c.63 8.92-1 16.02-4.36 18.97c12.88-2.41 7.85-30.52 6.76-36.34c-3.67-19.49-8.48-26.84-12.17-30.77c-2.82-3-15.1-9.35-21.58-9.05c-4.99.23-15.91 9.56-18.89 14.73c-.88 1.52 17.83 17.4 17.83 17.4"/><path fill="#ff7555" d="M68.66 123.73c16.9-1.34 27.59-10.84 28.71-19.85c3.86-31.14-3.77-76.17-34.16-84.9c-3.39-.97-9.35-2.25-14.53-2.25c-6.03 0-15.33 1.27-22.01 5.85c-12.18 8.36-15.43 20.26-16.23 26.16c-2.95 21.63 36.96 76.68 58.22 74.99"/><path fill="#c62828" d="M97.37 103.88c2.01-16.2.91-36.15-4.89-52.81c-3.02-3.9-6.38-5.73-9.16-4.83c-3.34 1.08-6.27 5.53-5.21 10.01c0 0 8.09 32.46 2.59 52.99c-3.64 13.59-13.23 14.52-13.23 14.52c.4 0 .8 0 1.19-.03c16.91-1.34 27.59-10.84 28.71-19.85"/><path fill="#f44336" d="M18.62 120.38c5.1 1.61 18.51 3.62 42.26 3.62c21.33 0 21.18-7.59 22.94-16.5c3.62-18.38-1.34-78.26-38.49-79.55C12.84 26.81 9.59 45.89 7.14 66.61c-2.56 21.67-1.96 29.78-.72 38.61c1.61 11.54 8.69 14.05 12.2 15.16"/><path fill="#37474f" d="M90.05 59.81c-.86-4.52-2.08-9.49-4.09-14.34l-2.42.11c1.81 4.11 3.31 8.94 4.39 14.63c3.45 18.23 3.85 30.45 3.67 37.08c-.11 3.98 2.08 4 2.19-.25c.17-6.81-.29-18.99-3.74-37.23"/><path fill="#e2a610" d="M92.53 95.21a2.626 2.626 0 0 0-1.73 2.92l1.3 7.54a2.19 2.19 0 0 0 3.17 1.64l3.62-1.85c1.18-.6 1.56-2.11.81-3.2l-4.17-6.06a2.62 2.62 0 0 0-3-.99"/><path fill="#ffca28" d="M94.23 105.83c-.18-.33-1.14-5.47-1.43-7.81c-.32-2.63.81-2.78.98-2.92a2.62 2.62 0 0 0-2.99 3.03l1.3 7.54c.15 1.03.96 1.75 1.89 1.87c.42.05.86-.01 1.28-.23l.84-.43c-.04-.01-1.28.03-1.87-1.05"/><path fill="#546e7a" d="m119.95 92.13l-9.34.83c-.86.08-1.63-.56-1.7-1.43l-.71-7.93c-.08-.86.56-1.63 1.43-1.7l9.34-.83c.86-.08 1.63.56 1.7 1.43l.71 7.93c.07.86-.57 1.62-1.43 1.7"/><path fill="#37474f" d="m117.41 92.43l-8.84.79c-.86.08-1.63-.56-1.7-1.43l-.72-8.09c-.08-.86.56-1.63 1.43-1.7l8.84-.79c.86-.08 1.63.56 1.7 1.43l.72 8.09c.07.86-.57 1.62-1.43 1.7"/><path fill="#a06841" d="m111.28 101.56l-2.71-14.28c-.05-.24.12-.47.37-.49l7.13-.72c.2-.02.39.11.44.31l3.52 13.18c.23.86-.3 1.75-1.17 1.95l-5.68 1.3c-.87.19-1.74-.37-1.9-1.25"/><path fill="#fff59d" d="m49.47 58.81l-15.43-.46c-1.35 0-2.45-1.1-2.45-2.45l.21-7.94c0-1.33 1.06-2.42 2.39-2.45l15.26.41a2.453 2.453 0 0 1 2.52 2.4l-.03 7.99c.01 1.37-1.09 2.5-2.47 2.5" opacity="0.65"/><path fill="#ff7555" d="M87.01 7.05c-3.78.12-11.09 5.62-15.58 10.49c2.32-.19 7.81 2.38 12.37 5.9c.91.7 3.15.57 4.61-1c1.33-1.43 2.58-2.53 3.92-3.95c7.86-8.33 14.04-4.2 14.04-4.2c-6.5-4.23-14.42-7.39-19.36-7.24"/><path fill="#546e7a" d="M86.27 46.23C81.34 33.91 71.39 22.06 49.65 20.1c-15.1-1.36-25.27 5.65-29.41 8.19c-.92.56-1.95 1.26-2.65 2.22c-.89 1.22-1.01 2.22-1.01 2.22s13.1-12.23 32.87-10.48c11.3 1 26.14 4.77 34.31 23.87c.69-.17 1.62-.07 2.51.11"/><path fill="#ff7555" d="M69.35 114.25s-15.98 1.11-33.95.13c-9.47-.52-16.41-1.88-17.82-3.71c-1.74-2.26-3.8-4.45-3.8-16.07c0-7.83 2.89-14.14 8.49-14.28c4.28-.11 49.21-.6 45.82-.6s-6.45 7.43-6.14 15.44c.76 19.63 7.4 19.09 7.4 19.09"/><path fill="#ff7555" d="M53.67 94.6c.35-.1 3.53.18 6.07-1.59c.96-.67 1.72-1.23 2.33-1.87c.59-6 2.95-10.89 5.59-11.37c.09-.02.18-.04.26-.05c-3.92.08-35.97-1.1-45.98-.95c-4.64.07-8.22 5.53-7.9 11.95c.67 1.19 1.75 2.47 3.4 2.72c3.24.49 35.88 1.27 36.23 1.16"/><path fill="#fff59d" d="M53.67 94.6c.35-.1 3.53.18 6.07-1.59c.96-.67 1.72-1.23 2.33-1.87c.59-6 2.95-10.89 5.59-11.37c.09-.02.18-.04.26-.05c-3.92.08-35.97-1.1-45.98-.95c-4.64.07-8.22 5.53-7.9 11.95c.67 1.19 1.75 2.47 3.4 2.72c3.24.49 35.88 1.27 36.23 1.16" opacity="0.45"/><path fill="#c62828" d="M74.42 89.7c-.34-5.22-1.57-7.7-2.69-8.88c-1.03-1.1-2.64-1.19-4.93-1.08c-1.42.07-4.01 1.43-5.1 9.46v-.01c-.86 1.95-3.11 3.89-6.84 3.89l-35.75-1.16c-3.58-.23-4.89-3.65-5.06-3.96c0 0-.52 2.41-.03 3.94c.62 1.92 2.9 3.06 5.09 3.06l35.75 1.16c2.85 0 5.02-1.13 6.42-2.18q-.09 1.86-.09 4.05c0 15.36 4.43 16.52 7.26 16.39c2.83-.14 5.6-1.22 6.05-3.73c.64-3.51.57-10.89-.08-20.95"/></svg> </span>
              
             背包 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="chapter3/knapsack/01-knapsack">01背包</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="chapter3/knapsack/multiple-knapsack">多重背包</a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48"><path fill="#00bcd4" d="M19 22h10v20H19zM32 8h10v34H32zM6 30h10v12H6z"/><g fill="#3f51b5"><path d="m11 8l10 10V8z"/><path d="m9.394 22.437l-2.828-2.828l9.969-9.969l2.828 2.828z"/></g></svg> </span>
              
             线性动态规划 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="chapter3/linear/lcs">lcs</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="chapter3/linear/lis">lis</a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="#000" d="M16 120h480V16H16Zm32-72h416v40H48Zm192 96H16v96h224Zm-32 64H48v-32h160Zm64 32h224v-96H272Zm32-64h160v32H304Zm-152 96H16v88h136Zm-32 56H48v-24h72Zm72 32h128v-88H192Zm32-56h64v24h-64Zm136 56h136v-88H360Zm32-56h72v24h-72ZM121.442 443.278A52.721 52.721 0 1 0 68.722 496a52.78 52.78 0 0 0 52.72-52.722m-73.442 0A20.721 20.721 0 1 1 68.722 464A20.745 20.745 0 0 1 48 443.278m92.853 0a52.721 52.721 0 1 0 52.721-52.72a52.78 52.78 0 0 0-52.721 52.72m73.442 0a20.721 20.721 0 1 1-20.721-20.72a20.745 20.745 0 0 1 20.726 20.72Zm51.41 0a52.721 52.721 0 1 0 52.721-52.72a52.78 52.78 0 0 0-52.721 52.72m73.442 0a20.721 20.721 0 1 1-20.721-20.72a20.745 20.745 0 0 1 20.721 20.72m104.131-52.72A52.721 52.721 0 1 0 496 443.278a52.78 52.78 0 0 0-52.722-52.72m0 73.442A20.721 20.721 0 1 1 464 443.278A20.745 20.745 0 0 1 443.278 464"/></svg> </span>
              
             区间动态规划 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><path fill="currentColor" d="M7 8H5V7H4V6H3V4h6v2H8v1H7m-4 5H1v-2h2m9 2H9v-2h3m9 2h-3v-2h3M7 13H5v-1H4v-2h1V9h2v1h1v2H7m9 1h-2v-1h-1v-2h1V9h2v1h1v2h-1m2 6h-6v-2h1v-1h1v-1h2v1h1v1h1Z"/></svg> </span>
              
             动态规划优化 
            </span>
          </a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-folder-open-o"></i>
          <a href="javascript:void(0);" class="menu-no-link">第四章 数据结构</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/Block">分块算法</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/BIT">树状数组</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/segment-tree">线段树</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/stack">栈</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/stack/表达式">表达式求值</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/stack/monotonic-stack">单调栈</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="512" height="105" viewBox="0 0 512 105"><path fill="#4fb58b" d="m92.384 56.139l.068.005l7.077.74c.497.053.953.296 1.275.675l.053.064l-.068.034c.331.417.477.952.404 1.48a52.72 52.72 0 0 1-16.456 32.072a50.97 50.97 0 0 1-34.662 13.598a50.4 50.4 0 0 1-18.257-3.389l-.317-.124a1.87 1.87 0 0 1-1.062-1.001l-.03-.074a1.94 1.94 0 0 1-.034-1.448l2.794-6.815a1.917 1.917 0 0 1 2.42-1.108l.064.024a40.06 40.06 0 0 0 41.67-8a41.32 41.32 0 0 0 13.01-25.047a1.95 1.95 0 0 1 1.983-1.69zM259.52 27.215c6.034 0 10.753 1.841 13.767 5.377l.1.12V29.72a1.68 1.68 0 0 1 1.514-1.592l.067-.005h8.052c.828.057 1.487.71 1.559 1.53l.004.067v44.696a27.2 27.2 0 0 1-5.48 17.532c-4.337 5.278-10.926 7.951-19.583 7.951c-12.035 0-21.533-7.614-23.096-18.49a1.68 1.68 0 0 1 1.144-1.762l.066-.02l7.867-1.85q.06-.012.124-.022a1.58 1.58 0 0 1 1.792 1.334a11.9 11.9 0 0 0 12.103 10.506c9.303 0 13.68-4.728 13.766-14.61l.001-.3v-3.917a17.67 17.67 0 0 1-13.767 5.9c-13.38 0-23.08-10.388-23.08-24.676a26 26 0 0 1 6.355-17.532a22.17 22.17 0 0 1 16.725-7.245M17.198 81.577l.1-.001h.1a5.9 5.9 0 0 1 5.833 5.834v.1l-.001.1a5.934 5.934 0 1 1-6.032-6.033m381.7-54.984l.412.003c14.384.199 23.296 10.211 23.296 26.237q0 1.272-.136 2.538a1.56 1.56 0 0 1-1.478 1.41l-.067.002h-34.19c.21 7.18 6.146 12.862 13.33 12.758a11.986 11.986 0 0 0 12.237-8.539a1.58 1.58 0 0 1 1.903-.96l.063.019l6.824 2.403c.378.122.686.39.86.74l.031.067c.188.37.22.8.087 1.194a22.51 22.51 0 0 1-22.004 15.296a24.3 24.3 0 0 1-17.348-7.043a27.12 27.12 0 0 1-7.447-19.684c0-16.391 11.78-26.242 23.284-26.438zm-193.47 0h.017c14.641 0 23.735 10.052 23.735 26.24a25 25 0 0 1-.135 2.538a1.546 1.546 0 0 1-1.481 1.41l-.065.002h-34.19c.21 7.2 6.177 12.89 13.38 12.758a11.97 11.97 0 0 0 12.237-8.539a1.563 1.563 0 0 1 1.903-.961l.064.02l6.824 2.403c.4.13.724.423.891.807c.16.382.16.812 0 1.194a22.51 22.51 0 0 1-21.986 15.296a24.3 24.3 0 0 1-17.381-7.043a27.2 27.2 0 0 1-7.447-19.684c0-16.557 12.019-26.44 23.634-26.44m-51.773-.017c6.572 0 11.884 1.597 15.818 4.74c2.66 2.12 4.63 4.98 5.665 8.22l.003.013a1.076 1.076 0 0 1-.738 1.284l-.055.014l-8.153 2.69a1.53 1.53 0 0 1-1.126 0a1.2 1.2 0 0 1-.64-.74l-.042-.16c-.743-2.654-3.17-6.916-10.732-6.916c-5.379 0-8.606 3.093-8.606 6.085l.001.118c.04 1.946 1.098 4.388 5.737 5.316l.145.029l8.976 1.68c9.918 1.998 15.635 7.388 15.749 14.9l.001.23l-.033-.135l-.002.228c-.144 7.53-7.429 15.455-20.842 15.455c-15.716 0-21.885-8.892-23.029-14.137a1.126 1.126 0 0 1 .784-1.228l.057-.016l8.405-2.622a1.4 1.4 0 0 1 .453 0a1.4 1.4 0 0 1 .618.132l.072.036c.308.148.536.425.621.756c1.06 5.044 5.615 8.052 12.17 8.052c6.102 0 8.876-3.194 8.876-6.085c0-2.86-2.417-4.979-6.584-5.854l-.14-.03l-9.43-1.831c-8.791-1.664-14.27-7.128-14.27-14.238c0-8.657 9.295-15.986 20.271-15.986M492.67 12.574h7.346a1.68 1.68 0 0 1 1.578 1.616l.002.065v13.8h8.84c.86.061 1.53.76 1.564 1.615l.001.066v7.393a1.58 1.58 0 0 1-1.5 1.531l-.066.002h-8.84v24.525c0 4.068 1.612 5.75 5.764 5.75a22 22 0 0 0 2.514-.192l.312-.044a1.56 1.56 0 0 1 1.277.353c.317.294.507.699.536 1.13l.003.08v6.909a1.58 1.58 0 0 1-1.127 1.53a22 22 0 0 1-5.945.809l-.274-.003c-8.772 0-14.245-5.585-14.354-14.618l-.001-.275V38.763h-7.65a1.68 1.68 0 0 1-1.575-1.53l-.004-.067v-7.362a1.68 1.68 0 0 1 1.515-1.676l.065-.005h2.056l.219-.004c2.4-.07 6.087-1.042 6.162-6.4l.002-.169v-7.295a1.68 1.68 0 0 1 1.515-1.676zM349.897 26.586l.193.007h-.017c8.654 0 17.39 6.03 17.564 19.198l.002.402v31.131a1.68 1.68 0 0 1-1.512 1.592l-.068.005h-8.052a1.68 1.68 0 0 1-1.575-1.53l-.005-.067V47.202l-.002-.232c-.049-3.839-1.353-10.006-9.259-10.006c-5.842 0-10.004 4.548-10.086 11.163l-.002.2v28.997a1.68 1.68 0 0 1-1.512 1.592l-.068.005h-8.15a1.68 1.68 0 0 1-1.576-1.53l-.004-.067V47.202l-.002-.232c-.049-3.839-1.353-10.006-9.262-10.006c-6.073 0-10.186 4.515-10.268 11.26l-.001.205v28.895a1.68 1.68 0 0 1-1.513 1.592l-.067.005h-8.053a1.68 1.68 0 0 1-1.558-1.53l-.004-.067V29.619a1.68 1.68 0 0 1 1.496-1.591l.066-.006h7.75a1.68 1.68 0 0 1 1.576 1.53l.004.067v2.874a18.1 18.1 0 0 1 13.614-5.9a16.08 16.08 0 0 1 14.508 8.22a18.2 18.2 0 0 1 15.843-8.227m120.566 5.94a22.23 22.23 0 0 1 4.511 14.157l-.008.216v30.425a1.68 1.68 0 0 1-1.496 1.591l-.066.006h-8.151a1.684 1.684 0 0 1-1.578-1.53l-.005-.067V48.529c0-7.53-3.546-11.363-10.27-11.363a9.35 9.35 0 0 0-7.648 3.564a14.75 14.75 0 0 0-2.626 8.742l.005.184v27.668a1.68 1.68 0 0 1-1.513 1.592l-.067.005h-8.136a1.68 1.68 0 0 1-1.576-1.53l-.004-.067V29.585c.04-.835.688-1.51 1.513-1.592l.067-.005h7.951a1.68 1.68 0 0 1 1.559 1.53l.004.067v3.362a17.5 17.5 0 0 1 13.885-6.354a17.01 17.01 0 0 1 13.649 5.934M1.95 58.179h57.875a1.967 1.967 0 0 1 1.95 1.916v7.313a1.967 1.967 0 0 1-1.883 1.981l-.067.002H1.95A1.97 1.97 0 0 1 0 67.474v-7.38a1.97 1.97 0 0 1 1.88-1.914zm258.966-20.91c-7.934 0-12.977 5.647-12.977 14.724S252.915 66.7 260.916 66.7c7.632 0 12.775-5.916 12.775-14.708c0-8.808-5.143-14.725-12.775-14.725m-67.25 9.82l-.021.18h23.92c-.583-6.39-5.086-10.374-11.83-10.453l-.206-.002A11.77 11.77 0 0 0 193.69 46.91zm193.493 0l-.021.18h23.921c-.582-6.39-5.087-10.374-11.832-10.453l-.205-.002a11.77 11.77 0 0 0-11.839 10.098zM67.07 2.892c.502.18.908.557 1.127 1.042c.2.49.2 1.04 0 1.53l-2.521 6.724a1.916 1.916 0 0 1-2.438 1.176a40.04 40.04 0 0 0-38.662 6.909a41.64 41.64 0 0 0-13.649 21.751a1.95 1.95 0 0 1-1.882 1.463h-.438l-6.925-1.664a1.93 1.93 0 0 1-1.227-.908H.42a1.95 1.95 0 0 1-.218-1.53a52.76 52.76 0 0 1 17.566-27.77A50.95 50.95 0 0 1 67.07 2.893M41.436 31.939H99.31a1.967 1.967 0 0 1 1.947 1.847l.003.069V41.1a1.967 1.967 0 0 1-1.882 1.982l-.068.001H41.435a1.967 1.967 0 0 1-1.932-1.915v-7.246a1.967 1.967 0 0 1 1.864-1.981zM81.612 9.834h.2a5.9 5.9 0 0 1 5.832 5.834v.2a5.934 5.934 0 1 1-6.032-6.034"/></svg> </span>
              
             线段树 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/persistent-segment-tree">可持久化线段树</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/BST">二叉搜索树</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/RBTree">红黑树</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/AVL">AVL</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="data-structure/fhq-treap">FHQ-Treap</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-folder-open-o"></i>
          <a href="javascript:void(0);" class="menu-no-link">第五章 图论</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="graph/diameter_of_tree">树的直径</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="graph/center_of_tree">树的中心</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="graph/pseudotree">基环树</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="graph/kruskal">Kruskal</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="graph/floyed">floyed算法</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="string">字符串</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="string/进制hash/index.html">进制hash</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="string/manacher/index.html">马拉车-Manacher</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="string/最小表示法/index.html">最小表示法</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math">数学</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="thinkMind">思维方式</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="thinkMind/index.html">总结</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="thinkMind/约束松弛.html">约束松弛</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="thinkMind/特例化-归纳.html">特例化-归纳</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math">数学</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/向上取整.html">向上取整</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/log.html">对数</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/集合.html">集合</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/反证法.html">反证法</a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none"><path d="m12 3l4.33 6.75H7.67zM3 14h7v7H3zm18 3.5a3.5 3.5 0 1 1-7 0a3.5 3.5 0 0 1 7 0"/><path stroke="currentColor" stroke-linecap="square" stroke-width="2" d="m12 3l4.33 6.75H7.67zM3 14h7v7H3zm18 3.5a3.5 3.5 0 1 1-7 0a3.5 3.5 0 0 1 7 0Z"/></g></svg> </span>
              
             组合数学 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/combinatorics/112_combinatorial_problems/index.html">112个组合问题</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/numherTheory/index.html">数论</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/group_theory/index.html">群论</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/numherTheory/Eratosthenes.html">埃氏筛</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="math/numherTheory/inverse/index.html">模逆元</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
      
      <li>
        
          <i class="fa fa-folder-open-o"></i>
          <a href="javascript:void(0);" class="menu-no-link">附录</a>
        

        
          
  
  <ul>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 22q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22"/></svg> </span>
              
             技巧 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/quickIO.html">quickIO</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/assert的使用.html">assert断言的使用</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/写题步奏.html">写题步奏</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/macos.html">macos下使用万能头文件</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/常用命令.html">常用命令</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/tricks/常用变量名.html">常用变量名</a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#0065a9" d="m29.01 5.03l-5.766-2.776a1.74 1.74 0 0 0-1.989.338L2.38 19.8a1.166 1.166 0 0 0-.08 1.647q.037.04.077.077l1.541 1.4a1.165 1.165 0 0 0 1.489.066L28.142 5.75A1.158 1.158 0 0 1 30 6.672v-.067a1.75 1.75 0 0 0-.99-1.575"/><path fill="#007acc" d="m29.01 26.97l-5.766 2.777a1.745 1.745 0 0 1-1.989-.338L2.38 12.2a1.166 1.166 0 0 1-.08-1.647q.037-.04.077-.077l1.541-1.4A1.165 1.165 0 0 1 5.41 9.01l22.732 17.24A1.158 1.158 0 0 0 30 25.328v.072a1.75 1.75 0 0 1-.99 1.57"/><path fill="#1f9cf0" d="M23.244 29.747a1.745 1.745 0 0 1-1.989-.338A1.025 1.025 0 0 0 23 28.684V3.316a1.024 1.024 0 0 0-1.749-.724a1.74 1.74 0 0 1 1.989-.339l5.765 2.772A1.75 1.75 0 0 1 30 6.6v18.8a1.75 1.75 0 0 1-.991 1.576Z"/></svg> </span>
              
             vscode 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/vscode/如何调试.html">如何调试</a>
        

        

      </li>
    
      
      <li>
        
          <a href="javascript:void(0);" class="menu-info">
            <span>
              
                <span class="svg-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="#000"><path d="m3.463 12.86l-.005-.07zm7.264.69l-3.034-3.049l1.014-1.014l3.209 3.225l3.163-3.163l1.014 1.014l-3.034 3.034l3.034 3.05l-1.014 1.014l-3.209-3.225L8.707 17.6l-1.014-1.014l3.034-3.034z"/><path fill-rule="evenodd" d="M16.933 5.003V6h1.345l2.843-2.842l1.014 1.014l-2.692 2.691l.033.085a13.8 13.8 0 0 1 .885 4.912q0 .503-.034.995l-.005.075h3.54v1.434h-3.72l-.01.058c-.303 1.653-.891 3.16-1.692 4.429l-.06.094l3.423 3.44l-1.017 1.012l-3.274-3.29l-.099.11c-1.479 1.654-3.395 2.646-5.483 2.646c-2.12 0-4.063-1.023-5.552-2.723l-.098-.113l-3.209 3.208l-1.014-1.014l3.366-3.365l-.059-.095c-.772-1.25-1.34-2.725-1.636-4.34l-.01-.057H0V12.93h3.538l-.005-.075a14 14 0 0 1-.034-.995c0-1.743.31-3.39.863-4.854l.032-.084l-2.762-2.776L2.65 3.135L5.5 6h1.427v-.997a5.003 5.003 0 0 1 10.006 0m-8.572 0V6H15.5v-.997a3.569 3.569 0 0 0-7.138 0zm9.8 2.522l-.034-.09H5.733l-.034.09a12.3 12.3 0 0 0-.766 4.335c0 2.76.862 5.201 2.184 6.92c1.32 1.716 3.036 2.649 4.813 2.649s3.492-.933 4.813-2.65c1.322-1.718 2.184-4.16 2.184-6.919c0-1.574-.28-3.044-.766-4.335" clip-rule="evenodd"/></g></svg> </span>
              
             lldb的使用 
            </span>
          </a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/lldb/lldb如何调试.html">lldb如何调试</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/lldb/lldb实现display命令.html">lldb实现display命令</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/lldb/lldbinit.html">lldbinit使用</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/gdb/lldbpython脚本入门.html">lldbpython脚本入门</a>
        

        

      </li>
    
      
      <li>
        
          <i class="fa fa-file-text"></i>
          <a href="appendix/software/常用软件.html">常用软件</a>
        

        

      </li>
    
  </ul>
  

        

      </li>
    
  </ul>
  

</div>


  </div>
</div>
<script>
function showMenuModal() {
  document.getElementById('modal-menu').style.display = 'block';
}
function hideMenuModal() {
  document.getElementById('modal-menu').style.display = 'none';
}
</script>

    <main>
        
<article class="page">
    <header class="page-header">
        <h1>二叉查找树</h1>
    </header>
    
    <div class="container">
        <div class="heti markdown-body">
    <nav class="table-of-contents"><ol><li><a href="#bst-%E5%AE%9A%E4%B9%89">BST 定义</a></li><li><a href="#%E6%8F%92%E5%85%A5">插入</a><ol><li><a href="#%F0%9F%8C%B3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E6%98%8E">🌳 二叉搜索树操作的数学原理与证明</a><ol><li><a href="#1.-find(x)---%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C">1. find(x) - 查找操作</a></li><li><a href="#2.-insert(x)---%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">2. insert(x) - 插入操作</a></li><li><a href="#3.-findmin()---%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC">3. findMin() - 查找最小值</a></li></ol></li></ol></li><li><a href="#succ-%E5%90%8E%E7%BB%A7%E4%B8%8E-prev-%E5%89%8D%E9%A9%B1">succ 后继与 prev 前驱</a><ol><li><a href="#1.-succ(x)---%E6%9F%A5%E6%89%BE%E5%90%8E%E7%BB%A7">1. succ(x) - 查找后继</a></li><li><a href="#2.-prev(x)---%E6%9F%A5%E6%89%BE%E5%89%8D%E9%A9%B1">2. prev(x) - 查找前驱</a></li><li><a href="#3.-%E5%AE%9E%E7%8E%B0">3. 实现</a><ol><li><a href="#c%2B%2B-(%E5%B8%A6-parent-%E6%8C%87%E9%92%88)">C++ (带 parent 指针)</a></li><li><a href="#haskell-(%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F)">Haskell (纯函数式)</a></li></ol></li></ol></li><li><a href="#rank-%E6%8E%92%E5%90%8D%E4%B8%8E-atrank-%E9%80%89%E6%8B%A9">rank 排名与 atRank 选择</a><ol><li><a href="#1.-rank(x)---%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D">1. rank(x) - 查找元素排名</a><ol><li><a href="#c%2B%2B-(%E5%B8%A6-parent-%E6%8C%87%E9%92%88)-1">C++ (带 parent 指针)</a></li><li><a href="#haskell-(%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F)-1">Haskell (纯函数式)</a></li></ol></li><li><a href="#2.-atrank(k)---%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">2. atRank(k) - 查找第k小的元素</a><ol><li><a href="#c%2B%2B-(%E5%B8%A6-parent-%E6%8C%87%E9%92%88)-2">C++ (带 parent 指针)</a></li><li><a href="#haskell-(%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F)-2">Haskell (纯函数式)</a></li></ol></li><li><a href="#3.-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">3. 复杂度分析</a></li><li><a href="#4.-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4. 应用场景</a><ol><li><a href="#4.-deletemin()---%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC">4. deleteMin() - 删除最小值</a></li><li><a href="#5.-delete(x)---%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">5. delete(x) - 删除操作</a></li></ol></li></ol></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E7%AD%89%E5%BE%85%E6%95%B4%E7%90%86">等待整理</a><ol><li><a href="#%F0%9F%8C%B3-haskell-%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-(bst.hs)">🌳 Haskell 实现的二叉搜索树 (BST.hs)</a></li></ol></li><li><a href="#atrank---%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">atRank - 查找第k小的元素</a><ol><li><a href="#%F0%9F%A7%AE-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">🧮 算法原理</a></li><li><a href="#%F0%9F%93%90-%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E">📐 数学证明</a></li><li><a href="#%F0%9F%92%BB-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">💻 函数实现</a></li><li><a href="#%F0%9F%94%84-%E4%BA%92%E4%B8%BA%E9%80%86%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8">🔄 互为逆运算性质</a></li><li><a href="#%F0%9F%A7%AA-%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B">🧪 测试示例</a></li></ol></li></ol></nav><h2 id="bst-%E5%AE%9A%E4%B9%89" tabindex="-1">BST 定义</h2>
<p>BST的随机生成</p>
<div class="admonition definition">
<p class="admonition-title">定义</p>
<p>二叉搜索树是一种特殊的二叉树,它的节点的值可以进行&quot;比较&quot;(抽象的比较),并且满足以下性质:</p>
<ol>
<li>如果一个节点的左子树不为空,那么左子树上所有节点的值都小于该节点的值</li>
<li>如果一个节点的右子树不为空,那么右子树上所有节点的值都大于该节点的值</li>
<li>它的左右子树也都是二叉搜索树</li>
</ol>
</div>
<div class="code-tabs">
<ul>
<li><input type="radio" name="label-group-34" checked><label for="group-34-tab-0" onclick="this.previousElementSibling.click()">cpp</label></li>
<li><input type="radio" name="label-group-34"><label for="group-34-tab-1" onclick="this.previousElementSibling.click()">haskell</label></li>
</ul>
<input type="radio" id="group-34-tab-0" name="group-34" checked>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div>
        <code>struct Node <span class="token punctuation">{</span>
    int key<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code>
    </pre>
</div>
<input type="radio" id="group-34-tab-1" name="group-34">
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>
        <code><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code>
    </pre>
</div>
</div>
<h2 id="%E6%8F%92%E5%85%A5" tabindex="-1">插入</h2>
<h3 id="%F0%9F%8C%B3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E6%98%8E" tabindex="-1">🌳 二叉搜索树操作的数学原理与证明</h3>
<p>二叉搜索树（BST）的核心在于其<strong>不变量（Invariant）</strong>：对于树中的任意节点 <code>N</code>，其左子树中所有节点的值都小于 <code>N</code> 的值，其右子树中所有节点的值都大于 <code>N</code> 的值。这个不变量是所有操作正确性的基础。</p>
<p>树的高度 <code>h</code> 是所有操作时间复杂度的关键。</p>
<ul>
<li>对于一个<strong>完全平衡</strong>的二叉树，其高度为 <code>h = O(log n)</code>，其中 <code>n</code> 是节点数。</li>
<li>对于一个<strong>完全不平衡</strong>（退化为链表）的二叉树，其高度为 <code>h = O(n)</code>。</li>
</ul>
<p>因此，所有基本操作的性能都介于 <code>O(log n)</code> 和 <code>O(n)</code> 之间。</p>
<hr>
<h4>1. <code>find(x)</code> - 查找操作</h4>
<p><code>find</code>是最简单的操作，它在树中搜索值 <code>x</code>。</p>
<p><code>find</code> 操作利用了 BST 的不变量来高效地缩小搜索范围。从根节点开始，如果要查找的值 <code>x</code> 小于当前节点的值，则搜索进入左子树；如果 <code>x</code> 大于当前节点的值，则搜索进入右子树。这个过程持续进行，直到找到值 <code>x</code> 或者到达一个空的子树（表示 <code>x</code> 不在树中）。</p>
<p>伪代码</p>
<p><div class="ps-root">
<div class="ps-algorithm with-caption">
<p class="ps-line" style="text-indent:-1.2em;padding-left:1.2em;">
<span class="ps-keyword">Algorithm 1 </span>BST FIND</p>
<div class="ps-algorithmic with-linenum">
<div class="ps-block" style="margin-left:1.7999999999999998em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:0em;">1:</span><span class="ps-keyword">function </span><span class="ps-funcname">Find</span>(Node t,var x)</p>
<div class="ps-block" style="margin-left:1.2em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-1.5em;">2:</span><span class="ps-keyword">if </span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t.val = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><span class="ps-keyword"> then</span></p>
<div class="ps-block" style="margin-left:1.2em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-3em;">3:</span><span class="ps-keyword">return </span>TRUE</p>
</div>
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-1.5em;">4:</span><span class="ps-keyword">else if </span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">t = \varnothing </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span><span class="ps-keyword"> then</span></p>
<div class="ps-block" style="margin-left:1.2em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-3em;">5:</span><span class="ps-keyword">return </span>False</p>
</div>
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-1.5em;">6:</span><span class="ps-keyword">else if </span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>t</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">x &gt; t.val </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span><span class="ps-keyword"> then</span></p>
<div class="ps-block" style="margin-left:1.2em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-3em;">7:</span><span class="ps-keyword">return </span>Find(t.right,x)</p>
</div>
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-1.5em;">8:</span><span class="ps-keyword">else</span></p>
<div class="ps-block" style="margin-left:1.2em;">
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-3em;">9:</span><span class="ps-keyword">return </span>Find(t.left,x)</p>
</div>
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:-1.5em;">10:</span><span class="ps-keyword">end if</span></p>
</div>
<p class="ps-line ps-code">
<span class="ps-linenum" style="left:0em;">11:</span><span class="ps-keyword">end function</span></p>
</div>
</div>
</div>
</div></p>
<p><strong>正确性证明:</strong>
我们使用结构归纳法 (structural induction) 来证明 <code>find(T, x)</code> 的正确性。设 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 为树 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 的根节点，其键为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>，其左右子树分别为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>。</p>
<p>BST 的不变量是： <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>y</mi><mo>∈</mo><msub><mi>T</mi><mi>L</mi></msub><mo separator="true">,</mo><mtext>key</mtext><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\forall y \in T_L, \text{key}(y) &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">key</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq> 且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msub><mi>T</mi><mi>R</mi></msub><mo separator="true">,</mo><mtext>key</mtext><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\forall z \in T_R, \text{key}(z) &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">key</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>。</p>
<p><strong>基本情况 (Base Case):</strong>
当树 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 为空 (<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">T = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span></eq>) 时，<code>find(T, x)</code> 返回 <code>false</code>，这是正确的，因为空树不包含任何元素。</p>
<p><strong>归纳步骤 (Inductive Step):</strong>
假设对于子树 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，<code>find</code> 操作是正确的。我们需要证明 <code>find(T, x)</code> 对整个树 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 也正确。</p>
<p><code>find</code> 算法的逻辑如下：</p>
<ol>
<li>
<p><strong>若 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq></strong>: 算法返回 <code>true</code>。这显然是正确的。</p>
</li>
<li>
<p><strong>若 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq></strong>: 算法递归调用 <code>find(T_L, x)</code>。根据 BST 不变量，任何在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中的键都大于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>，所以 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 不可能存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中。因此，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中当且仅当它存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中。即：
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>T</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><msub><mi>T</mi><mi>L</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (x \in T) \iff (x \in T_L) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section>
根据归纳假设，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>L</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">find(T_L, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 的结果是正确的，因此 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">find(T, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 的结果也是正确的。</p>
</li>
<li>
<p><strong>若 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq></strong>: 算法递归调用 <code>find(T_R, x)</code>。同理，根据 BST 不变量，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 不可能存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">T_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中。因此，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中当且仅当它存在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">T_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中。即：
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>T</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><msub><mi>T</mi><mi>R</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (x \in T) \iff (x \in T_R) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section>
根据归纳假设，<code>find(T_R, x)</code> 的结果是正确的，因此 <code>find(T, x)</code> 的结果也是正确的。</p>
</li>
</ol>
<p>综上所述，<code>find</code> 操作的正确性得以证明。其递归深度最多为树的高度 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></eq>，所以时间复杂度为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></eq>。</p>
<div class="code-tabs">
<ul>
<li><input type="radio" name="label-group-112" checked><label for="group-112-tab-0" onclick="this.previousElementSibling.click()">cpp</label></li>
<li><input type="radio" name="label-group-112"><label for="group-112-tab-1" onclick="this.previousElementSibling.click()">haskell</label></li>
</ul>
<input type="radio" id="group-112-tab-0" name="group-112" checked>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div>
        <code>struct Node <span class="token punctuation">{</span>
    int key<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//非递归实现</span>
void <span class="token function">find</span><span class="token punctuation">(</span> int x<span class="token punctuation">,</span> Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">&lt;</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">></span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
      <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归实现</span>
bool <span class="token function">find_dfs</span><span class="token punctuation">(</span>int x<span class="token punctuation">,</span> Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">find_dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">find_dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<input type="radio" id="group-112-tab-1" name="group-112">
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>
        <code><span class="token hvariable">find</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">find</span> <span class="token hvariable">_</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code>
    </pre>
</div>
</div>
<h4>2. <code>insert(x)</code> - 插入操作</h4>
<p><strong>数学原理:</strong>
插入操作首先像 <code>find</code> 一样，在树中寻找 <code>x</code> 的位置。这个搜索过程最终会到达一个 <code>NULL</code> 链接（即一个空子树），这就是 <code>x</code> 应该被插入的地方。创建一个新节点并链接到该位置。</p>
<p><strong>正确性证明 (保持 BST 不变量):</strong>
我们通过归纳法证明 <code>insert</code> 操作会保持 BST 不变量。</p>
<ul>
<li><strong>基本情况:</strong> 向一棵空树插入节点 <code>x</code>，会创建一个只包含 <code>x</code> 的新树。这个树显然满足 BST 不变量。</li>
<li><strong>归纳假设:</strong> 假设向一棵大小为 <code>n</code> 的树 <code>T</code> 中插入节点能保持 BST 不变量。</li>
<li><strong>归纳步骤:</strong> 考虑向大小为 <code>n+1</code> 的树 <code>T'</code> 中插入节点 <code>x</code>。<code>insert</code> 算法会沿着一条路径向下，设路径上最后一个节点为 <code>P</code>。
<ul>
<li>如果 <code>x &lt; P.key</code>，<code>x</code> 将被作为 <code>P</code> 的新左孩子插入。由于 <code>x &lt; P.key</code>，并且路径上所有 <code>P</code> 的祖先都满足 BST 不变量，所以插入后，<code>x</code> 依然小于 <code>P</code> 和 <code>P</code> 的所有右侧祖先，且大于所有左侧祖先。</li>
<li>如果 <code>x &gt; P.key</code>，<code>x</code> 将被作为 <code>P</code> 的新右孩子插入，同理也保持不变量。</li>
<li>（如果 <code>x</code> 已存在，则不进行任何操作，不变量自然保持。）
由于新节点总是作为叶子节点插入，它不会改变树中任何现有节点之间的关系。它只在 <code>find</code> 路径的末端建立了一个新的、正确的父子关系。因此，BST 不变量得以保持。
时间复杂度与 <code>find</code> 相同，为 <code>O(h)</code>。</li>
</ul>
</li>
</ul>
<div class="code-tabs">
<ul>
<li><input type="radio" name="label-group-157" checked><label for="group-157-tab-0" onclick="this.previousElementSibling.click()">cpp</label></li>
<li><input type="radio" name="label-group-157"><label for="group-157-tab-1" onclick="this.previousElementSibling.click()">haskell</label></li>
</ul>
<input type="radio" id="group-157-tab-0" name="group-157" checked>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div>
        <code>struct Node <span class="token punctuation">{</span>
    int key<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//非递归实现</span>
void <span class="token function">insert</span><span class="token punctuation">(</span> int x<span class="token punctuation">,</span> Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">*</span> p <span class="token operator">=</span> t<span class="token punctuation">,</span>parent <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 记录父节点</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">&lt;</span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">></span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
      <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//do nothing</span>
    <span class="token punctuation">}</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span> <span class="token comment">// 设置新节点的父节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">// 树为空，新节点为根</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> parent<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 根据 BST 不变量决定插入位置</span>
        parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归实现</span>
void <span class="token function">insert_dfs</span><span class="token punctuation">(</span>int x<span class="token punctuation">,</span> Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">insert_dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">insert_dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果 x == t->key，不做任何操作</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<input type="radio" id="group-157-tab-1" name="group-157">
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>
        <code><span class="token hvariable">insert</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span>
<span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span>
</code>
    </pre>
</div>
</div>
<hr>
<h4>3. <code>findMin()</code> - 查找最小值</h4>
<p><strong>数学原理:</strong>
根据 BST 不变量，对于任何节点 <code>N</code>，其左子树中的所有值都比它小。因此，树中最小的值必须位于从根开始不断向左遍历所能达到的最深节点。</p>
<p><strong>正确性证明:</strong>
这是一个直接推论。假设最小值 <code>m</code> 不在最左侧的路径上。那么 <code>m</code> 所在的节点 <code>M</code> 必然是某个节点 <code>P</code> 的右孩子，或者它自己有一个左孩子 <code>L</code>。</p>
<ul>
<li>如果 <code>M</code> 有左孩子 <code>L</code>，则 <code>L.key &lt; M.key</code>，所以 <code>M</code> 不是最小值，矛盾。</li>
<li>如果 <code>M</code> 是 <code>P</code> 的右孩子，则 <code>P.key &lt; M.key</code>，所以 <code>M</code> 不是最小值，矛盾。
因此，最小值必须位于没有左孩子的、最靠左的节点上。时间复杂度为 <code>O(h)</code>，即从根到最左叶子的路径长度。</li>
</ul>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div>
        <code>struct Node <span class="token punctuation">{</span>
    int key<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//非递归实现</span>
int <span class="token function">findMin</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归实现</span>
int <span class="token function">findMin_dfs</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">findMin_dfs</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">findMax</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div>
        <code><span class="token hvariable">findMin</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">findMin</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">findMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">k</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">k</span>
<span class="token hvariable">findMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">findMin</span> <span class="token hvariable">l</span>
</code>
    </pre>
</div>
<hr>
<h2 id="succ-%E5%90%8E%E7%BB%A7%E4%B8%8E-prev-%E5%89%8D%E9%A9%B1" tabindex="-1"><code>succ</code> 后继与 <code>prev</code> 前驱</h2>
<p><code>succ</code> (Successor) 和 <code>prev</code> (Predecessor) 分别指 BST 中序遍历序列中一个节点的后一个节点和前一个节点。换句话说：</p>
<ul>
<li><strong>后继 (Successor)</strong>: 树中键值<strong>大于</strong>当前节点键值的节点中，键值<strong>最小</strong>的那个。</li>
<li><strong>前驱 (Predecessor)</strong>: 树中键值<strong>小于</strong>当前节点键值的节点中，键值<strong>最大</strong>的那个。</li>
</ul>
<p>这两个操作对于实现需要顺序访问的功能（如 <code>delete</code> 操作或构建有序迭代器）至关重要。<code>succ</code> 和 <code>prev</code> 的高效实现有两种思路：</p>
<ol>
<li>如果节点定义中包含 <code>parent</code> 指针，可以方便地在树中向上移动。</li>
<li>在纯函数式、无 <code>parent</code> 指针的场景下，需要从根节点开始查找，并一路记录“候选”的后继或前驱。</li>
</ol>
<hr>
<h3 id="1.-succ(x)---%E6%9F%A5%E6%89%BE%E5%90%8E%E7%BB%A7" tabindex="-1">1. <code>succ(x)</code> - 查找后继</h3>
<p><strong>数学原理:</strong>
对于给定的节点 <code>x</code>，其后继节点 <code>s</code> 的查找分为两种情况：</p>
<ol>
<li><strong>如果 <code>x</code> 存在右子树:</strong> 那么 <code>x</code> 的后继就是其<strong>右子树中的最小节点</strong>。因为右子树中所有节点都比 <code>x</code> 大，而其中最小的那个自然就是紧随 <code>x</code> 之后的节点。</li>
<li><strong>如果 <code>x</code> 不存在右子树:</strong> 那么需要从 <code>x</code> 开始<strong>向上回溯</strong>父节点。后继是第一个“从左边分支上来的祖先节点”。换言之，我们持续向上查找，直到找到一个节点 <code>p</code>，使得当前节点是 <code>p</code> 的左子树上的点。这个 <code>p</code> 就是 <code>x</code> 的后继。如果一路向上直到根节点，当前节点都是右孩子，那么说明 <code>x</code> 是树中最大的元素，它没有后继。</li>
</ol>
<blockquote>
<p>思考🤔, 对于任意一个点x: 哪些点比x大?
容易想到: 在中序序列中,比x位置靠后的都比x大.</p>
<ol>
<li>x右子树上的点</li>
<li>考虑x的祖先u
<ol>
<li>如果x在u的右子树上,那么x &gt; u</li>
<li>如果x在u的左子树上,那么x &lt; u,我们称这些祖先点为<strong>左祖先点</strong></li>
<li>离x越近的左祖先点,越小
anc1(x) anc2(x)  都是x的 左祖先结点,且 dep(anc1) &lt; dep(anc2) ,那说明anc1 离 x比较远, 那么 anc1 是anc2的左祖先结点(比较容易证明,只要证明,x的父亲在anc1的左子树上,然后归纳)</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>正确性证明:</strong>
设要查找后继的节点为 <code>x</code>。</p>
<p><strong>情况 1: <code>x</code> 有右子树 <code>R_x</code></strong></p>
<ul>
<li>根据 BST 不变量，<code>R_x</code> 中的所有节点的键值都大于 <code>x.key</code>。</li>
<li>同时，任何不属于 <code>x</code> 的子树且键值大于 <code>x.key</code> 的节点（即 <code>x</code> 的某个祖先 <code>A</code>），其键值必然也大于 <code>R_x</code> 中所有节点的键值（因为 <code>x</code> 及其子树 <code>R_x</code> 都位于 <code>A</code> 的左子树中）。</li>
<li>因此，大于 <code>x.key</code> 的最小键值必然存在于 <code>R_x</code> 中。这个值就是 <code>R_x</code> 的最小值。</li>
<li>算法通过 <code>findMin(x.right)</code> 找到此节点，是正确的。</li>
</ul>
<p><strong>情况 2: <code>x</code> 没有右子树</strong></p>
<ul>
<li>此时，任何 <code>x</code> 的后代（在这里就是空）的键值都不可能大于 <code>x.key</code>。所以后继只可能在 <code>x</code> 的祖先中。</li>
<li>我们从 <code>x</code> 向上遍历，设当前节点为 <code>curr</code>，其父节点为 <code>p</code>。
<ul>
<li><strong>如果 <code>curr</code> 是 <code>p</code> 的右孩子 (<code>curr == p.right</code>)</strong>: 这意味着 <code>p.key &lt; curr.key</code>。由于我们是从 <code>x</code> 开始向上，所以 <code>p.key</code> 也小于 <code>x.key</code>。<code>p</code> 不可能是后继，我们必须继续向上寻找。</li>
<li><strong>如果 <code>curr</code> 是 <code>p</code> 的左孩子 (<code>curr == p.left</code>)</strong>: 这意味着 <code>p.key &gt; curr.key</code>。因为 <code>p</code> 是第一个满足此条件的祖先，所有在 <code>p</code> 和 <code>x</code> 之间的祖先节点（<code>curr</code> 的父节点、祖父节点等）的键值都小于 <code>x.key</code>。因此，<code>p</code> 就是大于 <code>x.key</code> 的最小键值节点，即 <code>x</code> 的后继。</li>
</ul>
</li>
<li>算法中的 <code>while</code> 循环 (<code>while (p != nullptr &amp;&amp; x == p.right)</code>) 正是实现了这个过程：不断向上移动，直到当前节点不再是父节点的右孩子。此时的父节点 <code>p</code> 就是后继。如果循环结束时 <code>p</code> 为 <code>nullptr</code>，说明 <code>x</code> 是树中的最大元素，没有后继。</li>
</ul>
<hr>
<h3 id="2.-prev(x)---%E6%9F%A5%E6%89%BE%E5%89%8D%E9%A9%B1" tabindex="-1">2. <code>prev(x)</code> - 查找前驱</h3>
<p><strong>数学原理:</strong>
<code>prev</code> 的逻辑与 <code>succ</code> 完全对称。对于节点 <code>x</code>：</p>
<ol>
<li><strong>如果 <code>x</code> 存在左子树:</strong> 那么 <code>x</code> 的前驱就是其<strong>左子树中的最大节点</strong>。</li>
<li><strong>如果 <code>x</code> 不存在左子树:</strong> 从 <code>x</code> 开始<strong>向上回溯</strong>，直到找到一个节点 <code>p</code>，使得当前节点是 <code>p</code> 的右孩子。这个 <code>p</code> 就是前驱。如果一路向上直到根节点，当前节点都是左孩子，那么 <code>x</code> 是树中最小的元素，它没有前驱。</li>
</ol>
<blockquote>
<p>思考🤔, 对于任意一个点x: 哪些点比x小?
容易想到: 在中序序列中,比x位置靠前的都比x小.序列中离x最近的就是前驱</p>
<ol>
<li>如果x存在左子树,左子树中的最小值离x最近</li>
<li>如果x不存在左子树,显然离x最近的<strong>右子树祖先</strong>,就是最接近x的</li>
</ol>
</blockquote>
<p><strong>正确性证明:</strong>
证明过程与 <code>succ</code> 对称。</p>
<p><strong>情况 1: <code>x</code> 有左子树 <code>L_x</code></strong></p>
<ul>
<li><code>L_x</code> 中所有节点的键值都小于 <code>x.key</code>。</li>
<li>小于 <code>x.key</code> 的最大键值必然存在于 <code>L_x</code> 中，即 <code>L_x</code> 的最大值。</li>
<li>算法通过 <code>findMax(x.left)</code> 找到此节点，是正确的。</li>
</ul>
<p><strong>情况 2: <code>x</code> 没有左子树</strong></p>
<ul>
<li>前驱只可能在 <code>x</code> 的祖先中。</li>
<li>我们向上遍历，设当前节点为 <code>curr</code>，父节点为 <code>p</code>。
<ul>
<li><strong>如果 <code>curr</code> 是 <code>p</code> 的左孩子</strong>: <code>p.key &gt; curr.key</code>，<code>p</code> 不是前驱，继续向上。</li>
<li><strong>如果 <code>curr</code> 是 <code>p</code> 的右孩子</strong>: <code>p.key &lt; curr.key</code>。<code>p</code> 是第一个满足此条件的祖先，因此 <code>p</code> 是小于 <code>x.key</code> 的最大键值节点，即 <code>x</code> 的前驱。</li>
</ul>
</li>
<li>算法的 <code>while</code> 循环实现了此逻辑，是正确的。</li>
</ul>
<hr>
<h3 id="3.-%E5%AE%9E%E7%8E%B0" tabindex="-1">3. 实现</h3>
<h4>C++ (带 <code>parent</code> 指针)</h4>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div>
        <code>struct Node <span class="token punctuation">{</span>
    int key<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">key</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 辅助函数：在以 t 为根的子树中找到最小节点</span>
Node<span class="token operator">*</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 辅助函数：在以 t 为根的子树中找到最大节点</span>
Node<span class="token operator">*</span> <span class="token function">findMaxNode</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找后继</span>
Node<span class="token operator">*</span> <span class="token function">succ</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>

    <span class="token comment">// 情况 1: 节点有右子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 情况 2: 节点没有右子树</span>
    Node<span class="token operator">*</span> p <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> nullptr <span class="token operator">&amp;&amp;</span> x <span class="token operator">==</span> p<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">// p 是后继, 或者 p 是 nullptr (x是最大值)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找前驱</span>
Node<span class="token operator">*</span> <span class="token function">prev</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>

    <span class="token comment">// 情况 1: 节点有左子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">findMaxNode</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 情况 2: 节点没有左子树</span>
    Node<span class="token operator">*</span> p <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> nullptr <span class="token operator">&amp;&amp;</span> x <span class="token operator">==</span> p<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">// p 是前驱, 或者 p 是 nullptr (x是最小值)</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<h4>Haskell (纯函数式)</h4>
<p>在纯函数式编程中，数据结构是不可变的，通常没有父指针。因此，查找后继或前驱需要从根开始遍历。</p>
<p><strong>算法思路 (以 <code>succ</code> 为例):</strong>
从根节点开始向下查找目标值 <code>x</code>。</p>
<ul>
<li>当向<strong>左</strong>走时（即 <code>x &lt; 当前节点k</code>），当前节点 <code>k</code> 是一个潜在的后继，因为 <code>k &gt; x</code>。我们记录下这个 <code>k</code>，然后继续在左子树中寻找更精确（即更小）的后继。</li>
<li>当向<strong>右</strong>走时（即 <code>x &gt; 当前节点k</code>），当前节点 <code>k</code> 小于 <code>x</code>，不可能是后继。我们继续在右子树中查找 <code>x</code>，但无需更新潜在的后继。</li>
<li>当找到 <code>x</code> 时：
<ul>
<li>如果 <code>x</code> 有右子树，后继就是其右子树的最小值。</li>
<li>如果 <code>x</code> 没有右子树，那么我们在下降过程中记录的最后一个“潜在后继”（即最近的那个我们向左拐弯时的节点）就是最终的后继。</li>
</ul>
</li>
</ul>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div>
        <code><span class="token comment">-- 查找 BST 中的最大元素 (findMin 已在之前定义)</span>
<span class="token hvariable">findMax</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">findMax</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">findMax</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">k</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">k</span>
<span class="token hvariable">findMax</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">findMax</span> <span class="token hvariable">r</span>

<span class="token comment">-- 在纯函数式 BST 中查找后继</span>
<span class="token comment">-- 需要整个树和目标键值</span>
<span class="token comment">-- `best` 参数在向下递归时，记录“目前为止最好的后继候选”</span>
<span class="token builtin">succ</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token builtin">succ</span> <span class="token hvariable">x</span> <span class="token hvariable">tree</span> <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">tree</span> <span class="token constant">Nothing</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">go</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
    <span class="token hvariable">go</span> <span class="token constant">Empty</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token comment">-- 树为空或未找到</span>
    <span class="token hvariable">go</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token hvariable">best</span>
        <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token comment">-- k 是一个可能的后继, 继续在左子树找更接近的</span>
        <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">r</span> <span class="token hvariable">best</span>     <span class="token comment">-- 后继在右子树, best 不变</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token comment">-- 找到了键 x (k == x)</span>
            <span class="token keyword">case</span> <span class="token hvariable">r</span> <span class="token keyword">of</span>
                <span class="token constant">Empty</span> <span class="token operator">-></span> <span class="token hvariable">best</span>      <span class="token comment">-- 没有右子树, 那么 best (最近的左拐祖先) 就是后继</span>
                <span class="token hvariable">_</span>     <span class="token operator">-></span> <span class="token hvariable">findMin</span> <span class="token hvariable">r</span> <span class="token comment">-- 有右子树, 后继是右子树的最小值</span>

<span class="token comment">-- 纯函数式的前驱查找，逻辑对称</span>
<span class="token hvariable">prev</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">prev</span> <span class="token hvariable">x</span> <span class="token hvariable">tree</span> <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">tree</span> <span class="token constant">Nothing</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">go</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
    <span class="token hvariable">go</span> <span class="token constant">Empty</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token hvariable">go</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token hvariable">best</span>
        <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">l</span> <span class="token hvariable">best</span>     <span class="token comment">-- 前驱在左子树, best 不变</span>
        <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">go</span> <span class="token hvariable">r</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token comment">-- k 是一个可能的前驱, 在右子树找更接近的</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token comment">-- 找到了键 x (k == x)</span>
            <span class="token keyword">case</span> <span class="token hvariable">l</span> <span class="token keyword">of</span>
                <span class="token constant">Empty</span> <span class="token operator">-></span> <span class="token hvariable">best</span>      <span class="token comment">-- 没有左子树, best (最近的右拐祖先) 就是前驱</span>
                <span class="token hvariable">_</span>     <span class="token operator">-></span> <span class="token hvariable">findMax</span> <span class="token hvariable">l</span> <span class="token comment">-- 有左子树, 前驱是左子树的最大值</span>
</code>
    </pre>
</div>
<h2 id="rank-%E6%8E%92%E5%90%8D%E4%B8%8E-atrank-%E9%80%89%E6%8B%A9" tabindex="-1"><code>rank</code> 排名与 <code>atRank</code> 选择</h2>
<h3 id="1.-rank(x)---%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D" tabindex="-1">1. <code>rank(x)</code> - 查找元素排名</h3>
<p><code>rank(x)</code> 返回元素 <code>x</code> 在有序序列中的排名（第几小的元素，从1开始）。</p>
<h4>C++ (带 <code>parent</code> 指针)</h4>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div>
        <code><span class="token comment">// 辅助函数：计算子树的大小</span>
int <span class="token function">subtreeSize</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">subtreeSize</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">subtreeSize</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找元素 x 的排名</span>
int <span class="token function">rank</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> int x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">rankHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">rankHelper</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> int x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 空树，任何元素排名都是1</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// x 在左子树中</span>
        <span class="token keyword">return</span> <span class="token function">rankHelper</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> t<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// x 在右子树中，排名 = 左子树大小 + 当前节点 + 右子树中的排名</span>
        int leftSize <span class="token operator">=</span> <span class="token function">subtreeSize</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> leftSize <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">rankHelper</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 找到 x，排名 = 左子树大小 + 1</span>
        <span class="token keyword">return</span> <span class="token function">subtreeSize</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<h4>Haskell (纯函数式)</h4>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div>
        <code><span class="token comment">-- | 计算 x 在树中的排名 (第几小的元素，从1开始)</span>
<span class="token hvariable">rank</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">-- 在空树中，任何元素的排名都是1</span>
<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span>                    <span class="token comment">-- x 在左子树中</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span>       <span class="token comment">-- x 在右子树中，跳过左子树和当前节点的所有重复值</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token number">1</span>                  <span class="token comment">-- x 等于当前键，排名是左子树大小 + 1（第一个出现的位置）</span>

<span class="token comment">-- | 计算树中元素的总个数 (包括重复值)</span>
<span class="token hvariable">size</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">size</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token hvariable">size</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token hvariable">size</span> <span class="token hvariable">r</span>
</code>
    </pre>
</div>
<h3 id="2.-atrank(k)---%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0" tabindex="-1">2. <code>atRank(k)</code> - 查找第k小的元素</h3>
<p><code>atRank(k)</code> 返回第 <code>k</code> 小的元素，其中 <code>k</code> 从1开始。</p>
<h4>C++ (带 <code>parent</code> 指针)</h4>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div>
        <code><span class="token comment">// 查找第 k 小的元素</span>
Node<span class="token operator">*</span> <span class="token function">atRank</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> int k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">atRankHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Node<span class="token operator">*</span> <span class="token function">atRankHelper</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> int k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> nullptr <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
    
    int leftSize <span class="token operator">=</span> <span class="token function">subtreeSize</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> leftSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第 k 小的元素在左子树中</span>
        <span class="token keyword">return</span> <span class="token function">atRankHelper</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第 k 小的元素是当前节点</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第 k 小的元素在右子树中</span>
        <span class="token keyword">return</span> <span class="token function">atRankHelper</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> k <span class="token operator">-</span> leftSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<h4>Haskell (纯函数式)</h4>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div>
        <code><span class="token comment">-- | 返回第 k 小的元素 (k 从1开始)</span>
<span class="token comment">-- | 如果 k 超出范围，返回 Nothing</span>
<span class="token hvariable">atRank</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k'</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">k</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token constant">Nothing</span>                     <span class="token comment">-- k 无效</span>
    <span class="token operator">|</span> <span class="token hvariable">leftSize</span> <span class="token operator">>=</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token hvariable">l</span>              <span class="token comment">-- 在左子树中</span>
    <span class="token operator">|</span> <span class="token hvariable">leftSize</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">>=</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">k'</span>             <span class="token comment">-- 在当前节点中</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">atRank</span> <span class="token punctuation">(</span><span class="token hvariable">k</span> <span class="token operator">-</span> <span class="token hvariable">leftSize</span> <span class="token operator">-</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token hvariable">r</span> <span class="token comment">-- 在右子树中</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">leftSize</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span>
</code>
    </pre>
</div>
<h3 id="3.-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">3. 复杂度分析</h3>
<p>两个操作的时间复杂度都为 <strong>O(h)</strong>，其中 <code>h</code> 是树的高度：</p>
<ul>
<li><strong>最优情况</strong>（完全平衡树）：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></li>
<li><strong>最坏情况</strong>（链状树）：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></li>
</ul>
<p>空间复杂度为 <strong>O(h)</strong>（递归栈空间）。</p>
<h3 id="4.-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">4. 应用场景</h3>
<ul>
<li><strong>顺序统计树</strong>：快速查找第 k 小的元素</li>
<li><strong>中位数查找</strong>：<code>atRank (n/2)</code> 找到中位数</li>
<li><strong>排名查询</strong>：<code>rank x</code> 找到元素的相对位置</li>
<li><strong>范围查询</strong>：结合 <code>rank</code> 和 <code>atRank</code> 实现范围统计</li>
</ul>
<h4>4. <code>deleteMin()</code> - 删除最小值</h4>
<p><strong>数学原理:</strong>
<code>deleteMin</code> 建立在 <code>findMin</code> 的基础上。首先，找到最小节点 <code>M</code>。<code>M</code> 必没有左子树。要删除它，我们只需将其父节点（设为 <code>P</code>）的左链接指向 <code>M</code> 的右子树即可。</p>
<p><strong>正确性证明 (保持 BST 不变量):</strong>
设 <code>M</code> 是树中的最小节点，<code>P</code> 是它的父节点（<code>M = P.left</code>）。</p>
<ol>
<li><code>M</code> 没有左子树（根据 <code>findMin</code> 的证明）。</li>
<li><code>M</code> 可能有也可能没有右子树 <code>R</code>。</li>
<li>根据 BST 不变量，<code>P.key &gt; M.key</code>。并且，<code>R</code> 中所有节点的值 <code>r_i</code> 都满足 <code>r_i &gt; M.key</code>。</li>
<li>同时，因为 <code>M</code> 是 <code>P</code> 的左孩子，<code>P</code> 及其所有祖先节点的值都大于 <code>R</code> 中任意节点的值。即 <code>P.key &gt; r_i</code>。</li>
</ol>
<p>当我们用 <code>R</code> 替换 <code>M</code> 作为 <code>P</code> 的左孩子时，新的关系是 <code>P.left = R</code>。由于我们已经知道 <code>P.key &gt; r_i</code> 对于 <code>R</code> 中所有节点都成立，所以 BST 不变量在 <code>P</code> 节点处得以保持。树的其他部分没有受到影响。因此，操作是正确的。时间复杂度为 <code>O(h)</code>。</p>
<hr>
<h4>5. <code>delete(x)</code> - 删除操作</h4>
<p><strong>数学原理:</strong>
删除操作是最复杂的情况，因为它需要处理三种不同的场景来维持 BST 不变量。设要删除的节点为 <code>N</code>。</p>
<ol>
<li><strong><code>N</code> 是叶子节点:</strong> 直接删除即可，不影响其他节点。</li>
<li><strong><code>N</code> 只有一个子树:</strong> 将 <code>N</code> 的父节点直接链接到 <code>N</code> 的那个孩子上，从而绕过 <code>N</code>。</li>
<li><strong><code>N</code> 有两个孩子:</strong> 这是最关键的情况。我们不能简单地删除 <code>N</code>，因为会留下两个子树需要处理。解决方法是：
a. 在 <code>N</code> 的右子树中找到最小值（这个值被称为 <code>N</code> 的<strong>中序后继</strong>，Successor）。设为 <code>S</code>。
b. 将 <code>N</code> 节点的值替换为 <code>S</code> 的值。
c. 递归地删除节点 <code>S</code>（此时 <code>S</code> 最多只有一个右孩子，将其转化为情况 1 或 2）。</li>
</ol>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi mathvariant="normal">∅</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">delete( x, \varnothing) = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord amsrm">∅</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span></span></eqn></section><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mspace width="1em"/><mi>x</mi><mspace width="1em"/><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&lt;</mo><mi>k</mi><mo>:</mo><mo stretchy="false">(</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>x</mi><mtext> </mtext><mi>l</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&gt;</mo><mi>k</mi><mo>:</mo><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>x</mi><mtext> </mtext><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><mi>k</mi><mo>:</mo><mi>d</mi><mi>e</mi><mi>l</mi><mtext> </mtext><mi>l</mi><mtext> </mtext><mi>r</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
delete\quad x\quad (l,k,r) = \begin{cases}
x &lt; k: (delete\ x\ l,k,r) \\
x &gt; k: (l,k,delete\ x\ r) \\
x = k: del\ l\ r
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section><p>其中:</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mtext> </mtext><mi mathvariant="normal">∅</mi><mtext> </mtext><mi>r</mi><mo>=</mo><mi>r</mi><mspace linebreak="newline"></mspace><mi>d</mi><mi>e</mi><mi>l</mi><mtext> </mtext><mi>l</mi><mtext> </mtext><mi mathvariant="normal">∅</mi><mo>=</mo><mi>l</mi><mspace linebreak="newline"></mspace><mi>d</mi><mi>e</mi><mi>l</mi><mtext> </mtext><mi>l</mi><mtext> </mtext><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>y</mi><mtext> </mtext><mi>r</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mi>min</mi><mo>⁡</mo><mi>r</mi><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">
del\ \varnothing \ r = r \\
del\ l\ \varnothing = l \\
del\ l\ r = (l,y,delete\ y\ r), y = \min r \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7761em;vertical-align:-0.0817em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord amsrm">∅</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7761em;vertical-align:-0.0817em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord amsrm">∅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mspace newline"></span></span></span></span></eqn></section><p><strong>正确性证明 (保持 BST 不变量):</strong></p>
<ul>
<li><strong>情况 1 (叶子节点):</strong> 删除叶子节点不会改变任何祖先节点的子树结构，显然保持不变量。</li>
<li><strong>情况 2 (单孩子节点):</strong> 假设 <code>N</code> 有一个左孩子 <code>L</code>（右孩子同理），其父节点为 <code>P</code>。我们有 <code>P.key &gt; N.key &gt; L.key</code>。将 <code>P</code> 的链接指向 <code>L</code> 后，新的关系是 <code>P.key &gt; L.key</code>，这符合 BST 不变量。</li>
<li><strong>情况 3 (双孩子节点):</strong>
<ul>
<li>设 <code>N</code> 的左右子树分别为 <code>L_N</code> 和 <code>R_N</code>。</li>
<li>我们找到 <code>R_N</code> 中的最小值 <code>S</code>。根据定义，<code>S</code> 是大于 <code>N.key</code> 的所有值中最小的一个。</li>
<li>当我们将 <code>N</code> 的值替换为 <code>S</code> 的值后，新的 <code>N</code> 节点（我们称之为 <code>N'</code>）满足：
<ul>
<li><code>N'.key</code> 大于 <code>L_N</code> 中所有节点的值（因为 <code>S.key &gt; N.key</code>）。</li>
<li><code>N'.key</code> 小于 <code>R_N</code> 中所有其他节点的值（因为 <code>S</code> 是 <code>R_N</code> 的最小值）。</li>
</ul>
</li>
<li>此时，BST 的结构不变量在 <code>N'</code> 处得到了满足。</li>
<li>接下来，我们需要从 <code>R_N</code> 中删除原先的 <code>S</code> 节点。根据 <code>findMin</code> 的原理，<code>S</code> 节点自身没有左孩子。因此，删除 <code>S</code> 的问题就退化为了更简单的情况 1 或情况 2。</li>
<li>由于退化后问题的解决是正确的（已证明），因此整个删除操作也是正确的。</li>
</ul>
</li>
</ul>
<p>整个 <code>delete</code> 操作的复杂度也是由查找节点和（在情况3中）查找后继节点决定的，时间复杂度为 <code>O(h)</code>。</p>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div>
        <code><span class="token comment">-- | 从 BST 中删除一个值</span>
<span class="token comment">-- | 这里的逻辑直接翻译自原文中的 'delete' 和 'del' 助手函数</span>
<span class="token hvariable">delete</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">delete</span> <span class="token hvariable">_</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token comment">-- 从空树删除，返回空树</span>
<span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span> <span class="token comment">-- 要删除的值在左子树</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token comment">-- 要删除的值在右子树</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>               <span class="token comment">-- 找到了要删除的节点 (k == x)，调用 del</span>
    <span class="token keyword">where</span>
        <span class="token comment">-- | 'del' 助手函数处理删除根节点的情况</span>
        <span class="token hvariable">del</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
        <span class="token hvariable">del</span> <span class="token constant">Empty</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token hvariable">r</span> <span class="token comment">-- 没有左子树，用右子树替换</span>
        <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token hvariable">l</span> <span class="token comment">-- 没有右子树，用左子树替换</span>
        <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>     <span class="token operator">=</span> <span class="token comment">-- 有两个子节点</span>
            <span class="token comment">-- 1. 找到右子树的最小值 (k') 作为新的根</span>
            <span class="token comment">-- 2. 新树的左子树是 l</span>
            <span class="token comment">-- 3. 新树的右子树是 *删除* 了 k' 的原右子树 (r)</span>
            <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">k'</span><span class="token punctuation">,</span> <span class="token hvariable">r'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">deleteMinHelper</span> <span class="token hvariable">r</span> <span class="token comment">-- 找到并删除右子树的最小值</span>
            <span class="token keyword">in</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k'</span> <span class="token hvariable">r'</span>

<span class="token comment">-- | 助手函数：找到并删除最小节点 (用于 'delete' 操作)</span>
<span class="token comment">-- | 返回 (最小值的键, 删除了最小值的子树)</span>
<span class="token comment">-- | 这是一个高效的函数式实现，避免了对右子树的两次遍历。</span>
<span class="token hvariable">deleteMinHelper</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">deleteMinHelper</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"deleteMinHelper: called on empty tree"</span> <span class="token comment">-- 逻辑上不应该发生</span>
<span class="token hvariable">deleteMinHelper</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token comment">-- 找到了最小值 (k)，用其右子树 (r) 替换</span>
<span class="token hvariable">deleteMinHelper</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">minKey</span><span class="token punctuation">,</span> <span class="token hvariable">newL</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">deleteMinHelper</span> <span class="token hvariable">l</span> <span class="token comment">-- 最小值在左子树</span>
    <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">minKey</span><span class="token punctuation">,</span> <span class="token constant">Node</span> <span class="token hvariable">newL</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
</code>
    </pre>
</div>
<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>
<ul>
<li>增
<ul>
<li>insert</li>
</ul>
</li>
<li>删
<ul>
<li>delete</li>
<li>deleteMin</li>
<li>deleteMax</li>
</ul>
</li>
<li>查
<ul>
<li>find</li>
<li>findMin</li>
<li>findMax</li>
<li>succ</li>
<li>pred</li>
</ul>
</li>
<li>遍历
<ul>
<li>中序遍历会得到一个有序的序列</li>
<li>mapt</li>
<li>foldt</li>
</ul>
</li>
</ul>
<p><code>insert</code>,<code>find</code>,<code>delete</code>都很简单,就是简单的递归</p>
<p><code>succ</code>和<code>pred</code>比较复杂,需要考虑父节点
<code>delete</code>也比较复杂,需要考虑左右子树</p>
<h2 id="%E7%AD%89%E5%BE%85%E6%95%B4%E7%90%86" tabindex="-1">等待整理</h2>
<p>这是一个非常好的练习。您提供的伪代码混合了两种不同的编程范式：</p>
<ol>
<li><strong>函数式 (Functional)：</strong> <code>insert</code>、<code>delete</code>、<code>mapt</code>、<code>foldt</code> 这些函数不修改（mutate）原有的树，而是返回一个全新的、修改后的树。</li>
<li><strong>命令式 (Imperative)：</strong> <code>Node</code> 定义中的 <code>parent</code> 指针、以及依赖它的 <code>succ</code> (后继) 函数，都依赖于能够修改数据和在数据结构中“向上”导航。</li>
</ol>
<p>因此，在下面的 Haskell 实现中，我将：</p>
<ol>
<li>实现一个<strong>纯函数式</strong>的二叉搜索树，它不包含 <code>parent</code> 指针。</li>
<li>这与您示例中的 <code>insert</code>、<code>delete</code>、<code>mapt</code> 和 <code>foldt</code> 函数的<strong>函数式风格</strong>相匹配。</li>
<li>我将<strong>无法实现</strong>原文中的 <code>succ</code> 函数，因为它<strong>根本上依赖</strong>于 <code>parent</code> 指针。我会在代码中详细注释这一点。</li>
<li>原文中的 <code>insert</code> 算法逻辑<strong>是错误的</strong>（它将大于键的值插入左子树，小于的插入右子树）。我将实现<strong>正确</strong>的 BST 插入算法。</li>
<li>我将实现 <code>find</code> 和 <code>min</code> 的纯函数式（递归）版本，它们与原文中的迭代版本功能相同。</li>
</ol>
<hr>
<h3 id="%F0%9F%8C%B3-haskell-%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-(bst.hs)" tabindex="-1">🌳 Haskell 实现的二叉搜索树 (BST.hs)</h3>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br></div>
        <code><span class="token comment">-- | 定义二叉搜索树 (BST)</span>
<span class="token comment">-- | 'Empty' 代表空树</span>
<span class="token comment">-- | 'Node l k r' 代表一个节点，k 是键值，l 和 r 分别是左右子树</span>
<span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span>
            <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
            <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">)</span> <span class="token comment">-- 移除 Show 以便自定义</span>

<span class="token comment">-- | 自定义 Show 实例，使其更易读</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token operator">=</span> <span class="token hvariable">showTree</span> <span class="token number">0</span>
      <span class="token keyword">where</span>
        <span class="token hvariable">showTree</span> <span class="token hvariable">_</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token string">"Empty"</span>
        <span class="token hvariable">showTree</span> <span class="token hvariable">level</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span>
            <span class="token string">"Node "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">k</span> <span class="token operator">++</span> <span class="token string">"\n"</span> <span class="token operator">++</span>
            <span class="token hvariable">indent</span> <span class="token operator">++</span> <span class="token string">"L: "</span> <span class="token operator">++</span> <span class="token hvariable">showTree</span> <span class="token punctuation">(</span><span class="token hvariable">level</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">l</span> <span class="token operator">++</span> <span class="token string">"\n"</span> <span class="token operator">++</span>
            <span class="token hvariable">indent</span> <span class="token operator">++</span> <span class="token string">"R: "</span> <span class="token operator">++</span> <span class="token hvariable">showTree</span> <span class="token punctuation">(</span><span class="token hvariable">level</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>
          <span class="token keyword">where</span>
            <span class="token hvariable">indent</span> <span class="token operator">=</span> <span class="token builtin">replicate</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">level</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token char string">' '</span>

<span class="token comment">-- | 辅助函数：从列表构建树</span>
<span class="token comment">-- | 使用 foldl 和 insert 来构建</span>
<span class="token hvariable">fromList</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">fromList</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token hvariable">insert</span><span class="token punctuation">)</span> <span class="token constant">Empty</span>

<span class="token comment">-- | 辅助函数：将树转为中序列表 (L-K-R)</span>
<span class="token hvariable">toList</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">toList</span> <span class="token operator">=</span> <span class="token hvariable">foldLKR</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">k</span> <span class="token operator">-></span> <span class="token hvariable">acc</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">k</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment">-- | ---------------------------------------------------------------------------</span>
<span class="token comment">-- | 核心功能</span>
<span class="token comment">-- | ---------------------------------------------------------------------------</span>

<span class="token comment">-- | 向 BST 中插入一个值</span>
<span class="token comment">-- | 注意：原文中的 insert 算法逻辑是错误的 (它将大于的放左边，小于的放右边)</span>
<span class="token comment">-- | 这里实现的是 *正确* 的 BST 插入逻辑</span>
<span class="token hvariable">insert</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token comment">-- 基本情况：在空树上插入，返回一个新节点</span>
<span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span> <span class="token comment">-- x 小于当前键，递归插入左子树</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token hvariable">insert</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token comment">-- x 大于当前键，递归插入右子树</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span>            <span class="token comment">-- x 等于当前键，树不变 (BST 通常不存储重复值)</span>

<span class="token comment">-- | 在 BST 中查找一个值</span>
<span class="token comment">-- | 原文提供了一个迭代(while循环)算法，这在 Haskell 中不自然</span>
<span class="token comment">-- | 这里使用等效的、惯用的递归版本</span>
<span class="token hvariable">find</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">find</span> <span class="token hvariable">_</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token comment">-- 在空树中查找，失败</span>
<span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token comment">-- x 小于当前键，递归查找左子树</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">find</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span> <span class="token comment">-- x 大于当前键，递归查找右子树</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">True</span>       <span class="token comment">-- 找到 (k == x)</span>

<span class="token comment">-- | 查找 BST 中的最小元素</span>
<span class="token comment">-- | 原文提供了一个迭代版本，这里是等效的递归版本</span>
<span class="token comment">-- | 最小元素总是在最左边的节点上</span>
<span class="token hvariable">findMin</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">findMin</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token comment">-- 空树没有最小值</span>
<span class="token hvariable">findMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">k</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">k</span> <span class="token comment">-- 没有左子树，当前节点就是最小值</span>
<span class="token hvariable">findMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">findMin</span> <span class="token hvariable">l</span> <span class="token comment">-- 否则，最小值在左子树中</span>

<span class="token comment">-- | 从 BST 中删除一个值</span>
<span class="token comment">-- | 这里的逻辑直接翻译自原文中的 'delete' 和 'del' 助手函数</span>
<span class="token hvariable">delete</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">delete</span> <span class="token hvariable">_</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token comment">-- 从空树删除，返回空树</span>
<span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span> <span class="token comment">-- 要删除的值在左子树</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token hvariable">delete</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token comment">-- 要删除的值在右子树</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>               <span class="token comment">-- 找到了要删除的节点 (k == x)，调用 del</span>
    <span class="token keyword">where</span>
        <span class="token comment">-- | 'del' 助手函数处理删除根节点的情况</span>
        <span class="token comment">-- | 这对应原文中的 'del l r'</span>
        <span class="token hvariable">del</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
        <span class="token hvariable">del</span> <span class="token constant">Empty</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token hvariable">r</span> <span class="token comment">-- 没有左子树，用右子树替换</span>
        <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token hvariable">l</span> <span class="token comment">-- 没有右子树，用左子树替换</span>
        <span class="token hvariable">del</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>     <span class="token operator">=</span> <span class="token comment">-- 有两个子节点</span>
            <span class="token comment">-- 1. 找到右子树的最小值 (k') 作为新的根</span>
            <span class="token comment">-- 2. 新树的左子树是 l</span>
            <span class="token comment">-- 3. 新树的右子树是 *删除* 了 k' 的原右子树 (r)</span>
            <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">k'</span><span class="token punctuation">,</span> <span class="token hvariable">r'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">deleteMin</span> <span class="token hvariable">r</span> <span class="token comment">-- 找到并删除右子树的最小值</span>
            <span class="token keyword">in</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k'</span> <span class="token hvariable">r'</span>

<span class="token comment">-- | 助手函数：找到并删除最小节点 (用于 'delete')</span>
<span class="token comment">-- | 返回 (最小值的键, 删除了最小值的子树)</span>
<span class="token comment">-- | 这是 'del l r = let k' = min r in Node l k' (delete k' r)' 这一行</span>
<span class="token comment">-- | 的高效函数式实现。原文的实现 (先 findMin 再 delete) 会导致对右子树的两次遍历。</span>
<span class="token hvariable">deleteMin</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">deleteMin</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"deleteMin: called on empty tree"</span> <span class="token comment">-- 逻辑上不应该发生</span>
<span class="token hvariable">deleteMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token constant">Empty</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token comment">-- 找到了最小值 (k)，用其右子树 (r) 替换</span>
<span class="token hvariable">deleteMin</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">minKey</span><span class="token punctuation">,</span> <span class="token hvariable">newL</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">deleteMin</span> <span class="token hvariable">l</span> <span class="token comment">-- 最小值在左子树</span>
    <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">minKey</span><span class="token punctuation">,</span> <span class="token constant">Node</span> <span class="token hvariable">newL</span> <span class="token hvariable">k</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>

<span class="token comment">-- | ---------------------------------------------------------------------------</span>
<span class="token comment">-- | 关于后继 (succ) 函数的说明</span>
<span class="token comment">-- | ---------------------------------------------------------------------------</span>
<span class="token comment">-- |</span>
<span class="token comment">-- | 原文中 'succ' 函数的实现 *严重依赖于* 'parent' (父节点) 引用。</span>
<span class="token comment">-- |</span>
<span class="token comment">-- |     else {</span>
<span class="token comment">-- |       p = x.parent</span>
<span class="token comment">-- |       while (p 6= null and x == p.right) {</span>
<span class="token comment">-- |         x = p</span>
<span class="token comment">-- |         p = p.parent</span>
<span class="token comment">-- |       }</span>
<span class="token comment">-- |       return Optional.of(p);</span>
<span class="token comment">-- |     }</span>
<span class="token comment">-- |</span>
<span class="token comment">-- | 在 Haskell 这样的纯函数式语言中，我们不使用可变的父节点引用。</span>
<span class="token comment">-- | 我们的 'Tree' 数据结构是不可变的。'insert' 和 'delete' 函数会</span>
<span class="token comment">-- | 返回一个 *新* 的树，而不是修改旧的树。</span>
<span class="token comment">-- |</span>
<span class="token comment">-- | 因此，无法直接翻译原文中依赖 'parent' 指针的 'succ' 算法。</span>
<span class="token comment">-- |</span>
<span class="token comment">-- | 在函数式 BST 中要找到一个键的后继，你需要整个树和这个键，</span>
<span class="token comment">-- | 然后执行一次查找，同时"记住"当你向左走时可能的"后继"。</span>
<span class="token comment">-- | (此处省略 succ 的实现)</span>
<span class="token comment">-- |</span>
<span class="token comment">-- | ---------------------------------------------------------------------------</span>

<span class="token comment">-- | ---------------------------------------------------------------------------</span>
<span class="token comment">-- | 排名操作 (Rank Operations)</span>
<span class="token comment">-- | ---------------------------------------------------------------------------</span>

<span class="token operator">##</span> <span class="token hvariable">rank</span> <span class="token operator">-</span> 查找元素的排名

`<span class="token hvariable">rank</span> <span class="token hvariable">x</span>` 返回元素 <span class="token operator">`x`</span> 在有序序列中的排名（第几小的元素，从<span class="token number">1</span>开始）。如果 <span class="token operator">`x`</span> 不在树中，则返回 <span class="token operator">`x`</span> 应该插入的位置的排名。

<span class="token operator">###</span> 🧮 算法原理

基于 <span class="token constant">BST</span> 的有序性质，我们可以通过递归计算排名：

<span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">**</span>基本情况<span class="token operator">**</span>：空树中任何元素的排名都是 <span class="token number">1</span>
<span class="token number">2</span><span class="token punctuation">.</span> <span class="token operator">**</span>递归情况<span class="token operator">**</span>：
   <span class="token operator">-</span> 如果 `<span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>`（当前节点键值），则在左子树中查找
   <span class="token operator">-</span> 如果 `<span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>`，则排名 <span class="token operator">=</span> 左子树大小 <span class="token operator">+</span> 当前节点计数 <span class="token operator">+</span> 右子树中的排名
   <span class="token operator">-</span> 如果 `<span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">k</span>`，则排名 <span class="token operator">=</span> 左子树大小 <span class="token operator">+</span> <span class="token number">1</span>（第一个出现的位置）

<span class="token operator">###</span> 📐 数学证明

<span class="token operator">**</span>定理<span class="token operator">**</span>：`<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span>` 返回元素 <span class="token operator">`x`</span> 在树 <span class="token operator">`t`</span> 中的正确排名。

<span class="token operator">**</span>证明<span class="token operator">**</span>：对树的结构进行归纳法证明。

<span class="token operator">**</span>基本情况<span class="token operator">**</span>：`<span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token constant">Empty</span>`
<span class="token operator">-</span> `<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token number">1</span>`
<span class="token operator">-</span> 在空树中，任何元素插入后都是第<span class="token number">1</span>个元素，命题成立 ✓

<span class="token operator">**</span>归纳假设<span class="token operator">**</span>：假设对于所有高度小于 <span class="token operator">`h`</span> 的树，<span class="token operator">`rank`</span> 函数都返回正确排名。

<span class="token operator">**</span>归纳步骤<span class="token operator">**</span>：考虑高度为 <span class="token operator">`h`</span> 的树 `<span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span>`

<span class="token operator">**</span>情况<span class="token number">1</span><span class="token operator">**</span>：`<span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>`
<span class="token operator">-</span> 由 <span class="token constant">BST</span> 性质，<span class="token operator">`x`</span> 只可能在左子树 <span class="token operator">`l`</span> 中
<span class="token operator">-</span> `<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span>`
<span class="token operator">-</span> 由归纳假设，`<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span>` 是 <span class="token operator">`x`</span> 在左子树中的正确排名
<span class="token operator">-</span> 由于左子树中所有元素都小于 <span class="token operator">`k`</span>，这个排名也是在整个树中的正确排名 ✓

<span class="token operator">**</span>情况<span class="token number">2</span><span class="token operator">**</span>：`<span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>`
<span class="token operator">-</span> 由 <span class="token constant">BST</span> 性质，<span class="token operator">`x`</span> 只可能在右子树 <span class="token operator">`r`</span> 中
<span class="token operator">-</span> `<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span>`
<span class="token operator">-</span> `<span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span>` 是左子树和当前节点的元素总数
<span class="token operator">-</span> 由归纳假设，`<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span>` 是 <span class="token operator">`x`</span> 在右子树中的正确排名
<span class="token operator">-</span> 因此总和是 <span class="token operator">`x`</span> 在整个树中的正确排名 ✓

<span class="token operator">**</span>情况<span class="token number">3</span><span class="token operator">**</span>：`<span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">k</span>`
<span class="token operator">-</span> `<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token number">1</span>`
<span class="token operator">-</span> `<span class="token hvariable">size</span> <span class="token hvariable">l</span>` 是左子树中元素的数量
<span class="token operator">-</span> 所有这些元素都小于 <span class="token operator">`k`</span>，所以 <span class="token operator">`k`</span> 的排名 <span class="token operator">=</span> 左子树大小 <span class="token operator">+</span> <span class="token number">1</span> ✓

由归纳法，对于所有树 <span class="token operator">`t`</span>，<span class="token operator">`rank`</span> 函数都返回正确排名。∎

<span class="token operator">###</span> 💻 函数实现

```<span class="token hvariable">haskell</span>
<span class="token comment">-- | 计算 x 在树中的排名 (第几小的元素，从1开始)</span>
<span class="token comment">-- | 如果 x 不在树中，返回 x 应该插入的位置的排名</span>
<span class="token hvariable">rank</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">-- 在空树中，任何元素的排名都是1</span>
<span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span>                    <span class="token comment">-- x 在左子树中</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">k</span>     <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token hvariable">rank</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span>       <span class="token comment">-- x 在右子树中，跳过左子树和当前节点的所有重复值</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token number">1</span>                  <span class="token comment">-- x 等于当前键，排名是左子树大小 + 1（第一个出现的位置）</span>

<span class="token comment">-- | 计算树中元素的总个数 (包括重复值)</span>
<span class="token hvariable">size</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">size</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token hvariable">size</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token hvariable">size</span> <span class="token hvariable">r</span>
</code>
    </pre>
</div>
<h2 id="atrank---%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0" tabindex="-1">atRank - 查找第k小的元素</h2>
<p><code>atRank k</code> 返回第 <code>k</code> 小的元素，其中 <code>k</code> 从1开始。如果 <code>k</code> 超出范围，返回 <code>Nothing</code>。</p>
<h3 id="%F0%9F%A7%AE-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" tabindex="-1">🧮 算法原理</h3>
<p>递归地在树中查找第 <code>k</code> 个元素：</p>
<ol>
<li><strong>基本情况</strong>：空树中没有元素，返回 <code>Nothing</code></li>
<li><strong>递归情况</strong>：
<ul>
<li>计算左子树大小 <code>leftSize = size l</code></li>
<li>如果 <code>k ≤ leftSize</code>，则在左子树中查找</li>
<li>如果 <code>leftSize &lt; k ≤ leftSize + c</code>，则当前节点就是答案</li>
<li>如果 <code>k &gt; leftSize + c</code>，则在右子树中查找第 <code>k - leftSize - c</code> 个元素</li>
</ul>
</li>
</ol>
<h3 id="%F0%9F%93%90-%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E" tabindex="-1">📐 数学证明</h3>
<p><strong>定理</strong>：<code>atRank k t</code> 返回树 <code>t</code> 中第 <code>k</code> 小的元素（如果存在）。</p>
<p><strong>证明</strong>：对树的结构进行归纳法证明。</p>
<p><strong>基本情况</strong>：<code>t = Empty</code></p>
<ul>
<li><code>atRank k Empty = Nothing</code></li>
<li>空树中没有元素，任何 <code>k</code> 都应返回 <code>Nothing</code> ✓</li>
</ul>
<p><strong>归纳假设</strong>：假设对于所有高度小于 <code>h</code> 的树，<code>atRank</code> 函数都正确。</p>
<p><strong>归纳步骤</strong>：考虑高度为 <code>h</code> 的树 <code>t = Node l k c r</code>，令 <code>leftSize = size l</code></p>
<p><strong>情况1</strong>：<code>k ≤ leftSize</code></p>
<ul>
<li>第 <code>k</code> 小的元素在左子树中</li>
<li><code>atRank k t = atRank k l</code></li>
<li>由归纳假设，这是左子树中第 <code>k</code> 小的元素</li>
<li>由于左子树中所有元素都小于当前节点，这也是整个树中第 <code>k</code> 小的元素 ✓</li>
</ul>
<p><strong>情况2</strong>：<code>leftSize &lt; k ≤ leftSize + c</code></p>
<ul>
<li>第 <code>k</code> 小的元素是当前节点（考虑重复值）</li>
<li><code>atRank k t = Just k</code></li>
<li>左子树有 <code>leftSize</code> 个元素，当前节点从第 <code>leftSize + 1</code> 到 <code>leftSize + c</code> 个位置</li>
<li>因此第 <code>k</code> 个元素确实是当前节点 ✓</li>
</ul>
<p><strong>情况3</strong>：<code>k &gt; leftSize + c</code></p>
<ul>
<li>第 <code>k</code> 小的元素在右子树中</li>
<li><code>atRank k t = atRank (k - leftSize - c) r</code></li>
<li>需要跳过左子树和当前节点的所有元素</li>
<li>由归纳假设，这是右子树中第 <code>k - leftSize - c</code> 小的元素</li>
<li>这对应于整个树中第 <code>k</code> 小的元素 ✓</li>
</ul>
<p>由归纳法，对于所有树 <code>t</code>，<code>atRank</code> 函数都返回正确结果。∎</p>
<h3 id="%F0%9F%92%BB-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0" tabindex="-1">💻 函数实现</h3>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div>
        <code><span class="token comment">-- | 返回第 k 小的元素 (k 从1开始)</span>
<span class="token comment">-- | 如果 k 超出范围，返回 Nothing</span>
<span class="token hvariable">atRank</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">l</span> <span class="token hvariable">k'</span> <span class="token hvariable">c</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">k</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token constant">Nothing</span>                     <span class="token comment">-- k 无效</span>
    <span class="token operator">|</span> <span class="token hvariable">leftSize</span> <span class="token operator">>=</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token hvariable">atRank</span> <span class="token hvariable">k</span> <span class="token hvariable">l</span>              <span class="token comment">-- 在左子树中</span>
    <span class="token operator">|</span> <span class="token hvariable">leftSize</span> <span class="token operator">+</span> <span class="token hvariable">c</span> <span class="token operator">>=</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">k'</span>             <span class="token comment">-- 在当前节点中</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">atRank</span> <span class="token punctuation">(</span><span class="token hvariable">k</span> <span class="token operator">-</span> <span class="token hvariable">leftSize</span> <span class="token operator">-</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token hvariable">r</span> <span class="token comment">-- 在右子树中</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">leftSize</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token hvariable">l</span>
</code>
    </pre>
</div>
<h3 id="%F0%9F%94%84-%E4%BA%92%E4%B8%BA%E9%80%86%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8" tabindex="-1">🔄 互为逆运算性质</h3>
<p><code>rank</code> 和 <code>atRank</code> 在某种意义上互为逆运算：</p>
<ul>
<li>对于树中存在的元素 <code>x</code>：<code>atRank (rank x t) t = Just x</code></li>
<li>对于有效的排名 <code>k</code>：<code>rank (atRank k t) t = k</code></li>
</ul>
<p>这个性质在实现顺序统计树（Order Statistic Tree）时非常有用。</p>
<h3 id="%F0%9F%A7%AA-%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B" tabindex="-1">🧪 测试示例</h3>
<div class="language-haskell line-numbers-mode">
    <div class="code-info-header">
        <span>haskell</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-haskell">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div>
        <code><span class="token comment">-- 测试树: [1,2,3,4,5,7,8,9]</span>
<span class="token keyword">let</span> <span class="token hvariable">testTree</span> <span class="token operator">=</span> <span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token comment">-- rank 测试</span>
<span class="token hvariable">rank</span> <span class="token number">4</span> <span class="token hvariable">testTree</span>  <span class="token comment">-- 返回 4 (第4小的元素)</span>
<span class="token hvariable">rank</span> <span class="token number">6</span> <span class="token hvariable">testTree</span>  <span class="token comment">-- 返回 6 (6不在树中，会排在第6位)</span>

<span class="token comment">-- atRank 测试  </span>
<span class="token hvariable">atRank</span> <span class="token number">4</span> <span class="token hvariable">testTree</span>  <span class="token comment">-- 返回 Just 4</span>
<span class="token hvariable">atRank</span> <span class="token number">8</span> <span class="token hvariable">testTree</span>  <span class="token comment">-- 返回 Just 9 (第8个元素是9)</span>
<span class="token hvariable">atRank</span> <span class="token number">9</span> <span class="token hvariable">testTree</span>  <span class="token comment">-- 返回 Nothing (只有8个元素)</span>

<span class="token comment">-- 重复值测试</span>
<span class="token keyword">let</span> <span class="token hvariable">dupTree</span> <span class="token operator">=</span> <span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">rank</span> <span class="token number">2</span> <span class="token hvariable">dupTree</span>     <span class="token comment">-- 返回 3 (第一个2的排名是3)</span>
<span class="token hvariable">atRank</span> <span class="token number">3</span> <span class="token hvariable">dupTree</span>   <span class="token comment">-- 返回 Just 2</span>
<span class="token hvariable">atRank</span> <span class="token number">5</span> <span class="token hvariable">dupTree</span>   <span class="token comment">-- 返回 Just 2 (第5个元素也是2)</span>
</code>
    </pre>
</div>
<p>– | ---------------------------------------------------------------------------</p>
<table>
<thead>
<tr>
<th>–</th>
<th>映射和折叠 (Map &amp; Fold)</th>
</tr>
</thead>
</table>
<p>– | 对树中的每个元素应用一个函数
– | 对应原文中的 ‘mapt’
mapTree :: (a -&gt; b) -&gt; Tree a -&gt; Tree b
mapTree _ Empty = Empty
mapTree f (Node l k r) = Node (mapTree f l) (f k) (mapTree f r)</p>
<p>– | 折叠 (fold) 树 (Catamorphism)
– | 这是一个通用的树遍历/转换函数
– | 对应原文中的 ‘foldt’
– | g: 如何组合 (左子树结果, 转换后的键, 右子树结果)
– | f: 如何转换键
– | z: 空树的默认值
foldTree :: (b -&gt; c -&gt; b -&gt; b) -&gt; (a -&gt; c) -&gt; b -&gt; Tree a -&gt; b
foldTree _ _ z Empty = z
foldTree g f z (Node l k r) =
g (foldTree g f z l) (f k) (foldTree g f z r)</p>
<p>– | 演示：使用 ‘foldTree’ 来实现 ‘mapTree’
– | 对应原文中的 ‘maptr’
mapTree’ :: (a -&gt; b) -&gt; Tree a -&gt; Tree b
mapTree’ f = foldTree Node f Empty</p>
<p>– | 对应原文中的第二个 ‘fold’
– | fold f z (Node l k r) = fold f (k <code>f</code> (fold f z r)) l
– | 这是一个 <em>反向</em> 中序 (R-K-L, Right-Key-Left) 遍历折叠
foldRKL :: (a -&gt; b -&gt; b) -&gt; b -&gt; Tree a -&gt; b
foldRKL _ z Empty = z
foldRKL f z (Node l k r) = foldRKL f (k <code>f</code> (foldRKL f z r)) l</p>
<p>– | 一个更有用的 <em>正向</em> 中序 (L-K-R, Left-Key-Left) 遍历折叠
– | 注意 f 的类型是 (b -&gt; a -&gt; b)
foldLKR :: (b -&gt; a -&gt; b) -&gt; b -&gt; Tree a -&gt; b
foldLKR f z = go z
where
go acc Empty = acc
go acc (Node l k r) =
let accL = go acc l     – 先处理左子树 (L)
accK = accL <code>f</code> k  – 再处理当前键 (K)
in go accK r           – 最后处理右子树 ®</p>
<p>– | ---------------------------------------------------------------------------</p>
<table>
<thead>
<tr>
<th>–</th>
<th>主函数：测试数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>main :: IO ()</td>
<td></td>
</tr>
<tr>
<td>main = do</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>putStrLn &quot;--- BST 测试 ---&quot;

let nums = [5, 3, 8, 1, 4, 7, 9, 2]
putStrLn $ &quot;原始数据: &quot; ++ show nums

let tree = fromList nums
putStrLn $ &quot;\n--- 构建的树 ---&quot;
print tree

let orderedList = toList tree
putStrLn $ &quot;\n--- 中序遍历 (toList) ---&quot;
putStrLn $ &quot;结果: &quot; ++ show orderedList

putStrLn &quot;\n--- 查找 (find) ---&quot;
putStrLn $ &quot;查找 4 (应为 True): &quot; ++ show (find 4 tree)
putStrLn $ &quot;查找 6 (应为 False): &quot; ++ show (find 6 tree)

putStrLn &quot;\n--- 最小值 (findMin) ---&quot;
putStrLn $ &quot;最小值 (应为 1): &quot; ++ show (findMin tree)

putStrLn &quot;\n--- 插入 (insert) ---&quot;
let tree' = insert 6 tree
putStrLn $ &quot;插入 6 后的树:&quot;
print tree'
putStrLn $ &quot;中序遍历 (应包含 6): &quot; ++ show (toList tree')

putStrLn &quot;\n--- 删除 (delete) ---&quot;
putStrLn &quot;删除 2 (叶节点):&quot;
let treeDelLeaf = delete 2 tree'
print treeDelLeaf
putStrLn $ &quot;中序: &quot; ++ show (toList treeDelLeaf)

putStrLn &quot;\n删除 3 (一个子节点, 1 和 4):&quot;
let treeDelOne = delete 3 tree'
print treeDelOne
putStrLn $ &quot;中序: &quot; ++ show (toList treeDelOne)

putStrLn &quot;\n删除 8 (两个子节点, 7 和 9):&quot;
let treeDelTwo = delete 8 tree'
print treeDelTwo
putStrLn $ &quot;中序: &quot; ++ show (toList treeDelTwo)

putStrLn &quot;\n删除 5 (根节点，有两个子节点):&quot;
let treeDelRoot = delete 5 tree'
print treeDelRoot
putStrLn $ &quot;中序: &quot; ++ show (toList treeDelRoot)

putStrLn &quot;\n--- 映射 (mapTree) ---&quot;
let treeSquared = mapTree (*2) tree
putStrLn $ &quot;每个元素 * 2:&quot;
print treeSquared
putStrLn $ &quot;中序: &quot; ++ show (toList treeSquared)

putStrLn &quot;\n--- 折叠 (foldRKL) ---&quot;
let sumRKL = foldRKL (+) 0 tree
putStrLn $ &quot;R-K-L 方式求和: &quot; ++ show sumRKL
putStrLn $ &quot;foldr (+) 0 (toList tree): &quot; ++ show (foldr (+) 0 (toList tree))

putStrLn &quot;\n--- 折叠 (foldLKR) ---&quot;
let sumLKR = foldLKR (\acc k -&gt; acc + k) 0 tree
putStrLn $ &quot;L-K-R 方式求和: &quot; ++ show sumLKR
putStrLn $ &quot;foldl (+) 0 (toList tree): &quot; ++ show (foldl (+) 0 (toList tree))
</code></pre>
<pre><code>
### 🧑‍💻 如何运行代码

1.  将上述代码保存为 `BST.hs`。
2.  在您的终端中，使用 GHC (Haskell 编译器) 运行它：
    ```bash
    runghc BST.hs
    ```

您将看到所有测试用例的输出。

这个实现忠实地反映了您所提供示例中的**函数式**部分，并对命令式部分（`parent` 指针和 `succ`）无法在纯函数式 Haskell 中直接实现的原因进行了解释。

您想让我展示如何在 Haskell 中实现一个功能上等效的 `succ` (后继) 函数吗？它会比原文中的版本更复杂一些。

---
</code></pre>

</div> 
    </div>

</article>

    </main>
    
    <footer class="site-footer">
    <div class="footer-content">
        <p>&copy; 2025 rainboy. All rights reserved. last build time 2025/12/14 22:00:48</p>
        <p class="license">内容遵循 <a style="text-decoration:none;" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
            <img decoding="async" loading="lazy" src="/ccbyncsa.png" width="65" height="auto" style="display:inline-block;">
        </a> 协议</p>
        <p class="powered-by">Powered by <a href="https://github.com/rainboyOJ/rbook_nunjucks" target="_blank"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTIgMkExMCAxMCAwIDAgMCAyIDEyYzAgNC40MiAyLjg3IDguMTcgNi44NCA5LjVjLjUuMDguNjYtLjIzLjY2LS41di0xLjY5Yy0yLjc3LjYtMy4zNi0xLjM0LTMuMzYtMS4zNGMtLjQ2LTEuMTYtMS4xMS0xLjQ3LTEuMTEtMS40N2MtLjkxLS42Mi4wNy0uNi4wNy0uNmMxIC4wNyAxLjUzIDEuMDMgMS41MyAxLjAzYy44NyAxLjUyIDIuMzQgMS4wNyAyLjkxLjgzYy4wOS0uNjUuMzUtMS4wOS42My0xLjM0Yy0yLjIyLS4yNS00LjU1LTEuMTEtNC41NS00LjkyYzAtMS4xMS4zOC0yIDEuMDMtMi43MWMtLjEtLjI1LS40NS0xLjI5LjEtMi42NGMwIDAgLjg0LS4yNyAyLjc1IDEuMDJjLjc5LS4yMiAxLjY1LS4zMyAyLjUtLjMzczEuNzEuMTEgMi41LjMzYzEuOTEtMS4yOSAyLjc1LTEuMDIgMi43NS0xLjAyYy41NSAxLjM1LjIgMi4zOS4xIDIuNjRjLjY1LjcxIDEuMDMgMS42IDEuMDMgMi43MWMwIDMuODItMi4zNCA0LjY2LTQuNTcgNC45MWMuMzYuMzEuNjkuOTIuNjkgMS44NVYyMWMwIC4yNy4xNi41OS42Ny41QzE5LjE0IDIwLjE2IDIyIDE2LjQyIDIyIDEyQTEwIDEwIDAgMCAwIDEyIDIiLz48L3N2Zz4="/>
         rbook</a></p>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
    <script src="/assets/js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.6/heti-addon.min.js" integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        //const heti = new Heti('.heti');
        // error 自动挤压,增加空格 在Katex 公式中
        //heti.autoSpacing(); // 自动进行中西文混排美化和标点挤压
    </script>
</body>
</html>