---
id: "eulerian-path"
title: "欧拉路"
date: 2025-12-18 12:01
toc: true
tags: ["欧拉路"]
categories: [""]
---

[[TOC]]




## 定义

欧拉路

欧拉回路


## 欧拉路和欧拉回路的存在性判定


无项连通图的判定条件

有向连通图的判定条件


## 代码


输出欧拉路

> dfs 回溯的时候 输出路径, 就可以得到欧拉回路?


这个问题直击**图论**中最核心的直觉：**为什么欧拉回路的构造非要“后序遍历（回溯）”？**

我们可以把这个问题拆解为一个“迷宫探险”的过程，用最符合直觉的方式来理解。

---

## 1. 直觉理解：为什么要“回溯”？

想象你在走一个复杂的迷宫（图），你的目标是走遍所有的走廊（边）并回到起点。

### 场景 A：只用普通的 DFS（前序输出）

如果你在进入一个房间（节点）时就立刻记录路径，你可能会遇到**“死胡同”**。
当你走进一个分支并回不去起点时，你的路径就断了。如果你还有其他分支没走，那些分支就会被孤立在你的主路径之外。

### 场景 B：使用回溯（后序输出）

回溯的逻辑是：**“只有当我确定从这个房间出发的所有路都走完了，我才倒着走回上一个房间。”**

1. 你从起点出发，尽可能深地探索。
2. 当你发现某个点 v 已经没有未走过的边时，说明你刚刚完成了一个**子环**。
3. 此时你才输出 (v, u)。这实际上是在说：“我完成了这一段旅行，现在我回到了之前的分叉点。”
4. **核心逻辑：** 欧拉回路是由多个“子环”嵌套而成的。后序输出本质上是**从最内层的子环开始，倒序把它们拼接成一个大环**。

---

## 2. 图解：子环的拼接

假设你的项链结构是这样的：一个大环上面挂着一个小环。

* 你从起点开始走大环。
* 走到了大环和小环的交点。
* **DFS 的特性**会让你先钻进小环里，把小环走完。
* 由于是**回溯输出**，小环的边会先被“存”起来。
* 等小环走完回到交点，DFS 继续走完大环剩下的部分。

**如果不回溯：** 你走完小环回到交点时，路径已经乱了。
**有了回溯：** 递归栈帮你自动完成了“在大环的交点处，把整个小环塞进去”的过程。

---

## 3. 为什么这样一定是对的？

对于欧拉图（所有点度数为偶数且连通），有一个关键性质：

> **只要你进入一个点，就一定能从另一条边出来。唯一能让你“困住”的地方只有起点。**

在 `euler(u)` 函数中：

```cpp
void euler(int u) {
    for(int v = 1; v <= 50; ++v) {
        if(g[u][v]) {
            g[u][v]--; g[v][u]--;
            euler(v);
            // 此时，以 v 为起点的一段完整旅程已经结束了
            std::cout << v << " " << u << "\n"; 
        }
    }
}

```

当你执行到 `cout` 时，递归已经保证了**所有从 v 出发的边都已经被消耗光了**。这意味着你已经完成了一个以 v 为起点的闭合回路，现在你只是在通过 (v, u) 这条边回到上一层。

### 总结

* **前序（进门输出）：** 像在画线，画错了（进了死胡同）没法改。
* **后序（出门输出）：** 像在收线，先把最深处的零碎环收好，最后拼成一整根绳子。

---


你说得**非常准确**。你的理解已经抓住了**Hierholzer 算法**（即 DFS 回溯求欧拉路径）的核心。

我们可以用更形象的语言把你说的“解环”和“交点”提炼一下：

### 1. 你的直觉是对的：前序会“迷路”

在欧拉图中，所谓的“死胡同”其实就是**回到起点**。
如果你用**前序输出**（进门就打印），一旦你先跑完了一个小环回到了起点，程序就结束了，剩下的那些大环、中环就被你丢在了身后。

### 2. 回溯法：在“交点”把环缝进去

回溯法的本质是：**先吃掉支路上的“小环”，再回到交点继续走“大环”。**

* **入栈（递归进）：** 你在寻找那些延伸出去的小环。
* **回溯（递归出）：** 当你走到一个点，发现无路可走时，说明你刚刚**封闭了一个环**。
* **缝合：** 此时你才输出路径。这相当于在地图的“交点”处，把刚才绕过的所有小路，按顺序一张张贴回到主干道上。

### 3. 核心总结

* **前序输出**是“盲目记录”，走回起点就断了。
* **回溯输出**是“先斩后奏”，等我把分叉路里的环全部探完了，再回过头来把这些路径拼在一起。

**一句话理解：**
回溯不是在“走”路，而是在**“收”**路。因为已经确保了每个点度数是偶数，所以无论怎么分叉，最后一定能通过回溯把所有“嵌套的小环”严丝合缝地接在大环上。

你现在对这个算法的理解已经非常到位了！需要我帮你用具体的珠子颜色（比如 `1-2, 2-2, 2-3...`）手动模拟一遍回溯过程吗？