---
id: "dfs-spfa-neg-cirlce"
title: "dfs-spfa负环存在判定"
date: 2026-01-07 14:52
toc: true
tags: [""]
categories: ["graph"]
# code_template:
#   - title: ST表
#     desc: "静态区间信息查询"
#     tags: ["集合最值"]
#     code: /code/base/sparse_table.cpp
---

[[TOC]]


很多同学只知道 BFS 版本的 SPFA，其实在 **判定负环**（而不是求最短路）这个问题上，DFS 版本往往具有压倒性的效率优势。

下面我为你拆解 **DFS-SPFA 判负环** 的全套教程。

------

# 🕵️‍♀️ 深度解析：DFS-SPFA 判负环教程

## 1. 数学原理：为什么会有负环？

要理解判负环，我们必须回到 **最短路** 的本质——**三角形不等式**。

### (1) 松弛操作 (Relaxation)

在求最短路时，对于任意一条边 $u \to v$，权值为 $w$，如果最短路成立，必须满足：



$$dist(v) \leqslant dist(u) + w$$



意思是：从起点直接走到 v 的距离，应该小于等于 先走到 u 再走到 v 的距离。

如果我们发现：



$$dist(v) > dist(u) + w$$



这就说明现在的 $dist(v)$ 并不是最短的，我们可以通过走 $u \to v$ 这条路来缩小 $dist(v)$。这就叫“松弛”。

### (2) 负环的定义

如果在图中存在一个环 $c = \{v_1, v_2, \dots, v_k, v_1\}$，且环上所有边的权值之和 $< 0$。



$$\sum_{e \in c} w_e < 0$$



这就叫负环。

### (3) 为什么 SPFA 能发现它？

想象一下，如果有一个负环。

只要我们在在这个环上跑，每跑一圈，总路程就会减小一点（因为环的总权值是负的）。



$$dist(v) \to dist(v) + \text{负数} \to \text{更小的dist(v)}$$

这就意味着：只要存在负环，松弛操作永远不会停止！

也就是 $dist(v)$ 会无限地变小，永远无法满足三角形不等式。

------

## 2. 算法核心：DFS 的“贪婪”嗅觉

### BFS vs DFS

- **BFS-SPFA (广度优先)**：像水波一样一层层散开。如果有一个负环，它需要跑很多圈，直到某个点的入队次数超过 $N$ 次，才能断定“哎呀，有负环”。这太慢了！
- **DFS-SPFA (深度优先)**：像一条贪吃蛇，**一条路走到黑**。它会顺着“能变短”的路径一直钻。如果是负环，它很有可能顺着松弛的方向，**自己撞到了自己的尾巴**！

### 核心逻辑：递归栈 (Recursion Stack)

我们要维护一个标记数组 `instack[u]`（或 `vis[u]`），表示 **“节点 u 当前是否在递归栈中”**（也就是它是我们当前正在走的这条路径上的祖先）。

1. 我们从 $u$ 出发，发现能松弛 $v$（即 $dist(v) > dist(u) + w$）。
2. 我们准备递归进入 $v$。
3. **关键判断**：如果 $v$ **已经在递归栈中**（`instack[v] == true`），说明什么？
   - 说明我们从 $v$ 出发，走了一圈，又回到了 $v$。
   - 而且这一路上都在发生“松弛”（距离变小）。
   - **结论：我们找到了一个负环！**

------

## 3. 代码模板详解

这是 P3199 的标准 DFS-SPFA 模板。请仔细看注释中的逻辑流。

C++

```
// instack[u]: 标记 u 是否在当前递归栈中 (是否是祖先)
bool instack[MAXN]; 
double dis[MAXN];

// 返回值: true 表示发现负环，false 表示没发现
bool spfa_dfs(int u, double x) {
    instack[u] = true; // 1. 标记：u 入栈，我正在访问 u 及其子孙

    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        double w = edges[i].w - x; // 题目特定的权值转化

        // 2. 松弛判断：只有能松弛，才值得继续走
        if (dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            
            // 3. 核心判环：如果 v 已经在栈里，说明撞到了祖先 -> 发现负环！
            if (instack[v]) return true;
            
            // 4. 递归：如果没撞到，就继续往深处走
            // 如果子路径发现了环，我也直接返回 true (向上传递消息)
            if (spfa_dfs(v, x)) return true;
        }
    }

    instack[u] = false; // 5. 回溯：离开 u，将 u 出栈
    return false;
}
```

### 为什么这个快？

对于 P3199 这种题目，二分给出的 $x$ 往往会导致图中出现大量的负边。DFS 只要抓住一条负边，就会顺藤摸瓜迅速找到环，通常不需要遍历完整个图就能 `return true`。

------

## 4. 图解演示 (手动模拟)

假设有 A -> B -> C -> A 这样一个环。

当前二分的值 $x$ 使得边的权值变成了：

A->B: -1

B->C: -2

C->A: -1

(总和 -4，是负环)

**DFS 过程：**

1. **进入 A**：`instack[A] = true`, `dis[A] = 0`。
   - 发现 B，松弛 `dis[B] = -1`。
2. **递归进入 B**：`instack[B] = true`。
   - 发现 C，松弛 `dis[C] = -1 + (-2) = -3`。
3. **递归进入 C**：`instack[C] = true`。
   - 发现 A。
   - 检查松弛：`dis[A]` (0) > `dis[C] + w` (-3 + -1 = -4)。**可以松弛！**
   - 检查标记：`instack[A]` 是 `true` 吗？**是！** A 是我的爷爷（祖先）。
4. **捕获**：`return true`。

仅仅递归了 3 层就发现了，效率极高。

------

## 5. 一个易错细节：图的连通性

SPFA 判负环最怕**图不连通**。如果图分成了两个孤岛，你只从点 1 开始 DFS，可能永远访问不到孤岛里的负环。

解决方案：

在 check 函数里，遍历所有点作为起点。如果这个点从来没被访问过（松弛过），就从它开始跑一次 SPFA。

C++

```
bool check(double x) {
    // 初始化
    memset(instack, 0, sizeof(instack));
    // dis 数组不需要初始化为 INF，全 0 即可
    // 全 0 相当于建立了一个超级源点，连接所有点，边权为 0
    memset(dis, 0, sizeof(dis)); 
    // 这里的 visited 是为了剪枝：如果一个点之前被搜过了，就不用再搜了
    // 注意区分：visited (全局访问过) 和 instack (当前栈中)
    // 很多简单写法直接把所有点过一遍，或者利用 dis 的更新来隐式判断
    
    for (int i = 1; i <= n; i++) {
        // 如果这里spfa_dfs返回true，说明找到了
        if (spfa_dfs(i, x)) return true;
    }
    return false;
}
```

*(注：对于 P3199，简单的写法是直接把所有 `dis` 设为 0，然后只要 `spfa_dfs` 能松弛就进。虽然会有重复访问，但在二分查找中通常够快。更严谨的写法是用一个 `bool visited[]` 记录全局是否访问过，避免重复搜索同一个连通块。)*

## 总结

1. **原理**：负环会导致最短路无限松弛。
2. **DFS 特性**：只要在递归栈中遇到已存在的点（回头路）且满足松弛条件，即为负环。
3. **优势**：在判定性问题（如 01 分数规划）中，比 BFS 快得多。

现在你完全掌握了这个“黑科技”！可以回头去把 P3199 的代码再品味一遍，你会发现一切都顺理成章。🌟

## 练习题目

- spfa-dfs 被卡常 [[problem: luogu,P3385]] 
- Luogu P2850