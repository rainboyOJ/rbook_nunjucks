## Tarjan v-BCC 算法手动模拟练习

这里有三个不同特征的无向图。请根据你提供的代码逻辑，手动模拟 `dfs` 过程、`stack` 的变化以及 `low/dfn` 的更新。

### 练习图 1：蝴蝶结 (The Bowtie)

**特点**：经典的割点模型。一个点连接两个环。考察点 `3` 如何被分入两个不同的 BCC。

#### 图结构 (邻接表)

- **1**: [2, 3]
- **2**: [1, 3]
- **3**: [1, 2, 4, 5]  <-- 核心割点
- **4**: [3, 5]
- **5**: [3, 4]

#### 可视化

```
   1 -- 2
    \  /
     3
    /  \
   4 -- 5
```

#### 模拟目标

假设从 节点 1 开始 DFS (dfs(1, 0))。

请记录：

1. 访问顺序。
2. 栈 `st` 的内容变化。
3. 何时触发 `low[v] >= dfn[u]`。
4. 每次触发时，BCC 里输出了哪些点。

### 练习图 2：带桥的图 (The Bridge)

**特点**：包含一条线性的边（桥）。考察算法如何处理只有两个点的 BCC。

#### 图结构

- **1**: [2, 3]
- **2**: [1, 3]
- **3**: [1, 2, 4]   <-- 割点
- **4**: [3, 5, 6]   <-- 割点
- **5**: [4, 6]
- **6**: [4, 5]

#### 可视化

```
   1 -- 2
    \  /
     3
     |  <-- 这是一个桥 (也是一个 BCC)
     4
    / \
   5 - 6
```

#### 模拟目标

假设从 **节点 1** 开始 DFS。注意观察 `3-4` 这条边是如何被判定为一个 BCC 的。

### 练习图 3：复杂的房子 (The House with Roof)

**特点**：稍微复杂的环结构。

#### 图结构

- **1**: [2, 3]     (房顶尖)
- **2**: [1, 3, 4]
- **3**: [1, 2, 5]
- **4**: [2, 5]     (房底左)
- **5**: [3, 4]     (房底右)

#### 可视化

```
      1
     / \
    2 - 3
    |   |
    4 - 5
    (注意：2和3之间有连边，2-5无连边，3-4无连边)
```

**提示**：这个图是一个整体，看看你的模拟是否最后只生成了 1 个 BCC。

## ✅ 练习图 1 (蝴蝶结) 详细模拟答案

**假设邻接表顺序为：**

- 1: 2, 3
- 2: 1, 3
- 3: 1, 2, 4, 5
- 4: 3, 5
- 5: 3, 4

**初始状态**：`timer=0`, `st=[]`, `dfn[:] = 0`

#### 步骤流程

1. **Start DFS(1, 0)**
   - `dfn[1]=1`, `low[1]=1`, `timer=1`
   - **Stack**: `[1]`
   - **Edge 1->2**: `v=2`, `!dfn[2]` -> **DFS(2, 1)**
2. **Inside DFS(2, 1)**
   - `dfn[2]=2`, `low[2]=2`, `timer=2`
   - **Stack**: `[1, 2]`
   - **Edge 2->1**: `v=1`, `v==fa`, continue.
   - **Edge 2->3**: `v=3`, `!dfn[3]` -> **DFS(3, 2)**
3. **Inside DFS(3, 2)**
   - `dfn[3]=3`, `low[3]=3`, `timer=3`
   - **Stack**: `[1, 2, 3]`
   - **Edge 3->1**: `v=1`, `dfn[1] < dfn[3]` (Back Edge).
     - `low[3] = min(3, dfn[1]=1) = 1`
   - **Edge 3->2**: `v=2`, `v==fa`, continue.
   - **Edge 3->4**: `v=4`, `!dfn[4]` -> **DFS(4, 3)**
4. **Inside DFS(4, 3)**
   - `dfn[4]=4`, `low[4]=4`, `timer=4`
   - **Stack**: `[1, 2, 3, 4]`
   - **Edge 4->3**: `v=3`, `v==fa`, continue.
   - **Edge 4->5**: `v=5`, `!dfn[5]` -> **DFS(5, 4)**
5. **Inside DFS(5, 4)**
   - `dfn[5]=5`, `low[5]=5`, `timer=5`
   - **Stack**: `[1, 2, 3, 4, 5]`
   - **Edge 5->3**: `v=3`, `dfn[3] < dfn[5]` (Back Edge).
     - `low[5] = min(5, dfn[3]=3) = 3`
   - **Edge 5->4**: `v=4`, `v==fa`, continue.
   - **DFS(5) 结束**。回溯到 `DFS(4)`。
6. **Back to DFS(4, 3)** (此时处理完 neighbor 5)
   - `low[4] = min(low[4]=4, low[5]=3) = 3`
   - 检查判定：`low[5] (3) >= dfn[4] (4)`? **False**。
   - 说明 5 能回到 4 的上面（它是通过 3 回去的），所以暂时不构成以 4 为割点的 BCC。
   - **DFS(4) 结束**。回溯到 `DFS(3)`。
7. **Back to DFS(3, 2)** (此时处理完 neighbor 4)
   - `low[3] = min(low[3]=1, low[4]=3) = 1`
   - 检查判定：`low[4] (3) >= dfn[3] (3)`? **True!**
   - **找到 BCC！**
   - `bcc_cnt = 1`
   - **Pop Stack Loop**:
     - Pop `5` -> `bcc[1] = {5}`
     - Pop `4` -> `bcc[1] = {5, 4}`
     - 遇到 `v=4`，Break。
   - **Push u (3)**: `bcc[1] = {5, 4, 3}`
   - **当前 Stack**: `[1, 2, 3]` (注意：3 还在栈里，因为它是割点，还要服务于上面的结构)
   - **Edge 3->5**: `v=5`, `dfn[5]` 已存在。`dfn[5] > dfn[3]` (Forward Edge, ignore) 或视实现而定，通常 `!dfn[v]` 分支不会进，`else` 分支 `dfn[v] < dfn[u]` 也不满足，跳过。
   - **DFS(3) 结束**。回溯到 `DFS(2)`。
8. **Back to DFS(2, 1)** (此时处理完 neighbor 3)
   - `low[2] = min(low[2]=2, low[3]=1) = 1`
   - 检查判定：`low[3] (1) >= dfn[2] (2)`? **False**。
   - 说明 3 及其子树能回到 2 的上面（回到了 1）。
   - **DFS(2) 结束**。回溯到 `DFS(1)`。
9. **Back to DFS(1, 0)** (此时处理完 neighbor 2)
   - `low[1] = min(low[1]=1, low[2]=1) = 1`
   - 检查判定：`low[2] (1) >= dfn[1] (1)`? **True!**
   - **找到 BCC！**
   - `bcc_cnt = 2`
   - **Pop Stack Loop**:
     - Pop `3` -> `bcc[2] = {3}`
     - Pop `2` -> `bcc[2] = {3, 2}`
     - 遇到 `v=2`，Break。
   - **Push u (1)**: `bcc[2] = {3, 2, 1}`
   - **当前 Stack**: `[1]`
   - **Edge 1->3**: `v=3`, `dfn[3]` 已存在。`dfn[3] > dfn[1]`，跳过。
   - **DFS(1) 结束**。

**最终结果**:

- BCC 1: `{5, 4, 3}` (右边的三角形)
- BCC 2: `{3, 2, 1}` (左边的三角形)
- 栈最后剩下 `[1]`，如果是主函数调用，通常会清空或者忽略。

#### 练习建议

1. **做图 2 时注意**：当处理边 `3-4` 时，`4` 无法回到 `3` 的上方，所以 `low[4] >= dfn[3]` 会成立。此时栈里可能只有 `4`（因为下面的 `5,6` 已经形成 BCC 被弹出了）。结果应该是 `{4, 3}` 构成一个 BCC。
2. **做图 3 时注意**：因为所有点都在一个强环里，`low` 值会一直传递更新，直到回到根节点下面一层才可能触发条件。