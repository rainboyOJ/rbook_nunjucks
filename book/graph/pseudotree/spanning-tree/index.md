---
id: "one-loop-graph"
title: "基环树（One-Loop-Graph）——找环与应用"
date: 2025-12-19 20:00
toc: true
tags: ["图论", "找环", "基环树"]
categories: ["图论"]
---

[[TOC]]

## 摘要 (Abstract)

基环树（又称一环树、基环图）是指在连通图中恰好含有一个环的图结构。本文系统讲解基环树的定义与分类，给出在无向图、有向图（入度/出度为 1 的特殊图）中高效找环的方法，给出清晰的算法思想、伪代码与可运行的 C++ 实现，并包含复杂度分析与测试用例与拓展思考。

## 前置知识

- 图的深度优先搜索 (DFS)
- 拓扑排序（用于有向图的部分思路）
- 树与环的基本概念

## 背景与动机 (Motivation)

基环树在很多问题中自然出现，例如含唯一环的图的距离/直径计算、带环的并查集/树形动态规划等。能够稳定、快速地定位环并分离环上/环下的点，是解决一类问题（如环上路径统计、环上最短路） 的关键步骤。

## 问题定义 (Problem Definition)

给定一个连通图 G = (V, E)，若图中恰有一个环（cycle），则称为基环树。我们关心：

- 如何判定并找到这个环上的所有点（环的节点集合）；
- 在有向/无向、特殊有向（每点出度=1 或 入度=1）的情形下的高效算法；
- 将环与环外树状部分分离以便后续处理。

## 一句话算法

用 DFS 回溯记录父节点，遇到已访问但不为父节点的节点即可回溯出一条环；对于每个出度为1 的有向图，利用“二次遍历/标记法”或反向建图后使用入度为1的处理可在 O(n) 内找到环。

## 关键思路 (Key Idea)

- 无向图：标准 DFS，遇到已访问且不是父节点的边表示找到了一个环，回溯父指针收集环节点并标记环；其余节点形成若干以环为根的树。
- 有向图（每点出度=1）：从任意未访问点沿出边走，使用“当前起点标记”记录访问轨迹；若遇到被同一轮标记的点，则找到了一个环；若遇到其他轮次的访问或终点（自环外），说明该路径上无新环。
- 有向图（每点入度=1）：反向建图，把问题转成出度=1 的情形，或用拓扑剔除非环点（入度为0 的节点不断出列）剩下的就是环上节点。

带权边的情形可在找出环节点后把环上的权值记录下来用于后续计算。

## 算法步骤 (Algorithm Steps)

1. 无向图找环（完整 DFS 回溯法）：
   - 初始化 dfn/vis/pre（父指针）数组；
   - 任意起点 DFS，遇到已访问且不是父节点时，通过 pre 回溯收集环节点并终止或继续（若只需一个环，遇首个环即可停止）；
2. 有向图（每节点出度=1）：
   - vis[u] 保存 0（未访问）或当前轮次标识（如起点 id）或已确认不在环的标记；
   - 从 u 沿 nxt 指针前进，逐点标记为当前起点 id；
   - 若遇到已被当前起点标记的节点，则从该节点沿 nxt 收集环；
   - 若遇到已被其他起点标记或到达自循环外状态则结束；
3. 有向图（每节点入度=1）：
   - 构建反向图或直接用剔除法（拓扑）：
     - 统计入度，入度为0的节点入队并剔除（会减少后继节点入度），最终剩下的节点集合就是环节点。

## 算法证明 (Proof Sketch)

- 无向 DFS：在 DFS 树中，非树边必为回边或前向边。对无向连通图，遇到已访问且不为父节点的边必然表示存在一个环；沿父指针回溯直到回到重复节点即可收集一个闭环，证明完备。
- 出度=1 的有向图：每个节点出边唯一，路径形成链或最终形成环。用“轮次标记”保证当某轮遇到已被本轮标记的节点时，该节点必在当前路径中，从而构成环；遇到其他轮次标记说明进入已判定区域，无新环。
- 入度剔除法：非环节点必然在拓扑剔除过程中被移除（其出边会使目标入度减少），留下的节点强连通度为 1 的集合只能是环。

## 复杂度分析 (Complexity Analysis)

- 时间复杂度：所有算法均为线性时间 O(n + m)，其中 n = |V|、m = |E|。
- 空间复杂度：需要 O(n) 的标记/父指针数组，额外栈/队列也为 O(n)。

## 代码实现 (C++)

以下提供三种常用实现：无向图 DFS 找环、有向图（出度=1）寻找环、入度剔除法（找所有环点）。代码风格与本书其他章节一致，注释详尽，适合竞赛使用。

```cpp
#include <bits/stdc++.h>
using namespace std;

// ---------- 无向图：DFS 找环（找到一个环并记录环上节点） ----------
int N;
vector<vector<int>> g;
vector<int> dfn, pre;
int timer = 0;
vector<int> circle; // 存放环上的节点(按回溯顺序)

bool dfs_find_cycle(int u, int p) {
    dfn[u] = ++timer;
    pre[u] = p;
    for (int v : g[u]) {
        if (v == p) continue; // 忽略到父节点的边
        if (dfn[v]) {
            // 找到回边：v 已被访问且不是父节点 -> 有环
            // 从 u 回溯到 v 收集环节点
            int x = u;
            circle.push_back(v); // 环的起点（结束点）
            while (x != v) {
                circle.push_back(x);
                x = pre[x];
            }
            reverse(circle.begin(), circle.end());
            return true; // 已找到一个环
        } else {
            if (dfs_find_cycle(v, u)) return true;
        }
    }
    return false;
}

// ---------- 有向图（每节点出度 = 1）：轮次标记法 ----------
vector<int> nxt;
vector<int> mark; // 0: 未访问, >0: 起点标记id, -1: 已处理/不在新环
vector<int> ring_nodes;

void find_cycles_outdeg1(int n) {
    mark.assign(n+1, 0);
    for (int i = 1; i <= n; ++i) {
        if (mark[i]) continue;
        int cur = i;
        int id = i; // 用起点 i 作为当前轮次标记
        while (true) {
            if (mark[cur] == 0) {
                mark[cur] = id;
                cur = nxt[cur];
            } else if (mark[cur] == id) {
                // 找到以 cur 为入口的环，收集环节点
                int x = cur;
                do {
                    ring_nodes.push_back(x);
                    x = nxt[x];
                } while (x != cur);
                break;
            } else {
                // 遇到其他轮次标记或已处理节点，不会产生新环
                break;
            }
        }
        // 将当前路径上的节点（若非环）标记为已处理（-1）
        // 这里为简洁省略路径回溯清理，可在需要时添加。
    }
}

// ---------- 入度剔除法：找到所有在环上的点 ----------
vector<int> indeg;
vector<int> is_in_cycle; // 1 表示在环上，0 表示不在环上
void find_cycle_by_prune(int n) {
    queue<int> q;
    indeg.assign(n+1, 0);
    is_in_cycle.assign(n+1, 1); // 假设都在环上，剔除后不是环的设为0
    for (int u = 1; u <= n; ++u) {
        for (int v : g[u]) indeg[v]++;
    }
    for (int u = 1; u <= n; ++u) if (indeg[u] == 0) q.push(u);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        is_in_cycle[u] = 0;
        for (int v : g[u]) {
            indeg[v]--;
            if (indeg[v] == 0) q.push(v);
        }
    }
    // 剩下 is_in_cycle[u] == 1 的点属于环的候选集合（可能多个环）
}
```

## 测试用例 (Test Case)

1) 无向基环树示例
输入（边集，节点从1开始）:
- n = 6
- edges = {1-2, 2-3, 3-4, 4-2, 3-5, 5-6}

期望：
- 环节点集合 = {2,3,4}（顺序可能为 2,3,4 或其循环移位）
运行说明：用无向 DFS 实现 dfs_find_cycle(1,-1)，circle 将保存环点。

2) 有向出度=1 示例
n = 6, nxt = { -, 2, 3, 4, 2, 6, 5 } (下标从1)
- 链 1->2->3->4->2 构成环 {2,3,4}
- 链 5<->6 自环或小环 {5,6}
find_cycles_outdeg1 会收集这些环。

## 经典例题 (Selected Problems)

- Luogu Pxxxx: 找到图中唯一环并统计环上距离（练习基环树分解）
- USACO / 竞赛题：每个节点出度=1 的函数图里找环（见 USACO 题解）
- 常见题型：环上取一个节点为根，做环上 DP + 树上 DP 的组合问题

## 实践思考与扩展 (Further Thinking & Extension)

- 在找到环后，通常将问题分成“环上处理”与“环外树处理”两部分：环上可以用环形 DP，环外是若干以环点为根的树的普通树 DP。
- 若图不是连通或含多个环，可先用 SCC 或拓扑 + 剔除法识别所有环与环外结构。
- 权值边/最短路问题：找出环后，环上两点间的最短路径需要考虑沿环两侧距离的最小值（可以用前缀和 + 二分或滑动窗口）。
- 开放问题：如何在在线修改边的情况下维护基环树结构（支持插边删边）并快速更新环与树的分解。

## 参考 (References)

- 本书相关章节：book/graph/center_of_tree/index.md
- USACO 题解与讨论（出度=1 的环检测技巧）
- 相关博客：知乎专栏与竞赛题解合集（草稿中提到的参考链接）

附：草稿文件参考： [草稿.md](book/graph/one-loop-graph/草稿.md)
