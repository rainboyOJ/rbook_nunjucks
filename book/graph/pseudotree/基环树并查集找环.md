这个模板的特点是: 

1. 只能找到环上的两个相邻点
2. 不能找到环上的所有的点
3. 如果想要找到环上的所有点: 使用dfs法

原理: 和kruskall 算法一样,不停的添加边，如果两个点已经连通，说明这条边构成了环

```cpp
// 并查集用于找环
struct DSU {
    int fa[MAXN];
    void init(int size) {
        for(int i=0; i<=size; i++) fa[i] = i;
    }
    int find(int x) {
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }
    bool merge(int x, int y) {
        int fx = find(x);
        int fy = find(y);
        if (fx != fy) {
            fa[fx] = fy;
            return true;
        }
        return false;
    }
} dsu;

dsu.init(n);

// 读入边并处理基环
for (int i = 0; i < n; ++i) {
    int u, v;
    cin >> u >> v;
    // 如果 u和v 已经连通，说明这条边构成了环
    if (!dsu.merge(u, v)) {
        S = u;
        T = v;
    } else {
        // 否则这是一条树边，加入邻接表
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
}
```