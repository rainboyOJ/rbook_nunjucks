# 2-SAT 问题图解教程与代码

## Response:

这是一个非常棒的算法话题。2-SAT 问题是图论和逻辑结合的经典案例，在算法竞赛（如 ACM/ICPC、Codeforces）中非常常见。

以下是为你准备的详细教程。

* * *

### 1\. 2-SAT 是什么的缩写？

**2-SAT** 是 **2-Satisfiability**（2-可满足性）的缩写。

*   **SAT (Satisfiability)**：布尔可满足性问题。即给定一组布尔变量和一堆逻辑限制条件，问是否有一种赋值方式（True/False），使得所有条件都成立。
*   **2**：特指每个限制条件（子句）中**最多包含两个变量**。

**背景知识：**

*   **3-SAT**（每个子句3个变量）是著名的 **NP-完全问题**，目前没有多项式时间的解法（只能暴搜）。
*   **2-SAT** 是特例，它可以在 ** $O\left(N+M\right)$ ** 的线性时间内解决，因为它能被转化为**图论问题**。

* * *

### 2\. 2-SAT 问题详解教程

#### 核心概念：把逻辑变成图

2-SAT 问题的标准形式通常是一组“或”关系的合取（Conjunction of Disjunctions）：

$$
\left(A\vee B\right)\wedge \left(\neg A\vee C\right)\wedge \dots
$$

这意味着每一个括号里的条件都必须为真。

**关键转化：逆否命题** 对于限制条件  $\left(A\vee B\right)$ （A 或 B 至少有一个为真），我们可以将其转化为推导关系：

1.  如果  $A$  是假，那么  $B$  **必须**是真。即： $\neg A\Longrightarrow B$ 
2.  如果  $B$  是假，那么  $A$  **必须**是真。即： $\neg B\Longrightarrow A$ 

利用这个性质，我们可以构建一个**有向图（Implication Graph，蕴含图）**。

#### 建图步骤

假设有  $N$  个变量  $x_{1},x_{2},\dots ,x_{n}$ 。 我们在图中建立  $2N$  个节点：

*   节点  $i$  表示  $x_{i}$  为真 (True)。
*   节点  $i+N$  (或记为  $i^{′}$ ) 表示  $x_{i}$  为假 (False)。

对于每个限制条件  $\left(x_{i}\vee x_{j}\right)$ ，我们连两条有向边：

1.   $\neg x_{i}\to x_{j}$  （若  $x_{i}$  假，则  $x_{j}$  必真）
2.   $\neg x_{j}\to x_{i}$  （若  $x_{j}$  假，则  $x_{i}$  必真）

**常见的限制类型与连边方式：**

| 逻辑条件             | 含义            | 连边 1                    | 连边 2                              |
| -------------------- | --------------- | ------------------------- | ----------------------------------- |
| $A\vee B$            | A, B 至少一个真 | $\neg A\to B$             | $\neg B\to A$                       |
| $A=true$             | A 必须为真      | $\neg A\to A$             | (无)                                |
| $A\Longrightarrow B$ | 若 A 真则 B 真  | $A\to B$                  | $\neg B\to \neg A$                  |
| $A\oplus B=1$        | A, B 值不同     | $A\to \neg B,\neg B\to A$ | $B\to \neg A,\neg A\to B$           |
| $A\oplus B=0$        | A, B 值相同     | $A\to B,B\to A$           | $\neg A\to \neg B,\neg B\to \neg A$ |

* * *

#### 判定是否有解

图建好后，问题就变成了图的可达性问题。

**无解的情况：** 如果在图中，从  $x$  出发能走到  $\neg x$ ，**并且** 从  $\neg x$  出发也能走到  $x$ ，那么就会出现逻辑矛盾（ $x$  既要是真，也要是假）。

在图论中，这意味着  $x$  和  $\neg x$  位于同一个 **强连通分量 (SCC, Strongly Connected Component)** 中。

**判定法则：**

1.  使用 **Tarjan 算法** 或 **Kosaraju 算法** 求出图中所有的强连通分量。
2.  检查对于每个变量  $i$ ，节点  $i$  和节点  $i^{′}$  是否属于同一个 SCC。
    *   若 `SCC[i] == SCC[i']`，则**无解**。
    *   若所有变量都不冲突，则**有解**。

* * *

#### 构造一组解

如果判定有解，我们如何确定每个变量是 True 还是 False 呢？

这里利用 Tarjan 算法的一个特性： Tarjan 求 SCC 时，生成的 SCC 编号是按照**拓扑序的逆序**（Reverse Topological Order）排列的。

*   **逻辑：** 如果存在路径  $A\to B$ ，说明选  $A$  必须要选  $B$ 。为了避免冲突，我们倾向于选择“推导链”末端的节点（出度为0或指向已确定的节点）。
*   **规则：** 比较  $x$  和  $\neg x$  所在的 SCC 编号。
    *   如果 `SCC[x] < SCC[not_x]`：通常在 Tarjan 实现中，编号越小代表越先被“弹出”栈（即拓扑序越靠后）。我们选择拓扑序靠后的那个值。
    *   **结论：** 谁的 SCC 编号小，就选谁。（注：这取决于具体的 Tarjan 实现，但在标准实现中，取拓扑序靠后的可以避免向上传递导致的冲突）。

* * *

### 3\. C++ 代码模板 (使用 Tarjan)

这是一份标准的 2-SAT 模板代码。

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

const int MAXN = 200005; // 节点数通常是变量数的2倍

vector<int> adj[MAXN];
int dfn[MAXN], low[MAXN], scc[MAXN];
int timer, scc_cnt;
bool in_stack[MAXN];
stack<int> st;

int n, m; // n个变量, m个条件

// 添加边 u -> v
void add_edge(int u, int v) {
    adj[u].push_back(v);
}

// Tarjan 算法求强连通分量
void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    st.push(u);
    in_stack[u] = true;

    for (int v : adj[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_stack[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }

    if (low[u] == dfn[u]) {
        scc_cnt++;
        while (true) {
            int v = st.top();
            st.pop();
            in_stack[v] = false;
            scc[v] = scc_cnt;
            if (u == v) break;
        }
    }
}

int main() {
    // 输入 n 个变量, m 个子句
    // 假设输入格式：i a j b
    // 表示: (x_i = a) OR (x_j = b)
    // 变量下标 1 到 n。
    // 在代码中：
    // 1 到 n 表示 x_i 为真 (x_i)
    // n+1 到 2n 表示 x_i 为假 (!x_i)
    
    cin >> n >> m;

    for (int k = 0; k < m; ++k) {
        int i, a, j, b;
        cin >> i >> a >> j >> b;
        // a, b 为 1 代表真，0 代表假
        
        // 构造节点编号：
        // 变量 i: 真节点是 i, 假节点是 i + n
        int u = (a == 1) ? i : i + n;       // 条件1对应的节点
        int v = (b == 1) ? j : j + n;       // 条件2对应的节点
        
        int not_u = (a == 1) ? i + n : i;   // u 的反面
        int not_v = (b == 1) ? j + n : j;   // v 的反面

        // 逻辑: u OR v
        // 连边: !u -> v AND !v -> u
        add_edge(not_u, v);
        add_edge(not_v, u);
    }

    // 跑 Tarjan
    for (int i = 1; i <= 2 * n; ++i) {
        if (!dfn[i]) tarjan(i);
    }

    // 检查是否有解
    for (int i = 1; i <= n; ++i) {
        if (scc[i] == scc[i + n]) {
            cout << "IMPOSSIBLE" << endl;
            return 0;
        }
    }

    cout << "POSSIBLE" << endl;
    // 构造解
    for (int i = 1; i <= n; ++i) {
        // 谁的 SCC 编号小选谁 (Tarjan 中编号小的是拓扑序靠后的/缩点后的出度为0的)
        if (scc[i] < scc[i + n]) {
            cout << "1 "; // 选真
        } else {
            cout << "0 "; // 选假
        }
    }
    cout << endl;

    return 0;
}
```

### 4\. 总结与记忆点

1.  **缩写**：2-SAT = 2-Satisfiability（二元可满足性）。
2.  **核心**：将“或”逻辑转化为“蕴含（Implication）”有向边。
    *    $A\vee B\Longleftrightarrow \neg A\to B and \neg B\to A$ 。
3.  **算法**：
    *   **建图**：点数  $2N$ ，边数  $2M$ 。
    *   **SCC**：用 Tarjan 找强连通分量。
    *   **判无解**： $x$  和  $\neg x$  在同一个 SCC 中。
    *   **取值**：取 SCC 编号较小（拓扑序较后）的那个状态。

### 接下来你可以...

如果你想练习这个算法，建议去尝试以下题目：

*   **Luogu P4782** (【模板】2-SAT 问题) —— 上面的代码就是解决这个问题的基础。
*   **Codeforces** 上搜索 tag 为 `2-sat` 的题目（通常结合二分答案或其他逻辑，非常有趣）。



---

Powered by [Gemini Exporter](https://www.ai-chat-exporter.com)