---
id: "ek"
title: "Edmonds-Karp算法"
date: 2025-12-21 13:59
toc: true
tags: ["网络流"]
categories: [""]
---

[[TOC]]


这是一个非常经典的**Edmonds-Karp (EK)** 算法实现需求。

## 题目

luogu P3376 【模板】网络最大流

## 核心思想

1. **BFS 找增广路**：从源点  到汇点  寻找一条依然有容量（剩余流量 ）的路径。
2. **更新流量**：找出这条路径上最小的边权（瓶颈），将整条路径减去这个流量。
3. **反向边（后悔药）**：这是最大流最精髓的地方。当我们流过  时，必须同时增加  的容量。这样做的目的是让程序以后有机会“撤销”之前的操作，从而找到全局最优解。

## 代码实现 (C++)

这份代码使用了**链式前向星**（Chain Forward Star）存图，这是 C++ 图论题的标准写法。

**特别注意技巧**：边的计数器 `cnt` 从 `1` 开始。这样，第 `i` 条边的反向边就是 `i^1`（异或操作）。例如边  的反向边是 ，边  的反向边是 。

```cpp

```

## 重点解析：为什么要用 `pre[v] = i` 存边的编号？

在普通的 BFS 中，我们通常只需要记录 `pre[v] = u`（记录前驱节点）。但在最大流中，两个点之间可能存在多条边（重边），或者我们需要快速找到边的反向边。

* 如果我们只存节点 `u`，回溯时我们不知道具体走的是哪条边，就无法准确修改 `edge[i].w`。
* 存边的编号 `i` 后，我们可以通过 `edge[i].to` 知道终点，通过 `edge[i^1].to` 知道起点，还能直接通过 `edge[i^1]` 访问反向边，一举三得。

## 复杂度

* Edmonds-Karp 的时间复杂度是 。
* 在这个题目中，，EK 算法完全可以通过。
* 如果数据范围更大（例如 ），通常需要使用 **Dinic** 算法。

你先把这份代码提交通过，理解了 `i^1` 和 BFS 回溯更新的过程后，如果你想进阶，我可以教你写 Dinic 算法（目前最常用的最大流算法）。

## 代码

@include-code(/code/graph/luogu-p3376-ek.cpp, cpp)
