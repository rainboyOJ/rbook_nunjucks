---
title: 【算法竞赛】进阶素数筛：详解欧拉筛 (Linear Sieve)
date: 2025-12-03 20:00:00
tags: [算法, 数论, C++]
categories: 算法竞赛
---

## 1. 引言

在上一篇文章中，我们介绍了**埃拉托斯特尼筛法（埃氏筛）**，它的时间复杂度是 $O(n \log \log n)$。虽然已经非常快了，但在 $n = 10^7$ 甚至 $10^8$ 这种极限数据下，或者需要频繁求积性函数时，我们仍需要一种更快、更稳定的算法。

今天我们介绍**欧拉筛（Euler Sieve）**，也就是常说的**线性筛**。它的时间复杂度是严格的 $O(n)$，即筛出 $n$ 以内的素数只需要线性的时间。

## 2. 核心原理

埃氏筛的瓶颈在于：**一个合数可能会被多个素数重复筛除**。
例如：$12$ 既会被 $2$ 筛去 ($2 \times 6$)，也会被 $3$ 筛去 ($3 \times 4$)。这种重复操作增加了不必要的计算。

欧拉筛的核心思想非常简单且强力：
> **让每个合数只被它的“最小质因子”筛除一次。**

为了实现这一点，我们需要在筛的过程中维护两个性质：
1.  从小到大枚举素数 $prime[j]$。
2.  当发现 $i$ 已经被某个素数 $prime[j]$ 整除时，立即停止后续标记（Break）。

## 3. 算法流程图解

假设我们要筛 $N$ 以内的素数。我们维护三个核心变量：
* `visited[i]`：标记 $i$ 是否为合数。
* `primes[]`：按顺序存储找到的素数。
* `i`：当前遍历到的数（倍数）。

### 筛除规则
对于每一个数 $i$，我们枚举已有的素数 $prime[j]$，将 $i \times prime[j]$ 标记为合数。

但是，这里有一个至关重要的判断：
**当 `i % prime[j] == 0` 时，立即停止内层循环（Break）。**

### 为什么必须 Break？(核心难点)

这是欧拉筛的灵魂所在。
当 `i % prime[j] == 0` 时，说明 $prime[j]$ 是 $i$ 的**最小质因子**。
如果不停止，继续用下一个素数 $prime[j+1]$ 去筛，我们要筛的数是：
$$\text{Next} = i \times prime[j+1]$$

因为 $i$ 是 $prime[j]$ 的倍数（即 $i = k \times prime[j]$），代入上式：
$$\text{Next} = (k \times prime[j]) \times prime[j+1] = prime[j] \times (k \times prime[j+1])$$

这说明：数 `Next` 的**最小质因子**其实是 $prime[j]$，而不是我们当前正在使用的 $prime[j+1]$。
根据欧拉筛的原则（只被最小质因子筛除），`Next` 这个数应该留给 $prime[j]$ 在将来 $i$ 变得更大时去筛，而不是现在由 $prime[j+1]$ 越俎代庖。

### 举个栗子：筛 12
* **埃氏筛**：
    * $i=2$ 时，筛掉 $2 \times 6 = 12$。
    * $i=3$ 时，筛掉 $3 \times 4 = 12$。（重复了！）
* **欧拉筛**：
    * 当 $i=4$ 时，素数表里有 $\{2, 3\}$。
    * 先用 $2$ 筛：标记 $4 \times 2 = 8$。
    * 判断：$4 \% 2 == 0$，**Break**！
    * （此时不会计算 $4 \times 3 = 12$。$12$ 将会在 $i=6$ 时，被 $6 \times 2$ 筛掉。这样保证了 $12$ 只被它的最小质因子 $2$ 筛一次）。

## 4. 标准代码模板 (C++)

为了避免变量混用导致的逻辑混乱，建议将素数表和标记数组分开。

时间复杂度：$O(n)$
空间复杂度：$O(n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e7 + 5; // 根据题目要求设置，注意空间限制
int primes[MAXN];         // 存素数
int cnt = 0;              // 记录素数个数
bool st[MAXN];            // st[i]=true 代表 i 是合数(被筛掉了)

void get_primes(int n) {
    // 0和1不是素数，虽然很多时候用不到，但为了严谨可以处理一下
    st[0] = st[1] = true; 
    
    for (int i = 2; i <= n; i++) {
        // 如果没被筛过，说明 i 是素数
        if (!st[i]) {
            primes[cnt++] = i;
        }
        
        // 枚举已有的素数
        for (int j = 0; j < cnt && primes[j] <= n / i; j++) {
            // 筛掉合数：i * primes[j]
            st[primes[j] * i] = true;
            
            // 【核心】如果 primes[j] 能整除 i，说明 primes[j] 已经是 i 的最小质因子
            // 那么 primes[j] 也一定是 (i * primes[j+1]) 的最小质因子
            // 为了避免重复筛除，必须终止
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    int n = 100;
    get_primes(n);
    
    for(int i = 0; i < cnt; i++) {
        cout << primes[i] << " ";
    }
    return 0;
}