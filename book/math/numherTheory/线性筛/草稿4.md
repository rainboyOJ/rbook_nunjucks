
## 2. 核心原理

埃氏筛的瓶颈在于：**一个合数可能会被多个素数重复筛除**。
例如：$12$ 既会被 $2$ 筛去 ($2 \times 6$)，也会被 $3$ 筛去 ($3 \times 4$)。这种重复操作增加了不必要的计算。

欧拉筛的核心思想非常简单且强力：
> **让每个合数只被它的“最小质因子”筛除一次。**

为了实现这一点，我们需要在筛的过程中维护两个性质：
1.  从小到大枚举素数 $prime[j]$。
2.  当发现 $i$ 已经被某个素数 $prime[j]$ 整除时，立即停止后续标记（Break）。

## 核心的解析


设

- $p(a)$ 表示a的最小素因子
- $i(a)$ 表示$i(a) = a \div p(a)$

任何一个合数,都可以拆成

$$
a = p(a) \times i(a)
$$

显然这个拆法对于任意个以a来说,都是唯一的.


任何a都唯一的映射一对$p(a) ,i(a)$


证明1:  一一映射

也就是证明不存在 $i_1 \times x = a, i_2 \times y = a$

如果存在,则$x = y = P(a)$, 那么这个时候$i_1 = i_2$,这说a的分解是唯一的. 

只要我们能保证$i \times p$, 其中$P$ 是 $i \times p$的最小素因子.那么就可以唯一的筛选$V(K,p)$ 这个数字

对于任意一个数字a ,可以得到$a = P(a) \times i(a)$
如果$K!= K(a)$, 则K乘以任意值,不可能是


证明2: $i(a) >= p(a)$


这说明

证明3

一个$i$ 可能对应多个a, 但是一对$i,p$ 只能对应一个a,
只要保证, $p$是数字$a = i\times p$ 的最小素因子,那么就可以用这一对$i,p$ 去筛选

那么我们先写一个朴素的代码,**按K来筛选素数**


```cpp
std::vector<int> primes;
void get_primes(int n) {
    // 0和1不是素数，虽然很多时候用不到，但为了严谨可以处理一下
    st[0] = st[1] = true; 
    
    for (int i = 2; i <= n; i++) {
        // 如果没被筛过，说明 i 是素数
        if (!st[i]) primes.push_back(i);
        
        // 枚举已有的素数,把i当作k
        for( auto p : primes){
            // 不能超过边界
            if( p * i > n) break;
            // 筛掉合数：i * primes[j]
            st[p * i] = true;
            // 记录 ,这个数字被哪个组合删除
            printf("[%d] = %d x %d\n",p*i,p,i);
        }
    }
}
```

显然: 12 会被筛选两次

- `12 = 2 x 6`
- `12 = 3 x 4`

显然`12 = 3 x 4` 不应该出现, 因为3 不是12的最小的素因子


解决这个问题