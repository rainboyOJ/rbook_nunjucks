---
id: "oerlashai"
title: "欧拉线性筛选"
date: 2025-12-16 09:35
toc: true
tags: [""]
categories: [""]
---

[[TOC]]


没问题！如果说 $O(\sqrt{n})$ 的单点求法是“手枪”，那么\*\*线性筛（Linear Sieve / Euler Sieve）\*\*就是批量处理数据的“加特林机枪”。

线性筛的核心难点在于理解\*\*“每个合数只被它的最小质因子筛去一次”**以及**欧拉函数的递推关系\*\*。

下面这篇博客文章同样为你准备好了，重点解析了递推公式的由来，非常适合作为进阶教程。

-----

## 【数论进阶】线性筛（欧拉筛）求欧拉函数：O(N) 的魔法

在上一篇文章中，我们学习了如何用 $O(\sqrt{n})$ 的时间求出一个数的欧拉函数。但是，如果题目要求我们求出 $1$ 到 $10^7$ 之间**所有数**的欧拉函数，单点求法的时间复杂度会飙升到 $O(N\sqrt{N})$，这在竞赛中绝对会 TLE（超时）。

这时候，我们需要引入**线性筛**。它不仅能筛出质数，还能利用**积性函数**的性质，顺手把欧拉函数也算出来，总复杂度仅为 $O(N)$。

## 1 前置知识：积性函数

欧拉函数 $\varphi$ 是一个**积性函数**。这意味着：
如果 $\gcd(a, b) = 1$（$a, b$ 互质），则：
$$\varphi(a \times b) = \varphi(a) \times \varphi(b)$$

这个性质是我们能在筛法中递推计算的关键。

## 2 线性筛的核心逻辑

普通筛法（埃氏筛）慢在同一个合数会被多个质因子重复筛（比如 12 会被 2 和 3 分别筛一次）。
**线性筛**的核心保证是：**每个合数只会被它的“最小质因子”筛掉。**

在筛选过程中（设当前数为 $i$，枚举的质数为 $p$），我们会遇到三种情况，这直接决定了 $\varphi(i \times p)$ 的计算公式：

### 情况 1：$i$ 是质数

显然，$\varphi(i) = i - 1$。
（我们在代码初始化时处理，或者在筛出质数时直接赋值）。

### 情况 2：$i \bmod p \neq 0$ （$i$ 和 $p$ 互质）

此时，$p$ 是质数，且 $p$ 不是 $i$ 的因子。
根据欧拉函数的**积性**性质：
$$\varphi(i \times p) = \varphi(i) \times \varphi(p) = \varphi(i) \times (p - 1)$$

### 情况 3：$i \bmod p = 0$ （$i$ 和 $p$ 不互质，关键！）

这是线性筛最难理解的一步。
当 $i \bmod p = 0$ 时，说明 $p$ 已经是 $i$ 的因子了（而且是最小质因子）。
那么 $i \times p$ 的所有质因子，其实都已经在 $i$ 的质因子列表里了，并没有增加新的质因子种类。

根据欧拉函数通项公式：$\varphi(n) = n \times \prod (1 - \frac{1}{p_k})$。

  * 对于 $i$，公式为 $i \times \prod (1 - \frac{1}{p_k})$
  * 对于 $i \times p$，公式为 $(i \times p) \times \prod (1 - \frac{1}{p_k})$
    *(注意：$\prod$ 后面的部分完全一样，因为质因子种类没变)*

对比一下就能发现：
$$\varphi(i \times p) = \varphi(i) \times p$$

这也是为什么线性筛中遇到 `i % primes[j] == 0` 要 `break` 的原因：我们只需要处理最小质因子。

## 3 C++ 代码实现

这是标准的模板代码，建议背诵。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 1000005; // 假设范围是 10^6

int phi[MAXN];          // 存储欧拉函数值
vector<int> primes;     // 存储质数
bool is_prime[MAXN];    // 标记是否为质数（true表示被筛掉了，即合数）

void get_phi_linear(int n) {
    // 1. 初始化
    // phi[1] = 1 是定义
    phi[1] = 1;
    
    // 默认所有数都没有被筛掉（false）
    // 注意：这里 is_prime[i] == false 代表它是质数（或者还没被筛到）
    // 为了代码逻辑通顺，我们通常定义 is_composite 或者 not_prime
    // 但习惯上常用 bool 数组默认值 false 来省去 memset
    
    for (int i = 2; i <= n; ++i) {
        // --- 情况 1: i 是质数 ---
        if (!is_prime[i]) {
            primes.push_back(i);
            phi[i] = i - 1; // 质数的欧拉函数是 p-1
        }
        
        // 枚举已有的质数，作为最小质因子去筛合数
        for (int p : primes) {
            if (i * p > n) break; // 超出范围
            
            is_prime[i * p] = true; // 标记合数
            
            if (i % p == 0) {
                // --- 情况 3: p 是 i 的因子 ---
                // i * p 的最小质因子是 p，且 p 包含在 i 的因子中
                phi[i * p] = phi[i] * p;
                
                // 【线性筛核心】
                // 保证每个合数只被它的最小质因子筛掉。
                // 如果 i % p == 0，说明 i = p * k。
                // 下一个要筛的数是 i * primes[next]。
                // i * primes[next] = p * k * primes[next]。
                // 它的最小质因子应该是 p，而不是 primes[next]。
                // 所以必须 break，避免重复筛选。
                break;
            } else {
                // --- 情况 2: p 和 i 互质 ---
                // i * p 的最小质因子是 p，且 p 不在 i 的因子中
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
}

int main() {
    int n = 100; 
    get_phi_linear(n);
    
    cout << "phi(10) = " << phi[10] << endl; // 输出 4
    cout << "phi(13) = " << phi[13] << endl; // 输出 12
    return 0;
}
```

## 4 记忆口诀

为了方便在赛场上快速写出，记住这三个分支：

1.  **遇见质数**：直接写 `i - 1`。
2.  **互质乘积**（`i % p != 0`）：利用积性，`phi[i] * (p - 1)`。
3.  **包含因子**（`i % p == 0`）：只是倍数增大，质因子种类不变，`phi[i] * p`。

## 5 复杂度分析

  * **时间复杂度**：$O(N)$。每个合数只会被它的最小质因子筛一次，绝无重复。
  * **空间复杂度**：$O(N)$。需要数组存储状态和结果。

-----

### 总结

线性筛是数论题中的“瑞士军刀”。只要你掌握了这个模板，除了求欧拉函数，你还可以修改几行代码来求**莫比乌斯函数 ($\mu$)**、**约数个数 ($d$)**、**约数和 ($\sigma$)** 等等。它们的逻辑完全一致，都是分“互质”和“不互质”两种情况讨论递推公式。

掌握了它，你就拿到了通往高级数论题目的入场券！