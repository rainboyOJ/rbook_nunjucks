没问题！这正是学习任何复杂算法的最佳路径：**从最简模型入手**。

P14577 那道题之所以难，是因为它同时融合了“26种字符”、“消除逻辑”和“区间查询”。如果我们剥离掉所有花哨的外壳，只留下最核心的“**区间奇偶性**”骨架，就是下面这道为你定制的入门题。

-----

### 题目：01 序列的奇偶性查询

#### 题目描述

给你一个长度为 $n$ 的序列，序列中只包含数字 `0` 和 `1`。
现在有 $q$ 次询问，每次询问给出一个区间 $[l, r]$，请你回答：在这个区间内，数字 `1` 出现的次数是 **奇数** 还是 **偶数**？

#### 输入格式

第一行包含两个整数 $n, q$，表示序列长度和询问次数。
第二行包含一个长度为 $n$ 的字符串，仅包含字符 `'0'` 和 `'1'`。
接下来 $q$ 行，每行两个整数 $l, r$ ($1 \le l \le r \le n$)，表示询问的区间。

#### 输出格式

对于每个询问，输出一行：

  - 如果区间内 `1` 的数量是奇数，输出 `Odd`。
  - 如果区间内 `1` 的数量是偶数，输出 `Even`。

#### 样例输入

```text
5 3
01101
1 5
2 3
2 4
```

#### 样例输出

```text
Odd
Even
Even
```

#### 样例解释

  - `01101`，区间 `[1, 5]` 是 `01101`，有三个 1 $\rightarrow$ 奇数 (Odd)。
  - `01101`，区间 `[2, 3]` 是 `11`，有两个 1 $\rightarrow$ 偶数 (Even)。
  - `01101`，区间 `[2, 4]` 是 `110`，有两个 1 $\rightarrow$ 偶数 (Even)。

-----

### 解题思路解析

#### 方法一：暴力法（不推荐）

每次询问，写一个 `for` 循环从 $l$ 跑到 $r$，统计 1 的个数，然后 `% 2`。

  - **时间复杂度**：$O(n \times q)$。如果 $n, q$ 都是 $10^5$，运算量达到 $10^{10}$，肯定超时。

#### 方法二：普通前缀和（数学思维）

我们维护一个数组 `sum[i]`，表示前 $i$ 个数里有多少个 1。

  - 区间 $[l, r]$ 的 1 的个数 = `sum[r] - sum[l-1]`。
  - 判断 `(sum[r] - sum[l-1]) % 2` 是否为 0。
  - **时间复杂度**：$O(1)$ 查询。这是可行的。

#### 方法三：异或前缀和（位运算思维 —— 本题核心）

这是通往 高阶玩法的必经之路。

我们定义 `P[i]` 为前 $i$ 个数字的**异或和**。

  - `0` 对异或没有影响（因为 $x \oplus 0 = x$）。
  - `1` 会翻转异或的状态（因为 $x \oplus 1$ 会改变奇偶性）。

**核心公式**：
$$\text{区间}[l, r]\text{的奇偶性} = P[r] \oplus P[l-1]$$

**为什么成立？**

  - **加法视角**：偶数个 1 相加是偶数，奇数个 1 相加是奇数。
  - **异或视角**：
      - $1 \oplus 1 = 0$ (两个 1 抵消了，变成偶数)
      - $1 \oplus 1 \oplus 1 = 1$ (三个 1，抵消一对，剩一个，是奇数)
  - 因此，`1` 的**累加和的奇偶性** 完全等价于 **异或和的值**。
  - 利用 $A \oplus A = 0$ 的性质，`P[r] ^ P[l-1]` 就完美剔除了 $[1, l-1]$ 的影响，只留下了 $[l, r]$ 的状态。

-----

### 标准代码 (C++)

请注意看 `P[i] = P[i-1] ^ val` 这一行，这就是“状态更新”；以及 `P[r] ^ P[l-1]` 这一行，这就是“区间查询”。

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

const int MAXN = 100005;
int P[MAXN]; // 前缀异或数组

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, q;
    cin >> n >> q;

    string s;
    cin >> s;
    // 字符串是 0-indexed，但题目习惯通常用 1-indexed，这里我们做个转换
    // 为了方便处理 P[l-1] 当 l=1 的情况，P 数组大小开到 n+1

    P[0] = 0; // 0 个数字的异或和是 0
    for (int i = 0; i < n; i++) {
        // s[i] 是字符 '0' 或 '1'
        // 转化为数字： '0' -> 0, '1' -> 1
        int val = s[i] - '0';
        
        // 核心步骤：维护前缀异或
        // P[i+1] 代表前 i+1 个字符的异或和
        P[i + 1] = P[i] ^ val;
    }

    while (q--) {
        int l, r;
        cin >> l >> r;
        
        // 核心步骤：区间查询
        // 结果为 1 说明区间内有奇数个 1
        // 结果为 0 说明区间内有偶数个 1
        int result = P[r] ^ P[l - 1];

        if (result == 1) {
            cout << "Odd" << "\n";
        } else {
            cout << "Even" << "\n";
        }
    }

    return 0;
}
```

### 从这道题到 P14577 的跨越

做完这道题，你再回看 P14577，你会发现惊人的相似性：

1.  **本题**：只有 `0` 和 `1` 两种情况。我们用 **1 个比特** (int 的最低位) 来存储状态。
2.  **P14577**：有 `a` 到 `z` 26 种字符。我们用 **26 个比特** (int 的 0-25 位) 来存储状态。

<!-- end list -->

  * **本题的 `P[i]`**：`P[i] = P[i-1] ^ val`
  * **P14577 的 `now[i]`**：`now[i] = now[i-1] ^ (1 << (s[i]-'a'))`

看出来了吗？**代码逻辑是一模一样的**。P14577 只是把这个简单的题目做了 26 次“并行处理”而已。这就是位运算在算法竞赛中最迷人的地方。

## 题目


- csp-j 2025 t3