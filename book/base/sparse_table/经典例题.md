
ST 表作为一种高效的静态区间查询工具，其应用场景广泛且直接。为了帮助你更好地掌握它，我挑选了三道从入门到进阶的经典题目。

### 第一阶段：模板应用

这个阶段的目标是熟练掌握 ST 表的基本模板，并能解决标准的 RMQ 问题。

#### 1. 洛谷 P3865 【模板】ST 表
*   **链接**: [Luogu P3865](https://www.luogu.com.cn/problem/P3865)
*   **描述**: 这是最纯粹的 ST 表模板题。给定一个长度为 $N$ 的数组和 $M$ 次查询，对于每次查询，你需要回答区间 $[l, r]$ 内的最大值。
*   **解题思路**:
    *   直接使用本文中提供的 ST 表代码模板即可。
    *   这是检验你对 ST 表基本原理和代码实现是否理解正确的最佳题目。你需要构建一个用于查询区间最大值的 ST 表，然后对每个查询调用 `query(l, r)` 函数。注意题目给的区间是 1-indexed，而代码实现通常是 0-indexed，需要做相应转换。

---

### 第二阶段：复合应用

这个阶段我们来看 ST 表如何与其他信息结合，解决需要同时查询多种区间信息的问题。

#### 2. 洛谷 P2880 [USACO07JAN] Balanced Lineup G
*   **链接**: [Luogu P2880](https://www.luogu.com.cn/problem/P2880)
*   **描述**: 给定 $N$ 头牛的身高，进行 $Q$ 次查询。每次查询一个区间 $[l, r]$，问该区间内最高牛和最矮牛的身高差是多少。
*   **解题思路**:
    *   问题本质是需要同时查询 **区间最大值** 和 **区间最小值**。
    *   ST 表可以完美解决这两个问题。我们可以构建 **两个 ST 表**：一个 `st_max` 用于维护区间最大值，另一个 `st_min` 用于维护区间最小值。
    *   对于每次查询 `[l, r]`，我们分别在两个表上执行 `query_max(l, r)` 和 `query_min(l, r)`，然后将得到的结果相减，即为答案。
    *   这道题展示了 ST 表可以轻松扩展到处理多种满足幂等性的并行查询。

---

### 第三阶段：思想转换

这个阶段的题目需要一些巧妙的转化，将一个看起来不像是 RMQ 的问题转化为 RMQ 问题，这也是 ST 表强大之处的体现。

#### 3. 洛谷 P3379 【模板】最近公共祖先 (LCA)
*   **链接**: [Luogu P3379](https://www.luogu.com.cn/problem/P3379)
*   **描述**: 给定一棵有根树和多次查询，每次查询两个节点 `u` 和 `v` 的最近公共祖先 (LCA)。
*   **解题思路**:
    *   这是一个非常经典的思想转换：**LCA 问题可以转化为 RMQ 问题**。
    *   **步骤 1 (预处理)**: 对树进行一次深度优先搜索（DFS），记录下 **欧拉序 (Euler Tour)**。在遍历过程中，每进入一个节点和回溯离开一个节点时，都将其记录到序列中。同时，记录每个节点在欧拉序中 **第一次出现的位置** 和对应节点的 **深度**。
    *   **步骤 2 (转化)**: 两个节点 `u` 和 `v` 的 LCA，就是它们在欧拉序中第一次出现的位置之间的所有节点中，**深度最小** 的那个节点。
    *   **步骤 3 (求解)**: 这样，问题就变成了查询一个深度数组在某个区间上的最小值。我们可以对这个深度数组构建一个 ST 表。对于每次查询 `(u, v)`，我们先找到它们在欧拉序中第一次出现的位置 `pos_u` 和 `pos_v`，然后利用 ST 表查询 `[min(pos_u, pos_v), max(pos_u, pos_v)]` 区间内深度的最小值对应的节点，即为 LCA。
    *   这个方法被称为 "Tarjan 算法的 RMQ 实现"，它将一个树形结构问题巧妙地拍平成了一个序列问题，并用 ST 表高效求解。
