异或（XOR，符号通常为 $\oplus$ 或代码中的 `^`）在计算机科学和算法竞赛中被称为“神之运算”，因为它同时具备了算术运算和逻辑运算的特性。

以下是异或运算的**核心性质**及其在**实际算法中的应用**总结：

-----

### 一、 核心性质 (Mathematical Properties)

除了你提到的交换律、结合律和逆运算，以下性质构成了异或的完整代数体系：

#### 1\. 归零律 (Self-Inverse / Nilpotence)

$$x \oplus x = 0$$

  * **含义**：任何数和自己异或，结果为 0。
  * **本质**：这是消除操作的基础。两个相同的数会互相“湮灭”。

#### 2\. 恒等律 (Identity Element)

$$x \oplus 0 = x$$

  * **含义**：任何数和 0 异或，保持不变。
  * **本质**：0 是异或群中的“单位元”（类似于加法中的 0，乘法中的 1）。

#### 3\. 自反性 (Reversibility)

$$A \oplus B = C \iff A \oplus C = B \iff B \oplus C = A$$

  * **含义**：异或的逆运算就是它本身。
  * **本质**：这也是你提到的“逆运算还是异或”。它意味着如果你知道三个数中的任意两个，你就能求出第三个。这构成了**加密解密**和**前缀和差分**的基础。

#### 4\. 非进位加法 (Addition without Carry)

$$x \oplus y$$

  * **含义**：异或等价于二进制下的加法，但是**不处理进位**。
  * **公式关联**：$x + y = (x \oplus y) + 2 \cdot (x \land y)$。
      * $x \oplus y$ 是“不进位的部分”。
      * $x \land y$ 是“产生进位的部分”（每一位只有 1+1 才会进位，所以要左移一位即乘 2）。
      * *注：这个公式在处理“位运算求和”类题目中非常重要。*

#### 5\. 位独立性 (Bit Independence / Parallelism)

  * **含义**：第 $i$ 位的异或运算完全不受第 $j$ 位的影响。
  * **本质**：这就是我们上一题（P14577）的核心。我们可以把 32 个（或 64 个）独立的布尔问题压缩到一个整数中并行处理。

-----

### 二、 经典应用场景 (Applications in CP)

掌握了性质，我们来看看它们在算法竞赛中是如何落地的：

#### 1\. 寻找落单的数 (Finding the "Odd One Out")

  * **场景**：数组中除了一个数出现一次外，其余所有数都出现了两次（或偶数次），找出那个数。
  * **解法**：将数组所有元素异或起来。
  * **原理**：利用 **交换律** + **归零律**。
    $$a \oplus b \oplus a \oplus c \oplus b = (a \oplus a) \oplus (b \oplus b) \oplus c = 0 \oplus 0 \oplus c = c$$
  * **题目**：LeetCode 136. Single Number。

#### 2\. 变量交换 (Swap without Temp)

  * **场景**：不使用临时变量交换 `a` 和 `b`。
  * **代码**：
    ```cpp
    a = a ^ b;
    b = a ^ b; // b 变成了 (a ^ b) ^ b = a
    a = a ^ b; // a 变成了 (a ^ b) ^ a = b (此时的b已经是旧a)
    ```
  * **注**：虽然这很酷，但在现代编译器优化下，直接用 `swap(a, b)` 或 `int t` 更快，这更多是一种思维展示。

#### 3\. 区间查询与恢复 (Prefix XOR)

  * **场景**：多次查询静态数组区间 $[L, R]$ 的异或和。
  * **解法**：预处理前缀异或数组 $P$。$Ans = P[R] \oplus P[L-1]$。
  * **原理**：利用 **自反性**。在 $P[R]$ 中，$P[L-1]$ 部分被计算了一次，如果我们再异或一次 $P[L-1]$，这部分就会变成 0（抵消），只剩下 $[L, R]$ 的部分。

#### 4\. 博弈论 (Game Theory - Nim Game)

  * **场景**：Nim 游戏、公平组合游戏。
  * **理论**：**Sprague-Grundy 定理**。
  * **结论**：如果多堆石子的异或和（Nim Sum）不为 0，先手必胜；否则先手必败。
  * **原理**：异或和定义了游戏状态的“平衡”。

#### 5\. 线性基 (Linear Basis)

  * **场景**：给定一组数，求它们能异或出的最大值、最小值，或者判断某个数能否由这些数异或得到。
  * **概念**：类似于线性代数中的“向量基底”。我们可以用 $\log(\max A_i)$ 个数来表示原集合中所有数通过异或能组合出的所有可能性。
  * **本质**：这是异或在“向量空间”上的应用（异或视作加法，0/1 视作系数，构成了域 $GF(2)$ 上的线性空间）。

#### 6\. 简单的对称加密

  * **场景**：隐藏数据。
  * **解法**：`密文 = 明文 ^ 密钥`。
  * **解密**：`明文 = 密文 ^ 密钥`。
  * **原理**：利用 **自反性**。两次异或同一个 key 会还原。

-----

### 总结记忆表

| 性质 | 表达式 | 核心算法应用 |
| :--- | :--- | :--- |
| **归零律** | $A \oplus A = 0$ | 消除成对出现的数、前缀和去重 |
| **恒等律** | $A \oplus 0 = A$ | 初始化、作为“空”状态 |
| **自反性** | $A \oplus B = C \Rightarrow A \oplus C = B$ | 解密、区间查询恢复 |
| **非进位加** | $A+B = (A \oplus B) + 2(A \& B)$ | 位运算求和、高精度运算优化 |
| **位独立** | 并行计算 | 状态压缩（如 P14577） |