- **在有序的数组里查找东西**
    - 查找一个特定的数字。
    - 查找第一个大于或等于某个数的元素。
    - 查找第一个大于某个数的元素。
    - 查找最后一个小于或等于某个数的元素。
    - 统计某个数出现了多少次。

- **猜答案（答案二分）**
    - 解决“最大值最小化”问题。
        - *例子：把一根很长的木头切成 `k` 段，怎么切才能让最长的那一段尽可能短？*
    - 解决“最小值最大化”问题。
        - *例子：在一条路上装 `k` 个路灯，怎么装才能让两盏灯之间的最小距离尽可能远？*

- **在小数（实数）上查找**
    - 计算一个数的平方根，精确到指定的小数位。
    - 求解方程的近似解。

- **其他常见应用**
    - 寻找“山峰”数组的顶点（一个数组先递增后递减，找最大值）。

      这种问题的关键在于，虽然整个数组不是单调的，但我们可以利用**山峰的性质**来确定二分的搜索方向。山峰的左边是“上坡路”，右边是“下坡路”。

      **核心思想：**
      我们每次取中间位置 `mid`，通过比较 `A[mid]` 和它右边紧邻的元素 `A[mid+1]` 的关系，就能判断出 `mid` 正处于上坡还是下坡，从而确定真正的山峰在它的左边还是右边。

      **具体步骤：**
      1.  设置查找区间 `[left, right]` 为整个数组的下标范围。
      2.  取中间位置 `mid`。
      3.  比较 `A[mid]` 和 `A[mid+1]`：
          -   如果 `A[mid] < A[mid+1]`：这说明 `mid` 正处在**上坡**阶段，那么真正的山峰一定在 `mid` 的右边（可能是 `mid+1` 或更远）。因此，我们可以安全地舍弃包括 `mid` 在内的左半部分，更新 `left = mid + 1`。
          -   如果 `A[mid] > A[mid+1]`：这说明 `mid` 正处在**下坡**阶段，那么山峰就是 `mid` 本身，或者在 `mid` 的左边。我们不能排除 `mid` 本身，因此可以舍弃 `mid` 右边的部分，更新 `right = mid`。
      4.  当 `left` 和 `right` 相遇时，那个位置就是山峰的顶点。

      **示例代码 (C++):**
      ```cpp
      #include <iostream>
      #include <vector>

      // 寻找山峰元素的下标
      int findPeakElement(const std::vector<int>& nums) {
          int left = 0;
          int right = nums.size() - 1;

          while (left < right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] < nums[mid + 1]) {
                  // mid 在上坡，山峰一定在右侧
                  left = mid + 1;
              } else {
                  // mid 在下坡或就是山峰，答案在左侧或就是 mid
                  right = mid;
              }
          }
          // 循环结束时，left == right，指向山峰
          return left;
      }

      int main() {
          std::vector<int> mountain = {1, 3, 5, 8, 10, 7, 4, 2};
          int peak_index = findPeakElement(mountain);
          std::cout << "山峰的下标是: " << peak_index << std::endl;
          std::cout << "山峰的值是: " << mountain[peak_index] << std::endl;
          return 0;
      }
      ```
    - 加速某些算法，比如用 O(n log n) 的时间复杂度求解“最长上升子序列”。