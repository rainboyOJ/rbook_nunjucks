### 模式二：同向双指针 (滑动窗口)


## 经典问题：寻找等于 target 的最所有区间

**问题定义**: 给定一个正整数数组 `nums` 和一个目标值 `target`，找到数组中满足其和 `= target` 的 **连续子数组**,输出所有可能的区间

### 算法过程

1. **初始化**：设置左指针 `left = 0,right = 0`，当前窗口和 `current_sum = 0`
2. `current_sum == s` ,输出`left,right`
2. `current_sum > s` ,输出`current_sum -= a[left], left++`
2. `current_sum < s` ,输出`current_sum += a[right], right++`
5. 重复步骤,直到`right`到达数组末尾

### 证明


证明这个算法的正确性，核心在于证明**“不漏”**（即：如果存在一个解，我们的双指针一定能撞上它，而不会擦肩而过）。

这个证明依赖于一个关键性质：**单调性（Monotonicity）**。

我们假设存在一个**标准答案区间** $[i, j]$，其和恰好为 `target`。
我们要证明：当右指针 `right` 移动到位置 $j$ 时，左指针 `left` **一定**能准确地停在位置 $i$。

---

### 证明思路：反证法 + 状态分析

#### 1. 关键时刻的快照
想象一下，算法正在运行。右指针 `right` 一步步向右走，迟早会走到 **$j$** 这个位置（即标准答案的右边界）。

在 **`right` 刚刚抵达 $j$** 的这一瞬间，左指针 `left` 在哪里？
只可能有三种情况：
1.  **$left < i$**：左指针还在答案左边（还没跟上）。
2.  **$left = i$**：左指针正好在答案左边界（抓住了！）。
3.  **$left > i$**：左指针跑过头了（漏掉了！）。

我们要证明 **情况3 是绝对不可能发生的**。

#### 2. 为什么左指针绝对不会“跑过头”？ ($left > i$ 不成立)

**反证法假设**：
假设当 `right` 刚到达 $j$ 时，`left` 已经跑到了 $i$ 的右边（即 $left > i$）。

**推导矛盾**：
* 左指针 `left` 只有在 `current_sum > target` 时才会向右移动。
* 既然 `left` 跑到了 $i$ 的后面，说明在之前的某个时刻（当 `right` 还停留在 $j$ 或者 $j$ 之前某个位置 $k$ 时），窗口内的和已经**大于** `target` 了，迫使 `left` 跨过了 $i$。
* 但是，既然标准答案是 $[i, j]$，且所有数字都是**正整数**，那么对于任何 $k \le j$，子数组 $[i, k]$ 的和一定 $\le$ 子数组 $[i, j]$ 的和（也就是 `target`）。
    * 即：只要 `right` 还没超过 $j$，以 $i$ 为开头的子数组之和就不可能超过 `target`。
* 既然和没有超过 `target`，算法的 `while` 循环条件就不满足，`left` 就不可能主动越过 $i$ 去缩小窗口。

**结论**：在 `right` 到达 $j$ 之前，`left` 绝对没有理由、也没有资格越过 $i$。

#### 3. 既然没跑过头，那一定会相遇吗？

现在我们排除了情况3。当 `right` 刚刚到达 $j$ 时，`left` 必然在 $i$ 的左边或正好在 $i$（即 $left \le i$）。

此时窗口状态是 $[left, j]$。
* 这个窗口包含了标准答案 $[i, j]$，左边多了一些“累赘” $[left, i-1]$。
* 因为是正整数，多余的累赘会导致 `current_sum` $\ge$ `target`。
    * 如果正好 $left=i$，sum等于target，记录答案。
    * 如果 $left < i$，`current_sum` 一定 **大于** `target`。
* 这时候 `while sum > target` 循环启动了！
* `left` 会不断右移，一个个吐出左边的累赘。
* 当 `left` 终于走到 $i$ 时，累赘吐完，`current_sum` 恰好变成 `target`。循环停止，记录答案。

---

### 形象化总结：“守株待兔”与“步步紧逼”

这个算法的正确性可以比喻为：

1.  **Right 指针负责“圈地”**：它无脑向右探索，保证了**所有的右边界**都会被扫描到。
2.  **Left 指针负责“止盈”**：它的移动是被动的，只有钱多了（sum > target）才扔钱。
3.  **单调性保证（正整数）**：
    * 因为钱（数字）都是正的，所以如果不把左边的钱扔掉，总资产永远下不来。
    * 这保证了 Left 指针**不敢**在 Right 指针还没攒够钱之前就乱扔钱（越过正确边界）。
    * Right 指针一旦攒够了（到达 $j$），Left 指针就会被迫行动，不多不少，正好把多余的扔掉，停在 $i$。

**一句话证明：**
> 只要全是正数，左指针在右指针到达目标右边界之前，**绝无可能**因为“和太大”而提前越过目标左边界；因此，当右指针到位时，左指针只可能在左边等待收缩，从而必中目标。



## 经典问题：寻找大于等于 target 的最短区间

**问题定义**: 给定一个正整数数组 `nums` 和一个目标值 `target`，找到数组中满足其和 `≥ target` 的 **连续子数组** 的 **最小长度**。如果不存在，则返回 0。


- 如果$sum(i,j) >= target$,则$sum(i,j+1) >= target$,所以$j+1$不可能是最优解,所以$j$不可以再向右移动
- 如果$sum(i,j) < target$,则$sum(i-1,j) < target$,所以$i-1$不可能是最优解,所以$i$不可以再向右移动


### 算法过程

1. **初始化**：设置左指针 `left = 0,right = 0`，当前窗口和 `current_sum = 0`
2. `current_sum >= s` ,输出`current_sum -= a[left], left++`
2. `current_sum < s` ,输出`current_sum += a[right], right++`
5. 重复步骤,直到`right`到达数组末尾

### 证明

证明这个算法的正确性，核心在于证明**“不漏”**（即：如果存在一个解，我们的双指针一定能撞上它，而不会擦肩而过）。

这个证明依赖于一个关键性质：**单调性（Monotonicity）**。

我们假设存在一个**标准答案区间** $[i, j]$，其和恰好为 `target`。
我们要证明：当右指针 `right` 移动到位置 $j$ 时，左指针 `left` **一定**能准确地停在位置 $i$。

---

### 证明思路：反证法 + 状态分析

#### 1. 关键时刻的快照
想象一下，算法正在运行。右指针 `right` 一步步向右走，迟早会走到 **$j$** 这个位置（即标准答案的右边界）。

在 **`right` 刚刚抵达 $j$** 的这一瞬间，左指针 `left` 在哪里？
只可能有三种情况：
1.  **$left < i$**：左指针还在答案左边（还没跟上）。
2.  **$left = i$**：左指针正好在答案左边界（抓住了！）。
3.  **$left > i$**：左指针跑过头了（漏掉了！）。

我们要证明 **情况3 是绝对不可能发生的**。

#### 2. 为什么左指针绝对不会“跑过头”？ ($left > i$ 不成立)

**反证法假设**：
假设当 `right` 刚到达 $j$ 时，`left` 已经跑到了 $i$ 的右边（即 $left > i$）。

**推导矛盾**：
* 左指针 `left` 只有在 `current_sum > target` 时才会向右移动。
* 既然 `left` 跑到了 $i$ 的后面，说明在之前的某个时刻（当 `right` 还停留在 $j

@include-code(./code/poj3061.cpp, cpp)


- [poj3061](https://vjudge.net/problem/POJ-3061)
- 神奇的思想转换[poj2566](https://vjudge.net/problem/POJ-2566#author=DeepSeek_zh)
- 


