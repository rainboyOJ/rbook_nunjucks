## 区间和

输出正整数数组里面所有满足条件:$Sum(i,j) == target$ 的区间

```
15
6 1 2 3 4 6 4 2 8 9 10 11 12 13 14
6
```


```
1 1
2 4
6 6
7 8
```



**算法步骤**:

1. 初始化快指针 `j = 0`，慢指针 `i = 0`。
2. 初始化当前窗口的和 `sum = a[0]`。
3. 如果`sum == target`,输出一个解,然后`j++`, `sum += a[j]`
4. 如果`sum < target`, `j++`, `sum += a[j]`
5. 如果`sum > target`, `i++`, `sum -= a[i]`

**当 `current_sum == target` 时**，说明当前窗口满足条件，此时为什么尝试不尝试的缩小左边界: $i++$,其实也可以,但是这个为了好看,保证$j>=i$,所以这里放大右边界,即$j++$

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[100009];
int m;

void findsum(int a[],int n,int target){
  int i = 0,j = 0;
  int sum = a[0];
  while(j < n){
    if(sum == target){
      cout << i << " " << j << endl;
      j++; // 这里可能有越界bug,但是下一次循环会判断
      sum += a[j]; 
    }else if(sum < target){
      j++; // 这里可能有越界bug,但是下一次循环会判断
      sum += a[j];
    }else{ // 移动i
      sum -= a[i];
      i++;
    }
  }
}

int main() {
    std::cin >> n;
    for(int i = 0;i < n ;++i ) // i: 0->n
    {
        std::cin >> a[i];
    }
    std::cin >> m;
    findsum(a, n, m);
    return 0;
}
```

注意: 这种方法只适用于正整数数组,如果数组中有负数,那么就不可以了,因为破坏了**单调性**

**证明**

这里其实用到了区间和**单调性** : $sum(i,j) < sum(i,j+1)$

只需要证明,如果存在一对$(i_0,j_0)$,使得$sum(i_0,j_0) == target$,那么算法不可能漏掉这对$(i_0,j_0)$, 即证明了算法的 **正确性**.


分情况讨论, 当$j$到达$j_0$的时候, $i$的位置

1. $i < i_0$ : 说明$sum(i,j) > target$, 那么$i$会一直向右移动,直到$i == i_0$
2. $i == i_0$ : 说明$sum(i,j) == target$, 那么输出$(i,j)$
3. $i > i_0$ : 证明当j到达$j_0$的时候, $i$已经越过了$i_0$, 那么某个时刻$i = i_0$,这个时候k一定小于$j_0$, 那么$sum(i,k) < target$, 那么$i$不会向右移动, 而是$j$向右移动, 直到$j$到达$j_0$, 那么$sum(i,j) == target$, 那么输出$(i,j)$,则$i_0$ 不会被漏掉(反证法)

### 转换成前缀和

此时问题变成了,求有多少对元素满足:$P[j] - P[i] == target$


首先你可以写一个二重循环的暴力代码,枚举$a[j]$为结尾的所有的可能的数对

@include-code(./code/presum.cpp, cpp)

好的当你理解的暴力代码,那么你就可以理解下面,**暴力优化**,利用排序后前缀和数组的单调性

1. $p[j] - p[i] = m$,就是所求
2. $p[j] - p[i] > m$,则对于所有的$k <= i$,$p[j] - p[k] > m$,那么$[0,i]$就是相对于$j$的失配区间,此时应该尝试$i++$
3. 如果$[1,k]$是$p[j]$失配区间,那么对于$p[j+1]$也是失配区间
4. $p[j] - p[i] < m$,则区间$k \in [i+1,j-1]$,都有$p[j] - p[k] < m$,此时$p[j]$已经尝试了所有的可能性,则$j++$


注: 使用前缀和法,可以在存在负值的数组上求满足条件的区间和

@include-code(./code/presum2.cpp, cpp)



对应的题目 @problem(luogu-p1102)


## 寻找大于等于 target 的最短子数组和

**问题定义**: 给定一个正整数数组 `nums` 和一个目标值 `target`，找到数组中满足其和 `≥ target` 的 **连续子数组** 的 **最小长度**。如果不存在，则返回 0。

**算法步骤**:
1.  初始化快指针 `j = 0`，慢指针 `i = 0`。
2.  初始化当前窗口的和 `current_sum = 0`，最小长度 `min_len = infinity`。
3.  快指针 `j` 遍历整个数组，`j` 从 0 到 `n-1`：
    a. 将 `nums[j]` 加入窗口，更新 `current_sum += nums[j]`。
    b. **当 `current_sum >= target` 时**，说明当前窗口满足条件，此时需要尝试收缩窗口的左边界：
        i.  更新最小长度 `min_len = min(min_len, j - i + 1)`。
        ii. 将 `nums[i]` 移出窗口，`current_sum -= nums[i]`。
        iii.慢指针 `i` 向右移动 `i++`。
        iv. 持续这个 `while` 循环，直到 `current_sum < target`，即窗口不再满足条件。
4.  遍历结束后，如果 `min_len` 仍为 `infinity`，说明没有找到，返回 0，否则返回 `min_len`。

**复杂度分析**:
*   **时间复杂度**: $O(n)$。虽然有嵌套循环，但每个元素最多被快指针 `j` 访问一次，被慢指针 `i` 访问一次。
*   **空间复杂度**: $O(1)$。

**代码实现 (C++)**:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int min_subarray_len(const vector<int>& nums, int target) {
    int n = nums.size();
    int min_len = n + 1; // 初始化为一个不可能的值
    long long current_sum = 0;
    int i = 0; // 慢指针

    for (int j = 0; j < n; ++j) { // 快指针
        current_sum += nums[j];
        while (current_sum >= target) {
            min_len = min(min_len, j - i + 1);
            current_sum -= nums[i];
            i++;
        }
    }

    return (min_len == n + 1) ? 0 : min_len;
}
```
