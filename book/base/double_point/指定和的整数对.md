## 指定和的整数对

**问题定义**: 在一个整数数组 `nums` 中，寻找两个数，使它们的和等于一个给定的目标值 `target`。返回这两个数的下标。

### 常用方法

1. 二重暴力循环枚举
2. 二分法
3. 哈希表(桶)
4. 双指针

### 双指针法

**算法步骤**:

1. 先排序
2. 初始化左指针 `left = 0`，右指针 `right = n - 1`（`n` 为数组长度）。
3. 当 `left < right` 时，进行循环：
    1. 计算当前指针指向的两个元素的和 `current_sum = nums[left] + nums[right]`。
    2. 如果 `current_sum == target`，则找到了目标对，返回 `left` 和 `right`。
    3. 如果 `current_sum < target`，说明和太小了。由于数组是排序的，需要增大和，因此将左指针向右移动 `left++`。
    4. 如果 `current_sum > target`，说明和太大了。需要减小和，因此将右指针向左移动 `right--`。
4. 如果循环结束仍未找到，则说明不存在这样的整数对。

**复杂度分析**:
*   **时间复杂度**: $O(n)$。两个指针最多各移动 `n` 次。
*   **空间复杂度**: $O(1)$。


### 证明思路

这里用到了**单调性**的性质,


```
[i ................... j]
```

1. 初始的`i,j`: 答案必然在区间$[i,j]$内
2. 如果$a[i] + a[j] < target$,那么$a[i] + a[k] < target (  i< k < j)$,这说明$a[i]$太小了,**永远不可能是答案**,那么可以把$i$从答案区间里面删除,即`i++`,这样新的答案区间就变成了$[i+1,j]$
3. 如果$a[i] + a[j] > target$,那么$a[k] + a[j] < target  \quad  i< k < j$,这说明$a[j]$太大了,**永远不可能是答案**,那么可以把$j$从答案区间里面删除,即$j--$,这样新的答案区间就变成了$[i,j-1]$
4. 显然,刚开始的区间$[0,n-1]$是符合条件的,这样递归下去一定可以得到答案

问: 当$a[i] + a[j] == target$的时候,$i,j$应该如何移动呢?
答: 思考方式和上面一样,这是$i,j$都可以移动,可以$i++$ 或 $j--$

### 代码实现 

```cpp
// 在已排序数组中寻找和为 target 的两个数
void find_sum_pair(int nums[], int n,int target) {
    sort(nums,nums+n);
    int left = 0;
    int right = n - 1;

    while (left < right) {
        int current_sum = nums[left] + nums[right];
        if (current_sum == target) {
            // 找到目标对
            cout << left << " " << right << endl;
            i++; // 继续寻找下一对
        } else if (current_sum < target) {
            // 和太小，移动左指针
            left++;
        } else {
            // 和太大，移动右指针
            right--;
        }
    }
}
```

对应题目 [[problem: luogu,T609340]] : 详细论证了暴力到双指针的进化