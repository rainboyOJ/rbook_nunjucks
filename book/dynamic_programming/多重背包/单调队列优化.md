这是一个非常好的请求。很多教程上来就丢出代码或者晦涩的公式，导致初学者很难理解“为什么要这样做”。

为了教会你（以及未来的学生），我将这篇教程设计为一个**循序渐进的思维过程**。我们不跳步，从最朴素的公式出发，一步步推导，直到你发现“啊，原来这里可以用单调队列！”。

------

# 教程：彻底搞懂多重背包的单调队列优化

## 1. 回到原点：朴素的二维 DP

首先，请忘掉优化，我们先老老实实地把多重背包的定义写出来。

场景：

你有 $N$ 种物品，容量为 $W$ 的背包。

第 $i$ 种物品：重量 $w$，价值 $v$，数量 $m$。

定义状态：

$f[i][j]$ 表示：只考虑前 $i$ 种物品，背包容量为 $j$ 时能获得的最大价值。

状态转移方程：

我们要决定第 $i$ 种物品拿几个（设拿 $k$ 个）。



$$f[i][j] = \max_{0 \le k \le m} \{ f[i-1][j - k \cdot w] + k \cdot v \}$$

痛点在哪里？

看看这个算法的复杂度：

1. 枚举物品 $i$ ($1 \to N$)
2. 枚举容量 $j$ ($1 \to W$)
3. 枚举个数 $k$ ($0 \to m$)

总复杂度是 $O(W \cdot \sum m_i)$。如果 $\sum m_i$ 很大（比如 $10^5$），这层 $k$ 的循环就是我们要消灭的敌人。

------

## 2. 人类的直觉：分组（按余数分类）

为了消灭 $k$ 循环，我们需要观察 $j$ 的变化规律。

假设当前物品重量 $w=3$。

- 如果我想求 $f[i][10]$，我需要看 $f[i-1][10], f[i-1][7], f[i-1][4], f[i-1][1] \dots$
- 如果我想求 $f[i][11]$，我需要看 $f[i-1][11], f[i-1][8], f[i-1][5], f[i-1][2] \dots$

发现了吗？

计算 $j=10$ 时用到的数据（1, 4, 7, 10），和计算 $j=11$ 时用到的数据（2, 5, 8, 11）是互不干扰的！

第一步转化：

我们可以按照 $j \pmod w$ 的余数 $r$ ($0 \le r < w$) 来把所有的 $j$ 分组。

每一组内部，都是一个等差数列。

我们可以把 $j$ 写成：$j = q \cdot w + r$

其中 $q$ 是商（表示能装下多少个 $w$），$r$ 是余数。

方程重写为（用 $f_{new}$ 代表当前层 $f[i]$， $f_{old}$ 代表上一层 $f[i-1]$）：



$$f_{new}[q \cdot w + r] = \max_{0 \le k \le m} \{ f_{old}[(q - k) \cdot w + r] + k \cdot v \}$$

------

## 3. 数学变换：提取“滑动窗口”

现在我们只盯着某一个余数 $r$ 这一组来看。

为了方便观察，我们定义一个新的下标 $t$，表示上一层状态的商。

即：让 $t = q - k$。

那么，$k$ 就可以表示为 $k = q - t$。

约束条件的变化：

因为 $0 \le k \le m$，所以 $0 \le q - t \le m$，推导出 $t$ 的范围是：



$$q - m \le t \le q$$



这说明 $t$ 在一个长度为 $m+1$ 的区间内滑动。

代入方程（高能预警，这是最关键的一步）：

把 $k = q - t$ 代入原来的方程：

$$f_{new}[q \cdot w + r] = \max_{q-m \le t \le q} \{ f_{old}[t \cdot w + r] + (q - t) \cdot v \}$$

展开括号里的 $(q - t) \cdot v$：

$$f_{new}[q \cdot w + r] = \max_{q-m \le t \le q} \{ f_{old}[t \cdot w + r] + q \cdot v - t \cdot v \}$$

观察常数和变量：

在这个 max 运算中，我们正在计算的是当前商为 $q$ 的情况。

- $q \cdot v$：对于当前的 $q$ 来说，这是个**常数**，可以提出来！
- $f_{old}[t \cdot w + r] - t \cdot v$：这一坨只和 $t$ 有关。

于是，公式变成了：

$$f_{new}[q \cdot w + r] = \underbrace{\max_{q-m \le t \le q} \{ f_{old}[t \cdot w + r] - t \cdot v \}}_{\text{这是一个滑动窗口求最大值问题}} + q \cdot v$$

------

## 4. 为什么可以用单调队列？

让我们给上面那一坨只和 $t$ 有关的东西起个名字，叫 $Val(t)$：



$$Val(t) = f_{old}[t \cdot w + r] - t \cdot v$$

那么方程简化为：



$$f_{new}[q \cdot w + r] = \max_{q-m \le t \le q} \{ Val(t) \} + q \cdot v$$

**这不就是滑动窗口最大值吗？**

- 随着 $q$（当前背包容量商）不断增加，窗口 $[q-m, q]$ 整体向右平移。
- 我们需要在 $O(1)$ 的时间内找到这个窗口内的最大值。

这正是单调队列的拿手好戏！

我们需要维护一个单调递减的队列，队列里存的是下标 $t$，使得对应的 $Val(t)$ 单调递减。

------

## 5. 算法流程图解

假设 $w=3, v=4, m=2$ (最多拿2个)。我们处理余数 $r=1$ 的这组。

$j$ 的序列为：$1, 4, 7, 10, 13, 16 \dots$

对应的商 $q$ 为：$0, 1, 2, 3, 4, 5 \dots$

我们要计算 $q=3$ (即 $j=10$) 时的值。

窗口范围：$t \in [3-2, 3] = [1, 3]$。我们需要找 $t=1, 2, 3$ 中谁的 $Val(t)$ 最大。

**单调队列操作步骤：**

1. **清理队头**：检查队头元素（下标）是否小于 $q-m$（过期了）。如果是，踢出队头。
2. **维护单调性**：准备插入新的下标 $q$。
   - 比较 $Val(q)$ 和 队尾元素的 $Val$。
   - 如果 $Val(q) \ge Val(队尾)$，说明 $q$ 不仅更新（靠后），而且值还更大（或相等），那队尾那个元素永远不可能成为最大值了（它是“又老又弱”）。**踢出队尾**。
   - 重复直到队列为空或队尾比 $q$ 强。
3. **入队**：把 $q$ 放入队尾。
4. **计算答案**：此时队头元素即为当前窗口内的最优 $t_{best}$。
   - $f_{new}[q \cdot w + r] = Val(t_{best}) + q \cdot v$
   - 也就是：$f_{new}[j] = (f_{old}[t_{best} \cdot w + r] - t_{best} \cdot v) + q \cdot v$

------

## 6. 代码实现（C++）

为了节省空间，我们通常使用滚动数组。但在单调队列优化中，我们需要引用上一层的数据。

注意：为了避免覆盖，我们需要两个数组，或者拷贝数组。这里为了清晰，我使用 pre_dp 备份上一层数据。


```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

// 假设最大容量和最大物品数
const int MAX_W = 40005; 

int dp[MAX_W];      // 当前状态
int pre_dp[MAX_W];  // 上一轮状态备份
int q[MAX_W];       // 单调队列，存的是下标 t (即商)

// 核心处理函数
// n: 物品数, W: 背包容量
// v[], w[], m[]: 价值, 重量, 数量数组 (下标从1开始)
void solve(int n, int W, int v[], int w[], int m[]) {
    
    // 初始化 dp 数组，一般为0
    memset(dp, 0, sizeof(dp));

    // 1. 枚举物品 i
    for (int i = 1; i <= n; ++i) {
        
        // 必须备份！因为计算 dp[i][...] 需要用到 dp[i-1][...]
        // 如果直接在 dp 上改，单调队列里的值可能已经被当前层更新过了，导致逻辑错误
        memcpy(pre_dp, dp, sizeof(dp));

        // 2. 枚举余数 r
        // 这是将问题拆分成 w[i] 个独立的线性序列
        for (int r = 0; r < w[i]; ++r) {
            
            int head = 1, tail = 0; // 初始化队列

            // 3. 枚举商 k (代码里常用 k 表示商，对应公式里的 q)
            // 实际容量 j = k * w[i] + r
            for (int k = 0; k * w[i] + r <= W; ++k) {
                
                // 计算当前下标 k 对应的 Val 值
                // 公式：Val(t) = pre_dp[t*w+r] - t*v
                int val = pre_dp[k * w[i] + r] - k * v[i];

                // --- 单调队列标准操作 ---
                
                // A. 维护单调递减性 (入队前，把比当前弱的干掉)
                // 队列存的是下标，我们需要比较的是 val
                // q[tail] 是队尾存的下标，val_in_queue 是队尾下标对应的 Val
                while (head <= tail) {
                    int t_idx = q[tail];
                    int val_in_queue = pre_dp[t_idx * w[i] + r] - t_idx * v[i];
                    if (val >= val_in_queue) {
                        tail--;
                    } else {
                        break; 
                    }
                }

                // B. 入队
                tail++;
                q[tail] = k;

                // C. 清理过期队头
                // 当前是 k，窗口长度是 m[i] + 1 (包含自己)
                // 所以合法的下标范围是 [k - m[i], k]
                // 如果队头下标 < k - m[i]，说明过期了
                if (q[head] < k - m[i]) {
                    head++;
                }

                // D. 更新 DP
                // 队头就是当前窗口内 Val 最大的下标 best_t
                int best_t = q[head];
                int max_val = pre_dp[best_t * w[i] + r] - best_t * v[i];
                
                // 公式：dp[j] = MaxVal + k * v
                dp[k * w[i] + r] = max_val + k * v[i];
            }
        }
    }
}
```

## 7. 总结回顾

请按以下步骤记忆，不要死记代码：

1. **朴素DP太慢**：$O(W \cdot \sum m)$ 伤不起。

2. **余数分组**：$w=3$ 时，容量 10 只和 7, 4, 1 有关。这让我们可以把 $W$ 拆成 $w$ 条互不相干的线。

3. 变形公式：把 $k$ (物品数量) 换成 $t$ (上一层的商)。

   $f_{new} = \max(f_{old} - t \cdot v) + q \cdot v$。

4. **发现单调性**：$\max(\dots)$ 部分就是一个典型的**定长滑动窗口取最大值**问题。

5. **单调队列**：用 $O(1)$ 解决滑动窗口最值。

这样，我们就成功地把 $O(k)$ 的循环给优化掉了，总复杂度降为 $O(N \cdot W)$。这也就是多重背包的**终极形态**。