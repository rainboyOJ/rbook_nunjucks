# You Asked:

---
id: "pair_number"
title: "配对问题"
date: 2025-12-20 09:23
toc: true
tags: ["枚举"]
categories: [""]
---

[[TOC]]



## 教学目标

- 公式$\sum a(i)$,$a(i)$:以$i$为结点的值是什么
- 本质++不重不漏++集合分类问题


## 题目: 黑白气球

有一排黑白气球,你可以随机选两个球,问有多少种方法选到颜色不同的球?

- 第一行表示有多个气球
- 0表示白色
- 1表示黑色


```
6
0 1 1 0 0 1
```

输出

```
9
```
代码

@include-code(./bloon, cpp)


## 解释

本质这是一个++不重不漏++的集合分类问题

先给每个气球进行编号

```
0 1 1 0 0 1
1 2 3 4 5 6
```

那么答案的$9$对气球如下:


| 编号| 对|
|--|--|
| 1| $(1,2)$|
| 2| $(1,3)$|
| 3| $(2,4)$|
| 4| $(3,4)$|
| 5| $(2,5)$|
| 6| $(3,5)$|
| 7| $(1,6)$|
| 8| $(4,6)$|
| 9| $(5,6)$|


### 证明这是一个集合问题:

原题目部我们: 1. 任何选一对 2. 且这一对的颜色不同

我们一步一步做,任选一对气球,可以得到集合$A = \{(1,2),{1,3},{2,3},{1,4},{2,4}, \cdots,(5,6)\}$这样的集合,然后去除集合$A$中颜色相同的一对气球,得到集合$B = \{(1,2), (1,3), (2,4), (3,4), (2,5), (3,5), (1,6), (4,6), (5,6) \}$,那么问题的答案就是集合$B$的基数(元素数量)


### 集合分类

如果我们可以把集合$B$++不重不漏++的分成多个子集合$b_i$,那么答案就是$\sum |b_i|$

显然按对数的结尾的数字,可以把集合$B$++不重不漏++的分成多个子集$b_i$.$b_i$表示结尾为$i$的元素形成的集合.例如$b_3 = \{(1,3)\}$.

证明:

- 不重: 显然以$i$为结尾的元素不可能和以$j$为结尾的元素在同一个集合
- 不漏: 任意一个元素一定会以$i \in [1,n]$为结尾



## 总结


!!! definition 定义: 配对问题

有条件的一对组合(任取两个元素)问题,我们称为对数类问题.

!!!


对数类问题的通常解法就是按结尾位置,把集合分类.关键在于如何快速的求取一个子集的数量.

对于对数类问题,对数问题的公式: ``\sum s(i)``

这里用到了**集合**与**分类加法原理**


## 题目2

在一个长n的**链式**的黑白气球,

1. 最大的配对数字和是那一对
2. 距离最远的是那一对那个

```
6
0 1 1 0 0 1
1 2 3 4 5 6
```

## 题目3

在一个长n的**环形**的黑白气球,

1. 最大的配对数字和是那一对
2. 距离最远的是那一对那个

```
6
0 1 1 0 0 1
1 2 3 4 5 6
```

## 练习题目

1.  noiopenjudge  ch0201-6184 找和为K的两个元素 
2.  luogu P1311 [NOIP2011 提高组] 选择客栈  


上面是我的教案文章, 我的目的的教会学生学习 最常见的配对问题, 我的文章,有没有遗漏的部分: 没有考虑到 的一些常见的配对枚举

# Gemini Responded:

这是一个非常扎实的教案雏形。你抓住了“配对问题”的核心思想——**固定右端点，统计左端点**（即你提到的“按结尾位置分类”）。这是从 $O(N^2)$ 暴力枚举优化到 $O(N)$ 或 $O(N \log N)$ 的关键思维。

基于你的教案，我分析了几个**关键的遗漏点**和**可以深化的方向**，这些在算法竞赛（OI）和编程面试中非常常见。

以下是建议补充的内容，按重要性排序：

### 1. 缺失的核心模型：数值约束 (Two Sum 模型)
目前的题目是“颜色不同”（0/1 属性），这属于**离散属性匹配**。但最经典的配对问题其实是**数值和/差/积**的问题。

* **场景**：找出 $a_i + a_j = K$ 的对数。
* **为何重要**：它引入了“哈希表”或“桶”的思想。你的气球问题其实是这个的简化版（桶只有 0 和 1 两个下标）。
* **教学扩展建议**：
    * 在气球问题后，加一个题目：数组中找出 $a_i + a_j = 10$ 的对数。
    * 借此引出**“查表法”**：当枚举到 $a_j$ 时，不需要回头遍历所有 $a_i$，只需要去一个 `count` 数组里查 $K - a_j$ 出现过几次。

### 2. 缺失的思维：余数分类 (同余性质)
这是“颜色不同”问题的数学抽象版，考察频率极高。

* **题目模型**：给定一堆数字，问有多少对 $(i, j)$ 使得 $(a_i + a_j)$ 能被 $K$ 整除。
* **逻辑**：
    * 如果不分类，是 $O(N^2)$。
    * 如果分类，是将数字按 $\% K$ 的余数分类。余数 $x$ 只能和余数 $(K-x) \% K$ 配对。
* **补充价值**：这能极好地训练“集合分类”的思想。

### 3. 缺失的常见约束：距离限制 (Sliding Window)
你在题目2中提到了“距离最远”，但通常还有一种常见限制是“距离不超过 $D$”。

* **题目模型**：统计有多少对 $(i, j)$ 满足 $condition$ 且 $j - i \le D$。
* **逻辑**：
    * 这引入了**滑动窗口**或**双指针**的概念。
    * 当我们从 $j$ 移动到 $j+1$，过期的 $i$ (即 $j - D - 1$) 需要从集合/桶中移除。

### 4. 题目2与3的模糊点与优化建议
目前的题目2和3描述略显模糊，建议具体化：

* **问题**：“最大的配对数字和”是指下标和 $i+j$ 还是数值和 $val[i]+val[j]$？如果是数值和，且只是找最大，排序首尾相加即可，体现不出“枚举”的精髓。
* **建议修改**：
    * **题目2 (链式)**：改为“求有多少对 $(i, j)$ 满足 $i < j$ 且 $a_i > a_j$（逆序对的简单版）”或者“$a_i$ 和 $a_j$ 颜色相同且距离不超过 $K$”。这能结合路边的客栈那道题。
    * **题目3 (环形)**：环形通常的处理技巧是**断环为链**（数组复制一倍变成 $2n$）。这是一个非常重要的“元技巧”，应该在教案里显式提出来。

### 5. 算法复杂度的对比 (教案的点睛之笔)
在“解释”部分，建议显式对比两种写法：

1.  **暴力枚举**：两层 for 循环，固定 $i$ 找 $j$（或反之）。$O(N^2)$。
2.  **记忆化枚举**（你的方法）：一层 for 循环，走到 $j$ 时，利用之前维护的信息直接计算。$O(N)$。

---

### 修改后的教案结构建议

你可以考虑在“题目: 黑白气球”和“题目2”之间，插入一个**进阶解释**。

#### 新增小节：如何快速计算 $b_i$ 的大小？ (Bucket/Map 思想)

> (接在“证明不重不漏”之后)
>
> 知道分类原理后，我们不需要真的把集合 $b_i$ 列出来。我们只需要一个**计数器**。
>
> 当我们遍历到第 $j$ 个气球（假设是黑色）时，我们要找前面有多少个白色气球。
> 我们可以维护两个变量 `cnt_black` 和 `cnt_white`：
> 1. 走到位置 $j$。
> 2. 如果 $color[j]$ 是黑，答案加上 `cnt_white`。
> 3. 把 $color[j]$ 加入计数器 (`cnt_black++`)。
>
> 这就是**边枚举，边维护历史信息**。

---

### 针对你现有练习题的补充
你列出的 `NOIP2011 选择客栈` 是一道非常经典的题，它包含两个要素：
1.  颜色相同（配对）。
2.  中间有最低消费（区间最值/有效性）。

这道题其实正好弥补了我上面说的“距离/范围限制”的缺失。你可以在教案中把这道题作为**“带条件的配对”**来重点讲解。

### 总结你的遗漏列表

1.  **数值 Hash 类**：$a_i + a_j = K$（Two Sum）。
2.  **同余类**：$(a_i + a_j) \% K == 0$。
3.  **距离限制类**：$j - i \le K$（滑动窗口维护计数）。
4.  **环形处理技巧**：断环为链。

### 能够为你做的下一步
你需要我为你**生成“数值约束（Two Sum）”或“同余分类”的教案段落**，以便你直接插入到文章中吗？

---

# You Asked:

好的你来生成

# Gemini Responded:

这是一个可以直接插入到你教案中的补充模块。我延续了你原本的 Markdown 风格（包括 `!!!` 提示块和 `++` 高亮格式），重点补充了**数值约束**和**余数分类**这两个算法竞赛中最核心的配对模型。

你可以将以下内容插入到你原教案的 **“题目: 黑白气球”** 之后，或者作为 **“进阶题目”** 章节。

-----

## 进阶模型1：数值配对 (Two Sum)

在“黑白气球”中，我们关注的是属性是否相等（0或1）。如果把气球变成带有数字的卡片，问题升级为：有多少对 $(i, j)$ 满足 $a_i + a_j = K$？

### 题目描述

给定一个长度为 $n$ 的整数数组 $a$ 和一个目标值 $K$，求有多少对下标 $(i, j)$ 满足 $i < j$ 且 $a_i + a_j = K$。

**输入样例：**

```text
6 10
1 5 3 4 9 7
```

**输出样例：**

```text
2
```

(解释：$1+9=10$, $3+7=10$)

### 解释

这依然是**集合分类**思想。当我们枚举右边的元素 $a_j$ 时，我们需要在左边的集合中寻找值为 $K - a_j$ 的元素数量。

我们可以建立一个“桶”或者哈希表（Map）来记录历史数据的出现次数。

1.  **枚举**：遍历每一个数 $x$。
2.  **查询**：查找“桶”中是否有 $K-x$。如果有，答案加上桶里 $K-x$ 的数量。
3.  **记录**：将当前数 $x$ 放入“桶”中（数量+1）。

\!\!\! warning 注意
查询和记录的顺序不能颠倒。必须先查询（找之前的），再记录（把自己加进去），这样才能保证满足 $i < j$ 且不会自己和自己配对。
\!\!\!

### 代码实现

```cpp
// 假设数值范围较小，可以用数组作为桶；如果数值很大，需用 std::map
int n, k;
cin >> n >> k;
vector<int> a(n);
map<int, int> cnt; // 桶：记录数值出现的次数
long long ans = 0;

for(int i = 0; i < n; i++) {
    cin >> a[i];
    int target = k - a[i]; // 我们需要的另一半
    
    // 1. 先去桶里查，看之前有没有出现过 target
    if(cnt.count(target)) {
        ans += cnt[target]; 
    }
    
    // 2. 把当前数字放入桶中，供后面的人配对
    cnt[a[i]]++; 
}
cout << ans << endl;
```

-----

## 进阶模型2：余数分类 (整除问题)

这是配对问题中考频极高的变种。题目往往问：有多少对数的和是 $K$ 的**倍数**？

### 题目描述

给定 $n$ 个正整数，问有多少对 $(i, j)$ 使得 $(a_i + a_j)$ 能被 $K$ 整除？

### 解释

如果直接枚举和，可能性太多。根据**同余性质**，我们可以把所有数字按 **$\% K$ 的余数** 进行分类。

假设 $K=5$：

  - 如果一个数是 $1$ (余数1)，它必须和余数为 $4$ 的数配对 ($1+4=5$)。
  - 如果一个数是 $2$ (余数2)，它必须和余数为 $3$ 的数配对 ($2+3=5$)。
  - 特殊情况：如果余数是 $0$，它只能和余数是 $0$ 的数配对。

所以，我们不需要关心数字具体是多少，只需要关心它的 **余数**。

**公式推导：**
若 $a_j \% K = r$，则我们需要寻找之前的 $a_i$ 满足 $a_i \% K = (K - r) \% K$。

### 代码核心

```cpp
int n, k;
cin >> n >> k;
vector<int> cnt(k, 0); // 余数桶，只需要大小为 k
long long ans = 0;

for(int i = 0; i < n; i++) {
    int x;
    cin >> x;
    int rem = x % k;          // 当前数的余数
    int need = (k - rem) % k; // 需要的另一半余数
    
    ans += cnt[need]; // 加上之前满足条件的个数
    cnt[rem]++;       // 记录当前余数
}
```

-----

## 技巧：环形问题的“断环为链”

针对你教案中的 **“题目3 (环形)”**，这里有一个通用的标准解法，建议加入教案。

对于环形问题（比如 $1$ 号和 $n$ 号也是相邻的），最经典的技巧是**复制一倍**。

### 方法

将数组 $A[1 \dots n]$ 复制一份接到后面，变成 $A[1 \dots 2n]$。
例如：`1 2 3` 变成 `1 2 3 1 2 3`。

这样，原环形数组中任意长度为 $n$ 的连续区间，现在都在这个 $2n$ 的链式数组中体现为了一个连续子段。我们就成功把“环形问题”转化为了“链式上的滑动窗口问题”。

**题目3思路提示：**

1.  构建 $2n$ 长度的数组。
2.  问题转化为：在 $2n$ 数组中，找距离不超过 $n$ 的配对。

---

# You Asked:

3. **距离限制类**：（滑动窗口维护计数）。 这个你没有补充阿

# Gemini Responded:

抱歉，把这个重要的模块漏掉了。这是\*\*“距离限制类”\*\*的教案补充。

这一类问题非常关键，它标志着算法思维从“静态统计”向“动态维护”转变。你可以把这段加在“进阶模型2”之后。

-----

## 进阶模型3：距离限制 (滑动窗口)

在之前的题目中，任何之前的气球都可以和当前气球配对。但现实中往往有**距离限制**。

### 题目描述

给定一个数组，问有多少对 $(i, j)$ 满足：

1.  $a_i = a_j$ (颜色相同)
2.  $j - i \le K$ (距离不超过 $K$)

**输入样例：**

```text
6 2
1 2 1 3 1 2
```

($N=6$, 距离限制 $K=2$)

**输出样例：**

```text
2
```

**解释：**

  - 下标 $0$ 的 `1` 和下标 $2$ 的 `1`：距离 $2-0=2 \le 2$ (符合)
  - 下标 $2$ 的 `1` 和下标 $4$ 的 `1`：距离 $4-2=2 \le 2$ (符合)
  - 下标 $0$ 的 `1` 和下标 $4$ 的 `1`：距离 $4-0=4 > 2$ (不符合，太远了)

### 解释：过期的要扔掉

如果我们还像之前一样只把数字放入桶里，桶里的数字会越来越多，包含那些距离很远的“过期”数字。

我们需要维护一个\*\*“滑动的窗口”\*\*：

1.  **入窗**：当我们走到 $j$ 时，把 $a_j$ 加入统计。
2.  **出窗**：如果窗口太大了（超过 $K$），就要把最左边那个“过期”的元素从桶里拿出来（计数减一）。

这个过程就像一个长度为 $K$ 的框，在数组上向右滑动。

### 算法流程

当我们遍历到第 $j$ 个元素时：

1.  **检查过期**：计算窗口左边界。如果 $j > K$，说明下标 $j-K-1$ 的元素已经失效了（距离变成了 $K+1$），需要从桶中 `cnt[a[j-K-1]]--`。
2.  **统计答案**：查询桶中 $a_j$ 现有的数量（这些肯定都是距离合法的）。
3.  **加入当前**：把 $a_j$ 放入桶中 `cnt[a[j]]++`。

### 代码实现

```cpp
int n, k;
cin >> n >> k;
vector<int> a(n);
map<int, int> cnt; // 或者用数组 int cnt[MAX_VAL]
long long ans = 0;

for(int j = 0; j < n; j++) {
    cin >> a[j];

    // 1. 核心步骤：移除过期的 (Sliding Window)
    // 当 j=k+1 时，距离 j 超过 k 的是 j-k-1 = 0 号元素
    if (j > k) {
        int expired_index = j - k - 1;
        cnt[a[expired_index]]--; 
    }

    // 2. 统计 (桶里剩下的都是距离 <= K 的)
    ans += cnt[a[j]];

    // 3. 加入当前
    cnt[a[j]]++;
}
cout << ans << endl;
```

\!\!\! success 总结
**滑动窗口**的本质是：在枚举 $j$ 的同时，维护一个**动态的桶**。
我们不仅要学会 `add` (加入集合)，还要学会 `remove` (移出集合)。
\!\!\!

-----

### 与 NOIP 2011 选择客栈 的联系

你在练习题中提到的 **[NOIP2011 提高组] 选择客栈** 就是这个模型的升级版。

  - **客栈题难点**：它不仅要求颜色相同 ($A_i = A_j$)，还要求 $i$ 和 $j$ 之间有一个客栈的价格 $\le P$。
  - **转化思路**：
      - 这其实是**带条件的距离限制**。
      - 这里的“有效性”不是靠固定的距离 $K$，而是靠“中间是否有低价客栈”。
      - 如果 $i$ 和 $j$ 之间出现了低价客栈，那么 $i$ 及其左边所有同色客栈，对于未来的 $j$ 都是“永不过期”的。
      - 这是一个非常好的练习题，用来考察学生是否理解了“何时记录”和“何时统计”。

---

# You Asked:

## 再次进阶: 单调队列


- P1886 【模板】单调队列 / 滑动窗口

怎么样 ?

# Gemini Responded:

这是一个非常棒的**拔高**方向。

从“滑动窗口计数（桶）”到“单调队列（最值）”是一个非常自然的思维跳跃，也是 NOIP/CSP 提高组的常见考点。

但是，需要注意一点：**之前的桶是用来解决“计数/求和”问题的，而单调队列是用来解决“最值/优化”问题的。**

为了保持你教案“配对问题”的主题连贯性，建议不仅介绍 P1886 模板，还要给出一个**利用单调队列解决的配对问题**（例如：限制距离求两数之和最大）。

以下是建议插入的模块：

-----

## 再次进阶：单调队列 (滑动窗口的最值)

在上一节“距离限制”中，我们用“桶”维护了窗口内的**计数**信息。因为“计数”是可以直接加减的（进来加一个，出去减一个）。

但如果问题变成了：**在距离不超过 $K$ 的范围内，找到 $A_i + A_j$ 的最大值**，怎么办？

我们无法用“桶”来维护最大值。因为当一个最大值“滑出”窗口时，我们不知道**次大值**是谁。我们需要一个更高级的数据结构——**单调队列**。

### 核心思想：剔除“无用”的元素

做配对最大值时，我们关注的是窗口内的“强者”。

\!\!\! quote 经典语录
如果一个元素比它前面的元素更小（或更弱），而且还比前面的元素出现得晚（更年轻），那么前面的那个元素就**永远**没有机会成为最大值了。
\!\!\!

这就是单调队列的核心：**维护一个单调递减（或递增）的队列，队列头部永远是当前窗口的最优解。**

### 练习题：P1886 滑动窗口

虽然这是模板题，但它是解决复杂配对问题的基石。

**题目大意**：有一个长为 $n$ 的序列，有一个长为 $k$ 的窗口在从左向右滑动，输出每次窗口内的最大值（和最小值）。

**代码实现 (求最大值)**：

我们需要使用双端队列 `deque`（或者手写数组模拟），存储的是**下标**。

```cpp
#include <deque>
// ...

int n, k;
cin >> n >> k;
vector<int> a(n);
for(int i=0;i<n;i++) cin>>a[i];

deque<int> q; // 存的是下标！
for(int i = 0; i < n; i++) {
    // 1. 入队前：维护单调性 (把前面比自己弱的都踢开)
    // 我们要找最大值，如果新来的 a[i] >= 队尾，那队尾那个数就是废的
    while(!q.empty() && a[q.back()] <= a[i]) {
        q.pop_back();
    }
    
    // 2. 入队
    q.push_back(i);
    
    // 3. 出队：维护窗口时效性 (把过期的踢走)
    // 队头是最大的，但如果队头的下标离 i 太远(> k-1)，就过期了
    if(q.front() <= i - k) {
        q.pop_front();
    }
    
    // 4. 获取答案
    // 窗口形成后 (i >= k-1)，队头就是当前窗口 [i-k+1, i] 的最大值
    if(i >= k - 1) {
        cout << a[q.front()] << " ";
    }
}
```

### 回到“配对问题”

学会了单调队列，我们就能解决这样的配对难题：

**题目：** 找到一对 $(i, j)$，满足 $1 \le j - i \le K$，使得 $A_i + A_j$ 最大。

**解法：**
这本质上是枚举 $j$，然后在 $j$ 左边的合法窗口 $[j-K, j-1]$ 里找一个最大的 $A_i$。
公式为：$MaxSum = A_j + \max(A_i)$，其中 $i \in [j-K, j-1]$。

直接套用单调队列维护 $A_i$ 的最大值即可将复杂度控制在 $O(N)$。

-----

### 教学建议

1.  **对比**：务必向学生强调，“桶/哈希表”是处理 **“有多少对”** (Sum/Count)，而“单调队列”是处理 **“哪一对最大”** (Max/Min)。
2.  **下标的重要性**：初学者容易在队列里存“数值”，但单调队列必须存“下标”，因为判断过期需要用到下标。

如果你想在这个部分加深难度，可以引入 **“单调队列优化 DP”** 的概念，但这可能超出了“配对枚举”的范畴，目前的程度对于学习“枚举和集合分类”来说已经非常完美了。

---


# 经典题目清单

这是一个非常棒的请求。为了完善你的教案，我为你整理了一份针对不同模型的**经典题目清单**。

这些题目覆盖了从基础的“哈希/桶计数”到“滑动窗口”，再到“单调队列优化”的完整路径。大部分都在 **Luogu (洛谷)** 上有镜像，方便学生提交。

---

### 1. 基础模型：数值/属性配对 (Map/桶)

这类题考察的核心是：固定一个 ，快速查 。

| 题目来源 | 题目编号 | 标题 | 考察点 | 难度 (参考) |
| --- | --- | --- | --- | --- |
| **Luogu** | **P1102** | **A-B 数对** | 。最经典的配对，完全对应你的“公式”教学。 | 普及- |
| **Luogu** | **P8649** | [蓝桥杯 2017 省 B] **k倍区间** | 前缀和 + 余数分类。转化为寻找前缀和模  相同的对数。 | 普及/提高- |
| **Codeforces** | **1520D** | **Same Differences** | 寻找  的对数。移项得 ，转化为简单的相等配对。 | 1200分 |
| **AtCoder** | **ABC 206 C** | **Swappable** | 求  的对数。正难则反，总对数减去  的对数。 | 灰/绿题 |

---

### 2. 进阶模型：余数分类 (同余性质)

这类题考察的核心是：按  分类，处理整除问题。

| 题目来源 | 题目编号 | 标题 | 考察点 | 难度 (参考) |
| --- | --- | --- | --- | --- |
| **Codeforces** | **1133B** | **Prep. for Women's Day** | 给一堆糖果，两两配对，和必须被  整除。完美的余数分类桶练习题。 | 1200分 |
| **Luogu** | **P3131** | [USACO16JAN] **Subsequences Summing to Sevens S** | 连续子段和是7的倍数。虽然是区间问题，但核心是利用前缀和模7的余数进行配对。 | 普及/提高- |
| **AtCoder** | **ABC 046 B** | **AtCoDeer and Paint Cans** | 虽然是染色，但AtCoder有很多模运算思维题，建议做 **ABC 105 B - Cakes and Donuts** (暴力/分类)。 | 简单 |

---

### 3. 进阶模型：距离/位置限制 (滑动窗口/特殊公式)

这类题考察：除了数值匹配，还有下标  的几何或距离约束。

| 题目来源 | 题目编号 | 标题 | 考察点 | 难度 (参考) |
| --- | --- | --- | --- | --- |
| **Luogu** | **P1311** | [NOIP2011] **选择客栈** | **(强烈推荐)** 你的教案里已有，这是“带条件配对”的巅峰之作，考察记录“最近的有效位置”。 | 普及/提高- |
| **Luogu** | **P2671** | [NOIP2015] **求和** | 要求下标奇偶性相同且颜色相同。多重限制下的分组求和，公式推导极佳。 | 普及/提高- |
| **Luogu** | **P1908** | **逆序对** |  且 。虽然通常用归并排序/树状数组，但理解为“左边比我大的数”也是一种配对思维。 | 普及/提高- |
| **Codeforces** | **1324D** | **Pair of Topics** | 。移项 + 排序 + 双指针/二分查找。 | 1400分 |

---

### 4. 高阶模型：单调队列 (最值配对)

这类题考察：不仅要配对，还要找最大/最小，且有范围限制。

| 题目来源 | 题目编号 | 标题 | 考察点 | 难度 (参考) |
| --- | --- | --- | --- | --- |
| **Luogu** | **P1886** | **滑动窗口 /【模板】单调队列** | 必做模板。求区间最大最小值。 | 普及/提高- |
| **Luogu** | **P1714** | **切蛋糕** | 求长度不超过  的最大连续子段和。即  其中 。经典的单调队列应用。 | 普及/提高- |
| **Luogu** | **P2629** | **Good News and Bad News** | 环形数组 + 单调队列。结合了你的“断环为链”技巧和单调队列。 | 提高+/省选- |
| **Luogu** | **P1725** | **琪露诺** | 简单的单调队列优化 DP。跳跃距离在  之间，求最大得分。 | 普及/提高- |
| **POJ** | **2823** | **Sliding Window** | 同 P1886，经典的单调队列老题。 | - |

---

### 5. 教案编写建议

在安排练习题时，建议按照以下梯度布置作业：

1. **必做题 (基础巩固)**:
* Luogu P1102 (A-B 数对) —— 练习 Map/桶思维。
* Codeforces 1133B —— 练习余数分类思维。


2. **挑战题 (思维提升)**:
* Luogu P1311 (选择客栈) —— 练习“记录有效位置”的思维。
* Luogu P2671 (求和) —— 练习复杂的公式拆解和分组。


3. **拔高题 (算法衔接)**:
* Luogu P1714 (切蛋糕) —— 从“计数”跨越到“求最值”，引入单调队列。



这样你的学生就能从单纯的 `Map` 使用者，进化为能够处理复杂几何/距离约束的算法选手。


# usaco 题目


USACO（美国计算机奥林匹克）题目通常不像国内 OJ 那样通过“模板”来分类，而是更偏向**场景化**和**Ad-hoc（针对性解法）**。

不过，USACO Silver（银组）和 Gold（金组）中充满了利用**Map、排序后双指针、前缀和模运算**来解决的“配对/计数”问题。

这里为你精选了最符合你教案逻辑的 USACO 题目：

### 1. 哈希/Map 配对模型 (对应你教案的“黑白气球”)

这类题目需要你把对象的“特征”提取出来作为 Key，存入 Map 计数。

* **题目**: **[USACO 2016 Dec Silver] Cities and States**
* **链接**: [P3138 (Luogu)](https://www.luogu.com.cn/problem/P3138) | [USACO官网](http://www.usaco.org/index.php?page=viewproblem2&cpid=667)
* **模型匹配**:
* **问题**: 给定城市名和州名，寻找互为“特殊对”的城市数量（即 A城市的缩写=B州的缩写，且 B城市的缩写=A州的缩写）。
* **解法**: 典型的 Map 计数。将字符串特征化，存入 `map<string, int>`。
* **教学价值**: 完美对应“不重不漏”的分类思想，需要处理 Key 的拼接和去重（比如来自同一个州的城市不能配对）。



### 2. 余数分类模型 (对应“同余性质”)

这是 USACO 非常经典的一类题，通常结合前缀和。

* **题目**: **[USACO 2016 Jan Silver] Subsequences Summing to Sevens**
* **链接**: [P3131 (Luogu)](https://www.luogu.com.cn/problem/P3131) | [USACO官网](http://www.usaco.org/index.php?page=viewproblem2&cpid=595)
* **模型匹配**:
* **问题**: 找一段连续子数组，其和是 7 的倍数，求最大长度。
* **解法**: 虽然它问的是长度，但核心逻辑是：**前缀和  和  模 7 同余**。
* **教学价值**: 这是讲解“余数分类”最好的例题之一。你只需要记录每个余数  **第一次出现的位置**和**最后一次出现的位置**，做差即可。


* **题目**: **[USACO 2017 Jan Silver] Hoof, Paper, Scissors** (非典型，但包含前缀和思想)
* 这也是利用前缀统计来优化  到  的经典案例。



### 3. 数值/距离窗口模型 (对应“滑动窗口/排序”)

USACO 非常喜欢考排序后的扫描（Sweep Line）或双指针。

* **题目**: **[USACO 2016 Open Silver] Diamond Collector**
* **链接**: [P3143 (Luogu)](https://www.luogu.com.cn/problem/P3143) | [USACO官网](http://www.usaco.org/index.php?page=viewproblem2&cpid=643)
* **模型匹配**:
* **问题**: 挑选两组钻石，每组内的最大值和最小值之差不能超过 。
* **解法**: 这是一个**排序 + 滑动窗口**的经典题。对于每个 （作为最小值），找最远的  使得 。
* **教学价值**: 这一步就是标准的“距离/数值限制”模型。题目还多了一步（选两组），需要结合预处理（类似前缀最大值/后缀最大值）的技巧，稍微拔高一点。


* **题目**: **[USACO 2017 Open Silver] Paired Up**
* **链接**: [P3661 (Luogu)](https://www.luogu.com.cn/problem/P3661) | [USACO官网](http://www.usaco.org/index.php?page=viewproblem2&cpid=738)
* **模型匹配**:
* **问题**: 也是配对，但是是为了让每对的和的最大值最小（贪心）。
* **解法**: 双指针（Two Pointers）。一个指头，一个指尾，向中间逼近。
* **教学价值**: 虽然不是“计数”，但它是“配对”思维的重要变体（贪心匹配）。



### 4. 单调队列/优化模型 (Gold 难度)

Silver 组较少直接考单调队列，通常出现在 Gold。

* **题目**: **[USACO 2017 Dec Gold] Haybale Feast**
* **链接**: [P4086 (类似逻辑) / USACO官网](http://www.usaco.org/index.php?page=viewproblem2&cpid=767)
* **模型匹配**:
* **问题**: 找一段区间，使得总和至少为 ，且区间内的最大“辣度”最小。
* **解法**: 双指针滑动窗口 + 单调队列（或 Multiset）维护窗口内的最大值。
* **教学价值**: 只有使用了单调队列/Set，才能在窗口滑动时快速知道当前的“最大辣度”是多少。



### 总结推荐表

如果你的学生刚学完你的教案，推荐按以下顺序刷 USACO 题：

1. **Cities and States** (Silver) -> 巩固 `Map` 和字符串处理。
2. **Subsequences Summing to Sevens** (Silver) -> 巩固余数分类。
3. **Diamond Collector** (Silver) -> 巩固排序后的滑动窗口。

这三道题非常经典，能够完美覆盖你的教学目标。