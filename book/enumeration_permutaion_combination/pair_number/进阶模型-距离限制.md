抱歉，把这个重要的模块漏掉了。这是**“距离限制类”**的教案补充。

这一类问题非常关键，它标志着算法思维从“静态统计”向“动态维护”转变。你可以把这段加在“进阶模型2”之后。

---

## 进阶模型3：距离限制 (滑动窗口)

在之前的题目中，任何之前的气球都可以和当前气球配对。但现实中往往有**距离限制**。

### 题目描述

给定一个数组，问有多少对  满足：

1.  (颜色相同)
2.  (距离不超过 )

**输入样例：**

```text
6 2
1 2 1 3 1 2

```

(, 距离限制 )

**输出样例：**

```text
2

```

**解释：**

* 下标  的 `1` 和下标  的 `1`：距离  (符合)
* 下标  的 `1` 和下标  的 `1`：距离  (符合)
* 下标  的 `1` 和下标  的 `1`：距离  (不符合，太远了)

### 解释：过期的要扔掉

如果我们还像之前一样只把数字放入桶里，桶里的数字会越来越多，包含那些距离很远的“过期”数字。

我们需要维护一个**“滑动的窗口”**：

1. **入窗**：当我们走到  时，把  加入统计。
2. **出窗**：如果窗口太大了（超过 ），就要把最左边那个“过期”的元素从桶里拿出来（计数减一）。

这个过程就像一个长度为  的框，在数组上向右滑动。

### 算法流程

当我们遍历到第  个元素时：

1. **检查过期**：计算窗口左边界。如果 ，说明下标  的元素已经失效了（距离变成了 ），需要从桶中 `cnt[a[j-K-1]]--`。
2. **统计答案**：查询桶中  现有的数量（这些肯定都是距离合法的）。
3. **加入当前**：把  放入桶中 `cnt[a[j]]++`。

### 代码实现

```cpp
int n, k;
cin >> n >> k;
vector<int> a(n);
map<int, int> cnt; // 或者用数组 int cnt[MAX_VAL]
long long ans = 0;

for(int j = 0; j < n; j++) {
    cin >> a[j];

    // 1. 核心步骤：移除过期的 (Sliding Window)
    // 当 j=k+1 时，距离 j 超过 k 的是 j-k-1 = 0 号元素
    if (j > k) {
        int expired_index = j - k - 1;
        cnt[a[expired_index]]--; 
    }

    // 2. 统计 (桶里剩下的都是距离 <= K 的)
    ans += cnt[a[j]];

    // 3. 加入当前
    cnt[a[j]]++;
}
cout << ans << endl;

```

!!! success 总结
**滑动窗口**的本质是：在枚举  的同时，维护一个**动态的桶**。
我们不仅要学会 `add` (加入集合)，还要学会 `remove` (移出集合)。
!!!


## 再次进阶: 单调队列


- P1886 【模板】单调队列 / 滑动窗口

---

### 与 NOIP 2011 选择客栈 的联系

你在练习题中提到的 **[NOIP2011 提高组] 选择客栈** 就是这个模型的升级版。

* **客栈题难点**：它不仅要求颜色相同 ()，还要求  和  之间有一个客栈的价格 。
* **转化思路**：
* 这其实是**带条件的距离限制**。
* 这里的“有效性”不是靠固定的距离 ，而是靠“中间是否有低价客栈”。
* 如果  和  之间出现了低价客栈，那么  及其左边所有同色客栈，对于未来的  都是“永不过期”的。
* 这是一个非常好的练习题，用来考察学生是否理解了“何时记录”和“何时统计”。