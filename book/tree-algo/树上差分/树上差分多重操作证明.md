这是一个非常深刻且直觉上很好的问题。很多同学在学习树上差分时，往往只是背下了公式，而忽略了“为什么多次操作叠加后依然正确”的数学本质。

简单直接的回答是：这利用了数学上的**线性（Linearity）**，具体来说是加法的**交换律（Commutativity）**和**结合律（Associativity）**，以及**求和运算的线性性质**。

也就是我们常说的：**“整体等于部分之和”**（Superposition Principle / 叠加原理）。

下面我为你提供一个严谨的证明思路，这完全符合算法竞赛中证明的风格。

---

### 1. 定义与符号

设树上有 $N$ 个节点。我们进行了 $M$ 次操作。
* **目标**：求最终每个节点 $x$ 的权值 $V_{final}(x)$。
* **操作**：第 $i$ 次操作为 $add(u_i, v_i, w_i)$。
* **单次贡献**：设第 $i$ 次操作单独发生时，对节点 $x$ 产生的增加值为 $C_i(x)$。
    * 若 $x$ 在 $u_i \to v_i$ 的路径上，$C_i(x) = w_i$。
    * 否则，$C_i(x) = 0$。

显然，经过 $M$ 次操作后，节点 $x$ 的最终真实值应该是所有操作贡献的累加：
$$V_{final}(x) = \sum_{i=1}^{M} C_i(x)$$

### 2. 差分数组的定义

我们定义差分数组 $D[u]$。
对于第 $i$ 次操作 $add(u_i, v_i, w_i)$，我们在差分数组上产生的修改记为 $\delta_i$。根据树上点差分的规则：
1.  $\delta_i(u_i) = w_i$
2.  $\delta_i(v_i) = w_i$
3.  $\delta_i(lca(u_i, v_i)) = -w_i$
4.  $\delta_i(fa(lca(u_i, v_i))) = -w_i$
5.  其他点为 $0$

经过 $M$ 次操作后，节点 $y$ 处的**总差分值** $D[y]$ 等于每次操作在该点产生的差分值之和：
$$D[y] = \sum_{i=1}^{M} \delta_i(y)$$

### 3. 还原过程（求和性质）

你提到的还原公式是：$sum(x)$ 等于 $x$ 所有子树（包括 $x$）的点的差分值之和。
即计算出的节点值 $Val(x)$ 为：
$$Val(x) = \sum_{y \in \text{subtree}(x)} D[y]$$

### 4. 证明核心：交换求和顺序

我们需要证明计算值 $Val(x)$ 等于真实值 $V_{final}(x)$。

将 $D[y]$ 的定义代入 $Val(x)$ 的公式中：

$$Val(x) = \sum_{y \in \text{subtree}(x)} \left( \sum_{i=1}^{M} \delta_i(y) \right)$$

这里出现了双重求和符号。外层是对**子树内节点**求和，内层是对**操作次数**求和。
利用**加法的交换律和结合律**，我们可以交换这两个求和符号的顺序：

$$Val(x) = \sum_{i=1}^{M} \left( \sum_{y \in \text{subtree}(x)} \delta_i(y) \right)$$

**现在让我们观察括号里面的部分：**
$$\text{Inner}_i(x) = \sum_{y \in \text{subtree}(x)} \delta_i(y)$$

这部分的含义是：**“仅考虑第 $i$ 次操作所产生的差分值，在 $x$ 子树内的总和。”**

既然你已经理解了“一次操作”的正确性，那么你就已经承认了：
对于单个操作 $i$，差分数组在子树内的求和，恰好等于该操作对 $x$ 的贡献。
即：
$$\sum_{y \in \text{subtree}(x)} \delta_i(y) = C_i(x)$$
*(如果不理解这一步，回顾：若 $x$ 在路径上，子树和为 $w$；若不在，子树和为 $0$)*

### 5. 结论

将上一步的结果代回 $Val(x)$ 的式子：

$$Val(x) = \sum_{i=1}^{M} C_i(x)$$

这与我们在第 1 步定义的真实值 $V_{final}(x)$ 完全一致。

$$Val(x) = V_{final}(x)$$

**证明完毕 (Q.E.D.)**

---

### 总结：用到的数学性质

1.  **加法的交换律与结合律 (Commutativity and Associativity of Addition)**：
    这是最核心的。它允许我们将“先把所有差分加起来再求子树和”等价于“先对每个操作求子树和（即算出每个操作的真实影响），再把这些影响加起来”。

2.  **运算的线性 (Linearity)**：
    令 $f$ 为“求子树和”的函数（即还原操作）。
    $$f(A + B) = f(A) + f(B)$$
    其中 $A$ 和 $B$ 是两次不同操作产生的差分数组。因为还原过程是线性的，所以多次操作的叠加不会互相干扰（不会出现平方项、交叉项等）。

### 还有其他疑问吗？

为了让这个知识点更牢固，你是否需要我为你写一段**C++ 的核心代码模板**（包含 LCA、差分修改、DFS 统计），以便你直接用于验证或比赛？