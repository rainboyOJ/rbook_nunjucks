## 堆的定义

堆是抽象定义的数据结构,它满足以下性质:

1. 性质:堆顶总保存着最小元素;  
2. 弹出操作移除堆顶元素,并保持堆的性质:新的堆顶元素仍是剩余中最小的;  
3. 插入操作将新元素加入堆中,并保持堆的性质;  
4. 其它操作(如合并两个堆)也保持堆的性质。

## 可以用数组表示一棵完全二叉树

例子:

```
        1
      /   \
     2     3
    / \   /
   4   5 6
```

可以用数组表示为: [1, 2, 3, 4, 5, 6]


多画几个例子,就可以发现规律:

对于任意节点 $i$

$$
\begin{cases}
\text{左孩子} = 2i \\
\text{右孩子} = 2i + 1 \\
\text{父节点} = \lfloor \frac{i}{2} \rfloor
\end{cases}
$$


好的，为了适合博客阅读，我将证明过程进行了精简和结构化，去除了冗余解释，保留核心逻辑。

以下是适合直接发布的版本：

---

### 数学归纳法证明：完全二叉树的数组表示

**命题**：完全二叉树的节点可以紧凑地映射到数组中（无空隙）。
**约定**：使用从 1 开始的索引规则。若父节点为 $i$，则左孩子为 $2i$，右孩子为 $2i+1$。

#### 1. 基础步骤 (Base Case)
当树的高度 $h=1$ 时：
树中仅有一个根节点，占用数组索引 $1$。数组连续且无空隙，命题显然成立。

#### 2. 归纳假设 (Inductive Hypothesis)
假设对于高度为 $h$ 的完全二叉树，命题成立。
即：节点占用数组索引 $1$ 到 $n$ 的连续空间。特别地，若该树为**满二叉树**，则填满 $1$ 到 $2^h - 1$。

#### 3. 归纳步骤 (Inductive Step)
考虑高度为 $h+1$ 的完全二叉树：

* **前 $h$ 层**：根据定义，前 $h$ 层必定构成一个**满二叉树**。由归纳假设，这部分节点紧凑地占用了数组索引 $1$ 到 $2^h - 1$。
* **第 $h+1$ 层**：
    1.  **衔接性**：第 $h+1$ 层最左侧节点是第 $h$ 层第一个节点（索引 $2^{h-1}$）的左孩子，其索引为 $2 \times 2^{h-1} = 2^h$。这正好紧接在前 $h$ 层最大索引 ($2^h - 1$) 之后，实现了无缝衔接。
    2.  **连续性**：根据完全二叉树定义，第 $h+1$ 层节点从左向右依次排列。由于父节点索引连续，根据 $2i$ 和 $2i+1$ 的计算规则，生成的子节点索引也必然是自然连续增长的。

**结论**：
高度为 $h+1$ 的完全二叉树，其节点索引从 $1$ 到总节点数之间没有空隙，证明成立。$\blacksquare$

---

## 二叉堆的定义

使用 **完全二叉树** 来实现堆,称为二叉堆


二叉堆的定义

由于背后的数据  模型是带有递归结构的二叉树,我们可以获得一个增强的堆性质:每棵子树的根节点  都是最小(或最大)的。即任何子树都代表一个子堆

定义:任何一个节点的值都小于等于它的左右子节点的值

性质:

堆顶总保存着最小元素;

数组实现的二叉堆

下面以小根堆来学习


## 插入

如果在数组末尾插入一个元素$x$,那么分情况讨论

1. 如果插入的元素大于父节点,那么它就可以直接插入,因为它是最小的
2. 如果插入的元素小于父节点,那么它破坏堆的性质,需要进行调整


最朴素的思想: 把$x$和父亲节点交换,为什么可以这样做呢?

```
  y
 / \
sx  x
```

显然: $sx < y$ ,$ y < x$ ,所以 $sx < y < x$ ,所以 $sx < x$ ,所以 $x$和$y$交换后,变成了一个堆,

因为是数据是递归定义,所以还可以向上调整

```
  y'
 / \
x  sx'
```

我们把这种调整 称为 **up**


```cpp
int heap[N], size;
void up(int pos) {
  while( pos > 1) {
    int fa = pos / 2;
    if (heap[pos] < heap[fa]) {
      swap(heap[pos], heap[fa]);
      pos = fa;
    } else break;
  }
}

void insert(int val) {
  heap[++size] = val;
  up(size);
}
```



## 弹出

弹出堆顶元素,然后把最后一个元素放到堆顶,然后进行调整

`fa`结点大于它的左右子节点之一,那么就需要进行调整

怎么调整呢?

分情况讨论

1. `left < right < fa`
1. `left < fa < right `
1. `right < left < fa`
1. `right < fa < left `

一共 4 种情况,简化为 2 种情况

1. `min1< min2 < fa`
1. `min1 < fa < min2`

容易想到,把`fa`和`min1`交换比较好,因为`min1`是最小的,交换后,`fa`的值变小了,那么`fa`的子树就变成了一个堆,然后递归的调整


- left,right 子树都是满足堆性质的


```cpp

void down(int pos) {
  int son = pos * 2;
  while (son <= n) { // 至少左孩子存在
    if (son + 1 <= n && heap[son + 1] < heap[son]) son++; // 找到最小的孩子
    if (heap[son] < heap[pos]) {
      swap(heap[son], heap[pos]);
      pos = son;
      son = pos * 2;
    } else break;
  }
}

void  pop() {
  heap[1] = heap[size--];
  down(1);
}

int top() {
  return heap[1];
}
```

## 删除

删除任意一个元素,然后进行调整




```
    fa
    /
   x
  / \
 y1 y2
```

1. x这个位置替换这个元素为最后一个元素后 `y1,y2,fa` 整体是满足的(如果不考虑x的值)
2. 只有可能向上调整,或者向下调整,或者不调整
3. 向上调整后,层数会减少,又变成这种模式

```cpp
void erase(int pos) {
  heap[pos] = heap[size--];
  down(pos);
  up(pos);
}
```

构造堆


堆的基本操作  堆的基本操作包括获取顶部,弹出顶部,寻找最小(或最大)的前 k 个元素,减小小  顶堆中某一元素(或增大大顶堆中某一元素),以及插入


堆排序  可以利用堆实现堆排序


## 解决的问题

在 Codeforces 等算法竞赛中，二叉堆（通常直接使用 C++ `std::priority_queue` 或 Python `heapq`）的核心作用是**动态维护集合的极值**。

它通常不是作为一道题的“全部解法”，而是作为**贪心算法、动态规划或图论算法的加速器**。

以下是二叉堆在 CP 中最常见的 5 类抽象问题模型：

---

### 1. 动态集合极值维护 (The "Rolling" Max/Min)
这是最基础的用法。当数据是**流式到达**（一边插入一边查询），且你需要时刻知道当前最大或最小的元素时。
* **抽象模型**：有一个集合 $S$，不断执行 `push(x)` 和 `query_max()`。
* **典型场景**：
    * 滑动窗口的最值问题（虽然单调队列更优，但堆也是一种解法）。
    * **带懒惰删除 (Lazy Deletion)**：如果需要支持“删除任意元素”，通常使用堆 + 一个记录“待删除元素”的哈希表/额外堆。

### 2. “反悔”贪心 (Regret Greedy / "Undo" Greedy)
**这是 Codeforces 上非常经典且高频的考点。**(还是集合)
当你按照某种贪心策略做选择时，可能会发现后面的选项比前面选的更好。此时利用堆记录“已选元素中最差的一个”，在需要时将其替换掉。
* **抽象模型**：
    1.  遍历物品，尽量选。
    2.  如果不满足条件（如容量不够），检查堆顶（已选的最差物品）。
    3.  如果当前新物品比堆顶更优，则**反悔**：扔掉堆顶，换入新物品。
* **经典例题**：
    * CF 865D (Buy Low Sell High)
    * “种树问题”或区间选点问题。

### 3. 对顶堆：动态中位数 (Dual Heaps for Dynamic Median)
利用两个堆来维护数据的顺序统计量。
* **抽象模型**：
    * **大根堆**维护较小的一半数。
    * **小根堆**维护较大的一半数。
    * 时刻保证两个堆的大小平衡。
* **解决问题**：动态求中位数，或者求“第 $K$ 大”的数。

### 4. 多路归并 (K-way Merge)
当你有 $K$ 个已经有序的序列，想要将它们合并成一个有序序列，或者求所有组合中的前 $N$ 小项。
* **抽象模型**：
    * 将 $K$ 个序列当前的头元素放入小根堆。
    * 每次弹出最小元素，并将该元素所属序列的下一个元素入堆。
* **典型场景**：
    * 求两个数组 $A, B$ 中 $a_i + b_j$ 的前 $K$ 小值。
    * Dijkstra 算法（本质上也是一种多路归并，合并从不同节点出发的路径）。

### 5. 最小合并代价 (Huffman Style)
每次操作需要消耗代价，且代价与元素大小有关，目标是最小化总代价。
* **抽象模型**：
    * 每次从集合中取出最小的两个元素 $x, y$。
    * 合并它们（代价通常是 $x+y$），将新元素放回集合。
    * 重复直到只剩一个元素。
* **典型场景**：哈夫曼编码、合并果子（经典的弱智题，但代表了一类模型）。

---

### 总结表格

| 模式 | 核心思想 | 复杂度 | 关键词 |
| :--- | :--- | :--- | :--- |
| **基础流式** | 谁最大/最小？ | $O(\log N)$ | Top K, 优先队列 |
| **反悔贪心** | **先选上，后面遇到更好的就把前面最差的踢掉** | $O(N \log N)$ | Regret, Undo, 替换 |
| **对顶堆** | 一半大，一半小，中间就是中位数 | $O(\log N)$ | 中位数, 动态第K大 |
| **多路归并** | $K$ 个有序流的竞争 | $O(N \log K)$ | Sum combinations |
| **图论优化** | 每次扩展当前代价最小的节点 | $O(E \log V)$ | Dijkstra, Prim |

### 下一步建议
如果你想练习最能体现 Codeforces 思维的堆题目，建议尝试 **“反悔贪心”** 类题目。

**Would you like me to provide a specific Codeforces problem ID and a brief hint for a "Regret Greedy" problem to practice?** (比如经典的 CF C/D 难度的题目)1. 优先队列
2. 动态维护集合的极值
3. 对顶堆：动态中位数 (Dual Heaps for Dynamic Median)
4. 动态求“第 $K$ 大”的数。
5. 最小合并代价