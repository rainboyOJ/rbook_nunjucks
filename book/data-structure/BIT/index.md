---
id: "bit"
title: "树状数组"
date: 2025-12-02 14:40
toc: true
tags: ["树状数组"]
categories: ["bit"]
code_template:
  - title: bit树状数组
    desc: "单点修改,区间查询"
    tags: ["区间信息","BIT"]
    code: /code/data-struture/BIT/bit.cpp
  - title: bit树状数组[区间修改,单点查询]
    desc: "区间修改,单点查询"
    tags: ["单点信息","BIT"]
    code: /code/data-struture/BIT/bit_区间修改_单点查询.cpp
---

[[TOC]]


# You Asked:

```
template<typename T,int N=maxn>
struct Bit {
    T c[N+5];
    //Bit(){}
    inline int lowbit(int x) { return x & -x;      }
    inline int fa(int p)     { return p+lowbit(p); }
    inline int left(int p)   { return p-lowbit(p); }

    void update(int p, T v){
        for( ; p <= N; p = fa(p) ) c[p] += v;
    }

    T query(int p){ //前缀合
        T sum=0;
        for( ;p > 0 ; p = left(p)) sum+= c[p];
        return sum;
    }
};
Bit<ll> bit;
```

如何证明(数学), p+ lowbit(p) 就是父亲

# Gemini Responded:

这是一个非常深刻且经典的问题。要理解为什么 `p + lowbit(p)` 是 `p` 的父亲（或者更准确地说是**直接覆盖 `p` 的下一个区间节点**），我们需要从**二进制表示**和**树状数组（BIT）的区间定义**两个角度来证明。

### 1. 核心定义：节点代表什么？

在树状数组中，每一个索引 `t` 不仅仅是一个下标，它代表一个**区间**。
对于任意节点 `t`，它维护的区间是：
$$[t - \text{lowbit}(t) + 1, \quad t]$$

**更新操作（Update）的本质**：
当我们更新位置 `p` 的值时，我们需要更新所有**覆盖了位置 `p`** 的节点。
也就是寻找所有满足以下条件的 $y$：
1.  $y \ge p$ （父节点索引必然大于等于子节点）
2.  $p \in [y - \text{lowbit}(y) + 1, \quad y]$ （区间包含关系）

---

### 2. 数学证明：为什么 `p + lowbit(p)` 覆盖了 `p`

我们要证明：如果令 $y = p + \text{lowbit}(p)$，那么节点 $y$ 的区间一定包含 $p$。

**步骤 A：二进制表示**
设 $p$ 的二进制表示中，最低位的 `1` 在第 $k$ 位（从0开始计数）。
那么 $p$ 可以写成：
$$p = A \cdot 2^{k+1} + 1 \cdot 2^k$$
其中 $A$ 是比第 $k$ 位更高的部分。因为 $k$ 是最低位的 1，所以第 $k$ 位右边全为 0。
此时：
$$\text{lowbit}(p) = 2^k$$

**步骤 B：执行加法**
计算 $y = p + \text{lowbit}(p)$：
$$y = (A \cdot 2^{k+1} + 2^k) + 2^k$$
$$y = A \cdot 2^{k+1} + 2 \cdot 2^k$$
$$y = A \cdot 2^{k+1} + 2^{k+1}$$
$$y = (A + 1) \cdot 2^{k+1}$$

**步骤 C：分析 $y$ 的性质**
观察 $y$ 的表达式 $(A + 1) \cdot 2^{k+1}$。这意味着 $y$ 的二进制末尾至少有 $k+1$ 个 0。
因此，$y$ 的最低位 1 的位置至少是 $k+1$。
所以我们得到一个关键不等式：
$$\text{lowbit}(y) \ge 2^{k+1}$$
而我们要记得 $\text{lowbit}(p) = 2^k$，所以：
$$\text{lowbit}(y) > \text{lowbit}(p)$$

**步骤 D：验证区间包含**
节点 $y$ 的管辖范围左边界是 $L_y = y - \text{lowbit}(y) + 1$。
我们需要证明 $L_y \le p$。

由 $y = p + \text{lowbit}(p)$ 可得：
$$y - \text{lowbit}(y) = p + \text{lowbit}(p) - \text{lowbit}(y)$$

因为 $\text{lowbit}(y) \ge 2 \cdot \text{lowbit}(p)$ (即 $2^{k+1} \ge 2 \cdot 2^k$)，
所以 $\text{lowbit}(p) - \text{lowbit}(y)$ 一定是一个**负数**。

这意味着：
$$y - \text{lowbit}(y) < p$$
所以：
$$y - \text{lowbit}(y) + 1 \le p \le y$$
**证毕**。节点 $y$ 的区间确实覆盖了位置 $p$。

---

### 3. 直观理解（二进制进位）

用一个具体的例子最容易理解。设 $N=8$。

**例子：更新位置 3**
$p = 3$ (二进制 `0011`)
$\text{lowbit}(3) = 1$ (`0001`)

**找父节点：**
$y = 3 + 1 = 4$ (二进制 `0100`)

我们来看看这就发生了什么：
1.  **节点 3** (`0011`) 的管辖长度是 `lowbit(3) = 1`。区间是 `[3, 3]`。
2.  **加法进位**：`0011 + 0001 = 0100`。末尾连续的 1 全部变成了 0，并在更高位产生了一个 1。
3.  **节点 4** (`0100`) 的管辖长度是 `lowbit(4) = 4`。区间是 `[1, 4]`。
4.  显然 `[1, 4]` 包含 `3`。

**再往上找：**
$p = 4$ (`0100`)
$\text{lowbit}(4) = 4$ (`0100`)
$y = 4 + 4 = 8$ (`1000`)
节点 8 的区间是 `[1, 8]`，显然包含节点 4 的区间 `[1, 4]`，也包含原始位置 3。



### 4. 总结

`p + lowbit(p)` 这个操作在数学上的意义是：
**找到 $p$ 作为一个子区间，被合并进的那个更大的区间的右端点。**

* **`lowbit(p)`**：代表当前节点 $p$ 管辖的区域长度。
* **`p + lowbit(p)`**：把这个长度加回去，利用二进制进位，找到了一个**更高位的、且能覆盖当前区域**的节点。

这就是为什么在 `update` 操作中，我们不断执行 `p += lowbit(p)` 就能遍历所有包含位置 $p$ 的节点（即树上的祖先）。

### 5. 下一步建议

既然你已经深入了解了 BIT 的数学原理，你是否需要我为你解释：
1.  如何利用这个性质实现 **区间修改 + 区间查询** (需要两个 BIT)？
2.  或者对比一下 **线段树 (Segment Tree)**，在什么情况下 BIT 的这种父子关系会失效或不够用？

---

# You Asked:

这个证明复杂了,有没有 简洁一点的证明

# Gemini Responded:

当然，我们可以从 **“补齐” (Completion)** 的角度给出一个极简的直觉证明。

### 核心直觉：二进制进位 = 积木合并

想象 BIT 的结构就是搭积木。
* 节点 $p$ 代表一块长度为 `lowbit(p)` 的积木。
* 这块积木放置在数轴的 $[p - \text{lowbit}(p) + 1, \quad p]$ 位置。

**证明逻辑如下：**

1.  **现状**：
    $p$ 的二进制末尾是一个 `1` 后面跟着 $k$ 个 `0`（例如 `...0100`）。
    这意味着 $p$ 目前管辖着一段长度为 $2^k$ 的区间。

2.  **目标**：
    我们要找 $p$ 的父亲。父亲必须是一个**更大的区间**，并且这个大区间要**包含** $p$ 这个小区间。

3.  **操作**：
    做加法 $p + \text{lowbit}(p)$。
    这相当于在 $p$ 的基础上，**再加一段**同样长度为 $2^k$ 的积木。

4.  **结果**：
    二进制发生进位：`...0100` + `...0000` (lowbit) $\rightarrow$ `...1000`。
    末尾的 `1` 消失了，进位到了更高位。
    
    这意味两块长度为 $2^k$ 的小积木，**合并**成了一块长度为 $2^{k+1}$ 的大积木。
    这块新的大积木的右边界就是 $p + \text{lowbit}(p)$，它自然包含了原来的 $p$。

---

### 一句话总结

**$p + \text{lowbit}(p)$ 的本质，就是把 $p$ 当前代表的 $2^k$ 区间，填满补齐，进位成 $2^{k+1}$ 的大区间。**

这个大区间（父亲）当然包含原来的小区间（儿子）。

---

# You Asked:

是不是要证明$p + \text{lowbit}(p)$ 是第一个包含p的点呢?

# Gemini Responded:

**是的，你非常敏锐，这正是问题的关键！**

证明“$y$ 包含 $p$”是不够的，因为爷爷节点也包含 $p$，祖先节点都包含 $p$。
要证明 $p + \text{lowbit}(p)$ 是树结构中的**直接父亲（Parent）**，我们必须证明它是**第一个**（最小的）包含 $p$ 且下标大于 $p$ 的节点。

换句话说，我们要证明：
**在 $p$ 和 $p + \text{lowbit}(p)$ 之间，不存在任何其他节点 $z$ 能够覆盖 $p$。**

---

### 简洁直观的证明：为什么中间的节点都“手太短”？

我们用**区间长度**来思考。

**1. 设定的场景**
* 令 $next = p + \text{lowbit}(p)$。
* 假设有一个中间点 $z$，满足 $p < z < next$。

**2. 关键推导：$z$ 的性质**
因为 $z$ 比 $p$ 大，但还没大到 $p + \text{lowbit}(p)$，这说明 $z$ 是在 $p$ 的基础上加上了一个比 $\text{lowbit}(p)$ **更小**的数。

* $p$ 的二进制末尾有 $k$ 个 0（因为 $\text{lowbit}(p) = 2^k$）。
* 既然 $z$ 只是增加了一个很小的量（$< 2^k$），那么 $z$ 的二进制变化必然发生在这些末尾的 0 里面。
* **结论**：$z$ 的末尾 0 的数量一定比 $p$ 少。也就是说：
    $$\text{lowbit}(z) < \text{lowbit}(p)$$

**3. 判定覆盖：$z$ 能否够得着 $p$？**
一个节点 $z$ 的管辖范围左边界是 $L_z = z - \text{lowbit}(z) + 1$。
如果 $z$ 要覆盖 $p$，必须满足 $L_z \le p$。

让我们来看看 $z$ 的左边界在哪里：
$$L_z = z - \text{lowbit}(z) + 1$$

因为 $z > p$，我们可以把 $z$ 写成 $p + \delta$（其中 $\delta > 0$）：
$$L_z = p + \delta - \text{lowbit}(z) + 1$$

回顾上面的结论：$\delta$ 是 $z$ 和 $p$ 的差值。由于 $z$ 是由 $p$ 的低位填充进来的，根据二进制性质，$\text{lowbit}(z)$ 其实就是 $\text{lowbit}(\delta)$（或者更小）。
在二进制加法中，增加的量 $\delta$ 和结果的 $\text{lowbit}(z)$ 满足：$\delta \ge \text{lowbit}(z)$。
*(比如 $4 \to 6$，增加2，lowbit是2；$4 \to 7$，增加3，lowbit是1)*

既然 $\delta \ge \text{lowbit}(z)$，那么：
$$L_z = p + (\delta - \text{lowbit}(z)) + 1$$
$$L_z \ge p + 0 + 1$$
$$L_z > p$$

**4. 最终结论**
因为 $L_z > p$，所以中间节点 $z$ 的管辖范围的左边界，在 $p$ 的右边。
**中间的节点 $z$ 根本覆盖不到 $p$。**

---

### 举个例子验证 (N=8)

设 $p = 4$ (`0100`)。
$\text{lowbit}(4) = 4$。
下一个目标是 $4+4=8$。

**我们来看看中间的数 5, 6, 7 是否包含 4？**

1.  **$z=5$ (`0101`)**:
    * $\text{lowbit}(5) = 1$。
    * 管辖区间：$[5, 5]$。
    * **左边界 5 > 4**，不包含。

2.  **$z=6$ (`0110`)**:
    * $\text{lowbit}(6) = 2$。
    * 管辖区间：$[5, 6]$。
    * **左边界 5 > 4**，不包含。

3.  **$z=7$ (`0111`)**:
    * $\text{lowbit}(7) = 1$。
    * 管辖区间：$[7, 7]$。
    * **左边界 7 > 4**，不包含。

**只有到了 8 (`1000`)**：
* $\text{lowbit}(8) = 8$。
* 管辖区间 $[1, 8]$。
* **左边界 1 <= 4**，包含！

### 总结
你说得对，证明不仅要是“包含”，还要是“紧邻”。
上面的推导证明了：**在 $p$ 和 $p+\text{lowbit}(p)$ 之间的所有数，因为 `lowbit` 太小（手太短），都无法向左伸长去覆盖 $p$。**
所以 $p+\text{lowbit}(p)$ 就是第一个能覆盖 $p$ 的节点（父亲）。

---


## 代码

@include-code(/code/data-struture/BIT/bit.cpp , cpp)


## 区间修改,单点查询


!!! tip 一句话算法

就是差分数组做BIT

**区间修改,单点查询,在差分数组上就是单点修改,区间查询**

!!!

@include-code(/code/data-struture/BIT/bit_区间修改_单点查询.cpp, cpp)


## 树状数组应用分类详解

树状数组 (Binary Indexed Tree, BIT) 是一种精巧的数据结构，其本质是**利用二进制的位运算特性，高效地维护序列的前缀信息**。它能在对数时间内完成单点修改和前缀查询，是解决动态区间问题的利器。本文将树状数组的应用场景系统地分为四大类别。

## 一、基础操作：单点修改与区间查询

**核心操作：** `update(i, val)`、`query(i)`  
**典型模式：** 维护一个动态序列，快速响应单点变化并查询区间累计值。

### 1.1 动态前缀和与区间和

这是树状数组最核心、最直接的应用。

- **动态前缀和**：在 $O(\log n)$ 时间内修改序列中的单个元素，并查询任意位置的前缀和。
- **动态区间和**：基于前缀和，通过 `query(r) - query(l-1)` 的方式，可以快速得到任意区间 `[l, r]` 的和。

| 应用场景 | 经典题目 | 核心思路 |
|---------|---------|---------|
| **单点更新, 区间求和** | [Luogu P3374](https://www.luogu.com.cn/problem/P3374) | `update` 修改点值，`query(r) - query(l-1)` 求区间和 |

**经典实现：**
```cpp
// 单点增加 val
void update(int p, int val) {
    for (; p <= N; p += lowbit(p)) c[p] += val;
}

// 查询 [1, p] 的前缀和
int query(int p) {
    int sum = 0;
    for (; p > 0; p -= lowbit(p)) sum += c[p];
    return sum;
}

// 查询区间 [l, r] 的和
int range_query(int l, int r) {
    return query(r) - query(l - 1);
}
```

## 二、核心技巧：差分思想

**核心思路：** 将对原数组的区间操作，转化为对差分数组的单点操作。

### 2.1 区间修改与单点查询

通过维护原数组的**差分数组**，可以巧妙地处理区间修改问题。

- **区间修改 `[l, r]`**：转化为对差分数组的两次单点修改：`diff.update(l, val)` 和 `diff.update(r + 1, -val)`。
- **单点查询 `a[i]`**：原数组的 `a[i]` 等价于差分数组的前缀和 `diff.query(i)`。

| 应用场景 | 经典题目 | 核心思路 |
|---------|---------|---------|
| **区间批量加/减** | [Luogu P3368](https://www.luogu.com.cn/problem/P3368) | 维护差分数组，区间修改 -> 两次单点修改 |

**经典实现：**
```cpp
// 差分树状数组
Bit diff_bit;

// 对原数组 [l, r] 区间增加 val
void range_add(int l, int r, int val) {
    diff_bit.update(l, val);
    diff_bit.update(r + 1, -val);
}

// 查询原数组 a[p] 的值
int point_query(int p) {
    return diff_bit.query(p);
}
```

## 三、进阶应用：值域统计

**核心思路：** 将树状数组建立在**值的范围**（值域）上，而非数组下标，用于统计频率和排名。

### 3.1 逆序对与排名查询

当处理的数据范围较大但数量不多时，通常需要先进行**离散化**。

- **逆序对统计**：从后往前遍历序列，每遇到一个数 `x`，就将其加入值域树状数组，并查询在它之前已加入的、比 `x` 小的数的个数。
- **动态查询排名**：统计动态序列中“小于等于 `k` 的数有多少个”这类问题。

| 应用场景 | 经典题目 | 核心思路 |
|---------|---------|---------|
| **逆序对统计** | [Luogu P1908](https://www.luogu.com.cn/problem/P1908) | 值域树状数组 + 离散化 |
| **动态排名** | [Luogu P3369](https://www.luogu.com.cn/problem/P3369) (平衡树模板) | 权值线段树/平衡树更优，但BIT可解部分问题 |

## 四、高级拓展：升维与变形

**核心思路：** 将一维 BIT 的思想扩展到更高维度或更复杂的数据结构上。

### 4.1 二维树状数组

将一维 BIT 扩展到二维，用于维护矩阵信息。

- **单点修改 `(x, y)`**：在两个维度上同时执行 `+= lowbit()` 循环。
- **查询子矩阵和**：利用二维前缀和的容斥原理进行查询。

| 应用场景 | 经典题目 | 核心思路 |
|---------|---------|---------|
| **二维矩阵区域和** | (模板题) | `c[x][y]` 维护矩阵，操作复杂度 $O(\log n \cdot \log m)$ |

### 4.2 树上树状数组

结合 **DFS 序**，将对树的操作转化为对序列的操作。

- **子树操作**：一棵子树在 DFS 序上对应一个**连续区间**，对子树的修改和查询可直接转化为对该区间的操作。
- **路径操作**：利用差分思想，将对 `u` 到 `v` 路径的操作，转化为对 `u`, `v`, `lca(u,v)`, `fa(lca(u,v))` 四个点的单点修改。

| 应用场景 | 经典题目 | 核心思路 |
|---------|---------|---------|
| **子树信息维护** | [Luogu P3372](https://www.luogu.com.cn/problem/P3372) (线段树模板) | DFS 序将子树问题转化为区间问题 |

## 应用分类总览

| 分类 | 核心特征 | 时间复杂度 | 适用场景 |
|-----|---------|-----------|---------|
| **基础操作** | 动态维护前缀和 | O(log N) | 单点修改、区间查询 |
| **差分技巧** | 区间修改转单点 | O(log N) | 区间修改、单点查询 |
| **值域统计** | 建立在值域上 | O(log V) (V为值域大小) | 逆序对、排名、计数 |
| **高级拓展** | 升维或结合树结构 | O(log²N) 或 O(log N) | 二维矩阵、子树/路径问题 |

## 练习建议

1. **入门模板：** [Luogu P3374](https://www.luogu.com.cn/problem/P3374) (单点修改, 区间查询)
2. **差分思想：** [Luogu P3368](https://www.luogu.com.cn/problem/P3368) (区间修改, 单点查询)
3. **值域应用：** [Luogu P1908](https://www.luogu.com.cn/problem/P1908) (逆序对)

掌握这四大分类，你就能灵活运用树状数组解决大部分相关的算法问题。

## 题目

- [[problem: luogu,P1972]]