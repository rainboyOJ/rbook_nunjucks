
## treap 树的定义


## 分裂

原树是一个bst,对原来的树,进行递归的染色,对于给定的只$V$

1. 🔵 蓝色 $val(u) \leqslant V$,的点 
2. 🔴 红色 $val(u) > V$的点

```

void split(tree u ,V){
    blue_tree = {}
    red_tree = {}
    if val(u) <= V:
        blue_tree = set_blue( u,left(u) )
        { blues ,reds} = split( right(u), V)
        blue_tree.right = blues
        red_tree = reds
    else 
        red_tree = set_right( u, right(u) )
        {blues ,reds } = split( left(u) ,V)
        u.left = reds
        blue_tree = blues
    return {blue_tree,right_tree}
}
```

容易想到合并后,还是一个堆




你的直觉非常棒！你已经抓住了 **递归（Recursion）** 和 **归纳法（Induction）** 的本质联系。

你的证明思路大方向是对的，但在第 2 步的表述上可以更严谨一些，特别是关于“谁连谁”以及“为什么性质依然保持”的逻辑。

下面我为你**润色**并**形式化**这个证明。我们将严格遵循数学归纳法的三步走（奠基、归纳假设、归纳步骤），并分情况讨论。

-----

### FHQ-Treap Split 操作正确性证明

**命题**：
对于一棵根为 `u` 的 Treap（满足 BST 和 Heap 性质），`split(u, v, x, y)` 能正确将其分裂为两棵树 `x` (所有值 $\le v$) 和 `y` (所有值 $> v$)，且分裂后的 `x` 和 `y` 依然满足 Treap 的所有性质。

#### 1\. 奠基 (Base Case)

当 `u` 为空节点 (`NULL`) 时：

  * `x` 和 `y` 均被置为 `NULL`。
  * 空树显然满足 $\le v$ 和 $> v$ 的定义，也满足 BST 和 Heap 性质。
  * **结论成立**。

#### 2\. 归纳假设 (Inductive Hypothesis)

假设对于任意规模更小（或高度更低）的子树，`split` 操作都能正确分裂并维持性质。

#### 3\. 归纳步骤 (Inductive Step)

对于当前非空节点 `u`，根据 BST 性质，`u` 的左子树 $L$ 所有值 $< u.val$，右子树 $R$ 所有值 $> u.val$。
我们需要讨论 `u.val` 和分割值 `v` 的关系：

**情况 A：`u.val <= v`** (即当前根节点属于左边这堆)

  * **操作逻辑**：

    1.  因为 `u.val <= v`，所以 `u` 及其整个左子树 $L$ 都应该属于结果树 `x`。
    2.  但 `u` 的右子树 $R$ 可能包含 $> v$ 的部分，所以我们需要递归处理 $R$。
    3.  调用 `split(R, v, x', y')`。
    4.  令 `u.r = x'`，最终结果 `x = u`, `y = y'`。

  * **证明性质保持**：

      * **值域划分 (Split Correctness)**：
          * `x` 树包含了 `u`、$L$ 以及递归回来的 `x'`。根据假设，`x'` 里所有值 $\le v$。显然 `u` 和 $L$ 也 $\le v$。所以最终的 `x` 树合法。
          * `y` 树直接等于 `y'`。根据假设，`y'` 里所有值 $> v$。所以最终的 `y` 树合法。
      * **BST 性质 (有序性)**：
          * 我们执行了 `u.r = x'`。
          * 因为 `x'` 是从原右子树 $R$ 分裂出来的，所以 `x'` 中的所有值必然大于 `u.val`。
          * 因此，把 `x'` 接在 `u` 的右边，**BST 性质未被破坏**。
      * **Heap 性质 (堆性质)**：
          * 我们执行了 `u.r = x'`。
          * 因为 `x'` 是原右子树 $R$ 的一部分（子集），而原树满足堆性质，即 `u.pri` 优于 $R$ 中任意节点的优先级。
          * 所以 `u.pri` 必然优于 `x'` 中任意节点的优先级。
          * **Heap 性质未被破坏**。

**情况 B：`u.val > v`** (即当前根节点属于右边这堆)

  * **操作逻辑**：

    1.  因为 `u.val > v`，所以 `u` 及其整个右子树 $R$ 都应该属于结果树 `y`。
    2.  但 `u` 的左子树 $L$ 可能包含 $\le v$ 的部分，递归处理 $L$。
    3.  调用 `split(L, v, x', y')`。
    4.  令 `u.l = y'`，最终结果 `x = x'`, `y = u`。

  * **证明性质保持**：

      * 与情况 A 对称（Symmetric），同理可证 BST 性质（`y'` 来自左子树，必小于 `u`）和 Heap 性质（`y'` 是左子树子集，优先级必低于 `u`）均保持。

-----

### 总结图解 (你的图示润色版)

假设 `u.val <= v` (情况 A)：

**分裂前：**

```
      u (<= v)
     /   \
    L     R (混合了 <= v 和 > v)
```

**递归分裂 R：** `split(R) -> x', y'`

  * `x'` 是 R 中小的那部分
  * `y'` 是 R 中大的那部分

**重组后：**

```
   结果树 x             结果树 y
      u                    y'
     / \
    L   x'
```

**关键点检查：**

1.  `x'` 接在 `u` 的右边，合法吗？ **合法**，因为 `x'` 来自原 `R`，肯定比 `u` 大。
2.  `u` 依然是父节点，合法吗？ **合法**，因为 `x'` 是原 `R` 的后代，优先级肯定比 `u` 低。

这个证明不仅逻辑闭环，而且解释了为什么 FHQ-Treap 不需要像 Splay 或 AVL 那样进行复杂的旋转——因为**它只切断边和重连边，且重连的方向永远符合 BST 的大小关系和 Heap 的优先级关系**。

### 简化证明

分裂正确性的证明: 分裂后得到两个$val <= V$ 和 $val>V$ 的满足treap定义的树

下面我来按**数学归纳法**的思路来进行证明split的正确性

1. 根据root进行`split`时候,分成了两个树,含有根x,一个不含有根y
    ```
      root     
      /      right 
    a        /   \
            b     c
    ```
2. 假定y的继续分割得到的两个树木x',y',且分割正确,那么x'作为x的子树同时符合,bst性质,heap性质
3. 边界,当其左右子树只一是空的时候,显然正确


### 如何split

如何使用`c++`的代码实现,把一个树分割

```cpp
template<typename T>
struct node {
  int l,r,size,fix;
  T val;
};
node tree[maxn];
```

我们使用数组作为节点的集合,使用下标来表示指向的左右孩子.

1. 一个函数要返回两个值: 使用引用参数,实现
2. 递归(数学归纳法)的证明可以分割
3. 边界条件: 空树

```cpp
/**
 * 分裂 (Split) - 按数值 v 分裂
 * 含义：将树 u 切成两棵树 x 和 y。
 * 功能: 
 *      1. 使得 x 指向 u 中所有节点值 <= v 的节点组成的树
 *      2. 使得 y 指向 u 中所有节点值 > v 的节点组成的树
 * x 树：所有节点值 <= v
 * y 树：所有节点值 > v
 * 注意：x 和 y 是通过引用传回的
 */
void split(int u,int v,int &x,int &y) {
    if( !u ) { // 边界: 如果 u 是空树，那么 x 和 y 都是空树
        x = y = 0;
        return;
    }
    if( tr[u].val <= v ) {
        x = u;
        // 剩下的问题是：u 的右子树里，可能还有 <= v 的，也可能有一部分 > v 的
        // 所以我们递归处理 u 的右子树
        split(tr[u].r,v,tr[u].r,y);
    } else {
        // 当前节点 > v，说明当前节点及其右子树都属于 y
        y = u;
        // 递归处理 u 的左子树
        split(tr[u].l,v,x,tr[u].l);
    }
    update(u);
}
```




##  合并 

最简单的合并:


我们继续沿用**数学归纳法**的框架，来证明 `merge` 操作的正确性。

`merge` 的证明其实比 `split` 更直观，因为它很像是在拉拉链。

-----

### FHQ-Treap Merge 操作正确性证明

**前置条件 (Precondition)**：
我们有两个 Treap 树 `x` 和 `y`。必须满足：**树 `x` 中所有节点的数值 $\le$ 树 `y` 中所有节点的数值**。
(这是 `merge` 能够工作的物理基础)。

**命题**：
`merge(x, y)` 能将满足前置条件的两棵树合并为一棵新的 Treap，且新树依然满足 BST 性质（中序遍历有序）和 Heap 性质（优先级合法）。

#### 1\. 奠基 (Base Case)

当 `x` 为空 或 `y` 为空时：

  * 如果 `x` 为空，返回 `y`；如果 `y` 为空，返回 `x`。
  * 显然，单独的一棵合法 Treap 依然是合法的。
  * **结论成立**。

#### 2\. 归纳假设 (Inductive Hypothesis)

假设对于任意规模更小的子树对，`merge` 操作都能正确合并并维持所有性质。

#### 3\. 归纳步骤 (Inductive Step)

我们需要决定谁做新树的**根节点**。这取决于谁的优先级 `pri` 更高（假设是大根堆）。

**情况 A：`x.pri >= y.pri`** (让 `x` 做根)

  * **操作逻辑**：

    1.  根据堆性质，`x` 的优先级最高，所以 `x` 必须作为合并后新树的根。
    2.  根据 BST 性质，`x` 的左子树 $L_x$ 保持不变（因为它本来就比 `x` 小，且肯定比 `y` 小）。
    3.  **关键点**：我们需要处理 `x` 的右子树 $R_x$ 和整棵树 `y`。
          * 已知 $R_x$ 的所有值 $> x.val$。
          * 已知 `y` 的所有值 $> x.val$ (根据前置条件)。
          * 已知 $R_x$ 的所有值 $\le$ `y` 的所有值 (这是 BST 中序遍历的传递性)。
    4.  递归调用 `merge(x.r, y)`，将结果接回 `x` 的右孩子。即 `x.r = merge(x.r, y)`。

  * **证明性质保持**：

      * **BST 性质**：
          * 新生成的右子树 `new_R` 包含了原 $R_x$ 和 `y`。
          * 这两部分都严格大于 `x.val`。
          * 因此将 `new_R` 接在 `x` 的右边，**BST 性质成立**。
      * **Heap 性质**：
          * `x.pri` 原本就大于 $R_x$ 中任何节点的 `pri`。
          * `x.pri` $\ge$ `y.pri` (当前情况的前提)。
          * 合并后的子树 `new_R` 的根节点，必然是原 $R_x$ 的根或者 `y` 的根。
          * 无论谁做 `new_R` 的根，其优先级都 $\le x.pri$。
          * **Heap 性质成立**。

**情况 B：`x.pri < y.pri`** (让 `y` 做根)

  * **操作逻辑**：

    1.  根据堆性质，`y` 的优先级更高，所以 `y` 做根。
    2.  `y` 的右子树 $R_y$ 保持不变。
    3.  我们需要合并 `x` 和 `y` 的左子树 $L_y$。
    4.  递归调用 `merge(x, y.l)`，结果接回 `y` 的左孩子。即 `y.l = merge(x, y.l)`。

  * **证明性质保持**：

      * **BST 性质**：
          * `x` 和 $L_y$ 都严格小于 `y.val`。
          * 合并结果接在 `y` 左边，**BST 性质成立**。
      * **Heap 性质**：
          * `y.pri` 大于 $L_y$ 的优先级，也大于 `x.pri`。
          * 所以 `y` 大于新左子树的根。**Heap 性质成立**。

-----

### 总结图解

假设 `x.pri > y.pri` (情况 A)：

**合并前：**

```
     x (pri=100)           y (pri=80)
    /  \                  /  \
   Lx   Rx (val < y)     Ly   Ry
```

**递归决策：**
`x` 当老大。保留 `Lx`。
问题变成了：**把 `Rx` 和 `y` 合并**。

```
       x
     /   \
   Lx   merge(Rx, y)  <-- 递归解决这里
```

**性质检查：**

1.  **数值大小**：`Rx` 和 `y` 都比 `x` 大，放右边没毛病。
2.  **优先级**：`x` (100) 比 `Rx` 的根大，也比 `y` (80) 大。所以不管 `merge(Rx, y)` 返回谁当根，`x` 都能镇得住它。

通过归纳法，这证明了只要子问题 `merge` 是对的，当前层的 `merge` 也就是对的。


**让合并后尽量平衡**

右右为右

1. 作为一个集合,即满足堆,又满足BST
边界显然是其中一个树是空.


## 问题抽象

恭喜你！掌握 **Treap**（特别是 **FHQ-Treap**，也叫无旋 Treap）是你算法竞赛生涯中的一个重要里程碑。

Treap 本质上是将 **BST（二叉搜索树）的性质** 与 **Heap（堆）的随机优先级** 结合，利用随机化来保证树的期望深度为 $O(\log n)$，从而避免退化。

在 Codeforces 等竞技编程平台中，FHQ-Treap 因其**代码短、易调试、功能极其强大（甚至能替代 Splay 和线段树）**而备受推崇。

以下我为你抽象出的三大**核心问题模型**，只要题目涉及这些特征，你就可以考虑使用 FHQ-Treap。

---

## 模型一：动态有序集合 (普通平衡树)

这是 Treap 最基础的形态。当你需要维护一个**数值集合**，且操作涉及数值的大小关系时使用。

* **核心特征：** 树中的节点是根据**“数值大小”**（Key）进行排序的。
* **解决的问题：**
    1.  **动态插入/删除：** 随时加入或移除一个数。
    2.  **排名查询 (Rank)：** 询问 $x$ 是第几小的数。
    3.  **第 K 大/小查询 (K-th)：** 询问排名为 $k$ 的数是多少。
    4.  **前驱/后继 (Pre/Suc)：** 找比 $x$ 小的最大数，或比 $x$ 大的最小数。

> **抽象视角：** 把它看作一个**“支持动态修改的 `std::set` 或 `std::multiset`，但支持索引访问”**。

---

## 模型二：动态序列维护 (文艺平衡树)

这是 **FHQ-Treap** 最强大的领域，也是它优于普通 Treap 和线段树的地方。

* **核心特征：** 树中的节点**不再按数值排序**，而是按**“在序列中的位置（下标）”**排序。这通常是通过维护子树大小 `size` 来实现的（中序遍历即为当前序列）。
* **解决的问题：**
    1.  **区间翻转：** 将序列区间 $[L, R]$ 进行翻转（如 Codeforces 常见题型）。
    2.  **区间移动/交换：** 将区间 $[L, R]$ 剪切下来，粘贴到序列的另一个位置。
    3.  **任意位置插入/删除：** 在数组的第 $k$ 个位置后面插入一段数字，或者删除一段。
    4.  **区间覆盖/加法：** 类似线段树的 Lazy Tag 操作。

> **抽象视角：** 把它看作一个**“超级数组” (Super Array)**。你可以像玩拼图一样，随意把数组切开 (`Split`)，交换位置，再拼回去 (`Merge`)，且时间复杂度依然是 $O(\log n)$。
>
> **注意：** 这种模型下，FHQ-Treap 可以完全替代 **Splay**，且代码更短。

---

## 模型三：可持久化与树套树 (高级模型)

虽然普通线段树也可以做可持久化，但 FHQ-Treap 的**函数式编程特性**（依靠 `Split` 和 `Merge` 的复制节点）让它在处理某些特定问题时非常自然。

* **核心特征：** 每次修改不破坏原树，而是生成新节点，保留历史版本。
* **解决的问题：**
    1.  **历史版本查询：** 查询第 $t$ 次操作时的数组状态。
    2.  **区间第 K 大（可持久化权值树）：** 类似主席树的功能。
    3.  **树套树的替代：** 有时可以用 Treap 维护外层或内层结构来解决多维偏序问题。

---

## FHQ-Treap 的“核武器”：Split 和 Merge

理解 FHQ-Treap 的关键在于将所有操作抽象为两个原子操作。你在解题时，只需要思考如何通过这两个操作组合出你要的功能：

1.  **Split (分裂)：**
    * *按值分裂 (Value Split)：* 把树分成 $\le val$ 和 $> val$ 两部分（用于模型一）。
    * *按排名分裂 (Rank/Size Split)：* 把树分成前 $k$ 个和剩下的部分（用于模型二）。

2.  **Merge (合并)：**
    * 将两棵 Treap 合并成一棵（前提：左树的所有 Key $\le$ 右树的所有 Key，或者在序列中左树在右树前面）。

**解题思维导图：**
* 题目需要维护顺序吗？ $\rightarrow$ **模型二 (按 Size 分裂)**
    * *例子：* "Reverse the substring from $l$ to $r$" $\rightarrow$ Split 出 $[1, l-1]$，$[l, r]$，$[r+1, n]$ $\rightarrow$ 给中间打翻转标记 $\rightarrow$ Merge 回去。
* 题目只关心数值大小吗？ $\rightarrow$ **模型一 (按 Value 分裂)**
    * *例子：* "Insert $x$" $\rightarrow$ Split 成 $\le x$ 和 $> x$ $\rightarrow$ 新建节点 $x$ $\rightarrow$ Merge 左、中、右。

---

### 总结表

| 场景 | 对应模型 | 维护方式 (Key) | 核心操作 | CF 典型 Tag |
| :--- | :--- | :--- | :--- | :--- |
| **名次树** | 模型一 | 数值大小 | 按值 Split | `data structures`, `binary search` |
| **区间操作** | 模型二 | 序列下标 (隐式) | 按 Size Split | `constructive algorithms`, `strings` (有时) |
| **历史版本** | 模型三 | 数值/下标 | 复制节点的 Split | `persistent` |

---

### 下一步建议

既然你已经学会了算法，现在的重点是**将“思维”对应到“代码模板”**。

**你要不要我给你出一道 Codeforces 上经典的 FHQ-Treap 题目（例如“区间翻转”或“普通平衡树”的变体），并带你分析一下如何用 Split/Merge 拼装出解法？**


## 区间翻转

这是一个非常经典的需求。在算法竞赛界，这道题通常被称为 **“文艺平衡树”**。

它完美对应了我刚才总结的 **模型二：动态序列维护**。

这里没有复杂的数值比较，核心在于\*\*“把平衡树当数组用”\*\*，利用 FHQ-Treap 的分裂（Split）和合并（Merge）来像玩拼图一样操作区间。

-----

### 题目原型：区间翻转 (Interval Reversal)

**题目描述：**
你需要维护一个序列，初始为 $\{1, 2, 3, \dots, n\}$。
接下来进行 $m$ 次操作，每次操作给定一个区间 $[l, r]$，你需要将序列中该位置区间的数字进行**翻转**。
最后输出操作完毕后的序列。

**示例：**

  * 初始：`1 2 3 4 5`
  * 操作 `[2, 4]` (翻转第2到第4个数)
  * 结果：`1 4 3 2 5`

-----

### 核心解析：为什么是用 FHQ-Treap？

如果你用普通数组，翻转一次是 $O(n)$，总复杂度 $O(mn)$，会超时。我们需要 $O(\log n)$。

#### 1\. 树的形态含义 (关键！)

在 FHQ-Treap 中，节点的 `val`（数值）在这个模型里**不参与排序**（或者说初始 `val` 只是它的“身份 ID”）。
**树的中序遍历（左-根-右）结果，就是当前的数组序列。**

  * 如果根节点的左子树大小为 3，说明根节点代表当前序列的第 4 个数。
  * 我们要维护的核心属性是 `size`（子树大小）。

#### 2\. 怎么选中区间 $[l, r]$？ (Split 的妙用)

不同于普通 Treap 按数值分裂，这里我们**按排名（子树大小）分裂**。

要把区间 $[l, r]$ 拿出来，我们只需要做两次分裂（Split）：

1.  **第一刀：** 把树分成“前 $l-1$ 个数” (树 $X$) 和 “剩下的数” (树 $Y$)。
      * `split(root, l - 1, x, y)`
2.  **第二刀：** 把剩下的树 $Y$ 分成 “前 $r - l + 1$ 个数” (树 $T$) 和 “最后的数” (树 $Z$)。
      * `split(y, r - l + 1, T, z)`

此时：

  * 树 $X$ = 区间 $[1, l-1]$
  * **树 $T$ = 区间 $[l, r]$ （这就是我们要操作的目标！）**
  * 树 $Z$ = 区间 $[r+1, n]$

#### 3\. 怎么翻转？ (Lazy Tag)

拿到树 $T$ 后，怎么翻转它代表的序列？
**性质：** 在二叉树中，交换一个节点的左右子树，等于交换了它所代表序列的前后两部分。如果递归交换所有子节点的左右子树，整个序列就被翻转了。

但我们不能真递归（太慢）。我们打个标记 `reverse_tag`：

1.  给树 $T$ 的根节点打上 `rev` 标记。
2.  交换树 $T$ 根节点的左右儿子。
3.  **完事。**

#### 4\. 怎么放回去？ (Merge)

操作完后，把三部分拼回去：
`root = merge(merge(x, T), z)`

-----

### 关键代码逻辑 (C++)

这是 FHQ-Treap 处理区间翻转最核心的三个部分：`PushDown`, `Split (by rank)`, 和 `Main Loop`。

#### 1\. 懒标记下传 (PushDown)

这是最容易写错的地方。每次访问节点（Split 或 Merge 到了该节点）之前，都要先把标记下传。

```cpp
void push_down(int p) {
    if (tree[p].lazy_rev) {
        // 交换左右儿子
        swap(tree[p].l, tree[p].r);
        
        // 标记下传给儿子
        if (tree[p].l) tree[tree[p].l].lazy_rev ^= 1;
        if (tree[p].r) tree[tree[p].r].lazy_rev ^= 1;
        
        // 清除当前标记
        tree[p].lazy_rev = 0;
    }
}
```

#### 2\. 按排名分裂 (Split by Rank/Size)

注意 `k` 是我们要切出来的左树的大小。

```cpp
// u: 当前节点, k: 需要的排名(前k个)
// x: 分裂出的左树根引用, y: 分裂出的右树根引用
void split(int u, int k, int &x, int &y) {
    if (!u) {
        x = y = 0;
        return;
    }
    push_down(u); // 重要！进入节点前先推标记
    
    int left_size = tree[tree[u].l].size + 1; // 左子树大小 + 根自己
    
    if (left_size <= k) {
        // 根节点和左子树都属于“前k个”，归入 x
        x = u;
        split(tree[u].r, k - left_size, tree[u].r, y); // 继续去右边找剩下的
    } else {
        // 根节点属于“后半部分”，归入 y
        y = u;
        split(tree[u].l, k, x, tree[u].l); // 继续去左边找
    }
    push_up(u); // 维护 size
}
```

#### 3\. 主逻辑 (Main)

```cpp
// 1. 建树 (通常可以用 merge 线性或者建一个笛卡尔树，这里假设通过 merge 依次插入了 1..n)
for (int i = 1; i <= n; i++) root = merge(root, new_node(i));

// 2. 处理 m 次翻转
while (m--) {
    int l, r;
    cin >> l >> r;
    
    int x, y, z;
    // 第一刀：切出 [1, l-1] 存入 x，剩下 [l, n] 存入 y
    split(root, l - 1, x, y);
    
    // 第二刀：从 y 中切出长度为 r-l+1 的区间 [l, r] 存入 target，剩下 [r+1, n] 存入 z
    int target;
    split(y, r - l + 1, target, z);
    
    // 操作：给 target 打上翻转标记
    tree[target].lazy_rev ^= 1; 
    
    // 合并：顺序必须是 x -> target -> z
    root = merge(merge(x, target), z);
}

// 3. 输出 (中序遍历)
inorder_output(root);
```

-----

### 总结与抽象

这个模型（区间翻转）是 FHQ-Treap 的高光时刻。

1.  **抽象模型：** 任何涉及 **“区间位移”、“区间翻转”、“区间剪切粘贴”** 的题目，本质上都是 **Split (切蛋糕) $\rightarrow$ Tag/Modify (加奶油/换位置) $\rightarrow$ Merge (拼回去)**。
2.  **与线段树的区别：** 线段树处理区间只能改值，不能改变区间的**拓扑结构**（比如你不能轻易把线段树的 $[1,3]$ 移到 $[5,7]$ 的后面）。而 FHQ-Treap 可以轻易做到，因为它的结构是动态的。
3.  **Codeforces 实战：** 如果题目中出现 "Reverse subarray", "Move subarray to end", "Cyclic shift" 等字眼，且数据范围 $N, M \le 10^5$，直接上 FHQ-Treap。

### 既然你已经理解了这个模型

**你想不想试着用这个逻辑解决一个稍微复杂一点的变种？**
比如：不仅仅是翻转，还要**求区间最小值**（区间翻转 + RMQ），或者**区间循环右移**？我可以给你相应的操作思路。

这是一份完整的、可以直接用于 Codeforces 的 FHQ-Treap 模板代码。

这份代码整合了你要求的三个功能：

1.  **区间翻转 (Reverse)**
2.  **区间最小值 (RMQ)**
3.  **区间循环右移 (Cyclic Shift)**

为了方便阅读和使用，我将其封装在一个命名空间或全局结构中，并附带了详细注释。

### C++ 代码模板 (FHQ-Treap)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200005;
const int INF = 1e9 + 7;

// FHQ-Treap 核心结构
struct Node {
    int l, r;       // 左右子节点在数组中的下标
    int size;       // 子树大小
    int rnd;        // 随机优先级 (用于维持平衡)
    int val;        // 节点实际存储的值
    int min_val;    // 子树内的最小值 (维护属性)
    bool lazy_rev;  // 翻转懒标记
} tr[MAXN];

int root = 0;       // 根节点
int idx = 0;        // 节点池计数器

// --- 基础辅助函数 ---

// 创建新节点
int new_node(int v) {
    idx++;
    tr[idx].l = tr[idx].r = 0;
    tr[idx].size = 1;
    tr[idx].rnd = rand(); // 或者使用 mt19937
    tr[idx].val = v;
    tr[idx].min_val = v;
    tr[idx].lazy_rev = false;
    return idx;
}

// 向上更新信息 (Push Up)
void push_up(int u) {
    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
    
    // 更新最小值：取自己、左儿子、右儿子的最小值
    tr[u].min_val = tr[u].val;
    if (tr[u].l) tr[u].min_val = min(tr[u].min_val, tr[tr[u].l].min_val);
    if (tr[u].r) tr[u].min_val = min(tr[u].min_val, tr[tr[u].r].min_val);
}

// 向下传递标记 (Push Down)
void push_down(int u) {
    if (tr[u].lazy_rev) {
        // 交换左右儿子
        swap(tr[u].l, tr[u].r);
        
        // 标记传递给子节点
        if (tr[u].l) tr[tr[u].l].lazy_rev ^= 1;
        if (tr[u].r) tr[tr[u].r].lazy_rev ^= 1;
        
        // 清除当前标记
        tr[u].lazy_rev = false;
    }
}

// --- 核心操作 Split & Merge ---

// 按排名(size)分裂
// u: 当前节点
// k: 左树需要的节点数量
// x, y: 分裂后的左树根和右树根 (引用返回)
void split(int u, int k, int &x, int &y) {
    if (!u) {
        x = y = 0;
        return;
    }
    push_down(u); // 凡是即将访问子节点，必须先 push_down
    
    int left_size = tr[tr[u].l].size + 1; // 左子树 + 根
    if (left_size <= k) {
        x = u;
        split(tr[u].r, k - left_size, tr[u].r, y);
    } else {
        y = u;
        split(tr[u].l, k, x, tr[u].l);
    }
    push_up(u); // 结构改变后，必须 push_up
}

// 合并
int merge(int x, int y) {
    if (!x || !y) return x + y;
    
    // 只有 rnd 优先级高的在上，维护堆性质
    if (tr[x].rnd < tr[y].rnd) {
        push_down(x); // 访问 x 的子节点前 push_down
        tr[x].r = merge(tr[x].r, y);
        push_up(x);
        return x;
    } else {
        push_down(y); // 访问 y 的子节点前 push_down
        tr[y].l = merge(x, tr[y].l);
        push_up(y);
        return y;
    }
}

// --- 功能实现 ---

// 1. 区间翻转 [l, r]
void reverse_range(int l, int r) {
    int x, y, z;
    // 提取区间 [l, r] 到 y
    split(root, l - 1, x, y);       // y 包含 [l, n]
    split(y, r - l + 1, y, z);      // y 包含 [l, r], z 包含 [r+1, n]
    
    // 打标记
    tr[y].lazy_rev ^= 1;
    
    // 合并回去
    root = merge(merge(x, y), z);
}

// 2. 区间最小值查询 [l, r]
int query_min(int l, int r) {
    int x, y, z;
    // 提取区间 [l, r] 到 y
    split(root, l - 1, x, y);
    split(y, r - l + 1, y, z);
    
    // 获取答案
    int ans = tr[y].min_val;
    
    // 合并回去 (必须复原!)
    root = merge(merge(x, y), z);
    return ans;
}

// 3. 区间循环右移 [l, r] 移动 k 位
void cyclic_shift(int l, int r, int k) {
    int len = r - l + 1;
    k %= len; // 防止 k 超过区间长度
    if (k == 0) return;

    int x, y, z;
    split(root, l - 1, x, y);       // x: [1, l-1]
    split(y, len, y, z);            // y: [l, r], z: [r+1, n]
    
    // 将 y 切割成前 (len-k) 和 后 k
    int left_part, right_part;
    split(y, len - k, left_part, right_part);
    
    // 交换顺序合并: right_part 放前面
    y = merge(right_part, left_part);
    
    // 整体合并
    root = merge(merge(x, y), z);
}

// --- 调试与构建 ---

// 中序遍历输出当前序列 (用于 Debug)
void print_tree(int u) {
    if (!u) return;
    push_down(u); // 遍历时也要下放标记
    print_tree(tr[u].l);
    cout << tr[u].val << " ";
    print_tree(tr[u].r);
}

int main() {
    srand(time(0)); // 随机种子
    
    // 示例：初始化序列 1, 2, 3, 4, 5
    int n = 5;
    for (int i = 1; i <= n; i++) {
        root = merge(root, new_node(i));
    }
    
    cout << "初始序列: ";
    print_tree(root); cout << endl;

    // 测试 1: 翻转区间 [2, 4] -> 1 4 3 2 5
    reverse_range(2, 4);
    cout << "翻转 [2,4]: ";
    print_tree(root); cout << endl;
    
    // 测试 2: 查询区间 [2, 4] 最小值 -> min(4, 3, 2) = 2
    cout << "查询 [2,4] 最小值: " << query_min(2, 4) << endl;

    // 测试 3: 区间循环右移 [1, 5] 移 2 位 -> 2 5 1 4 3
    // 当前序列是 1 4 3 2 5
    // 右移2位: 后两个(2, 5) 跑到最前面 -> 2 5 1 4 3
    cyclic_shift(1, 5, 2);
    cout << "整体右移 2 位: ";
    print_tree(root); cout << endl;

    return 0;
}
```

### 使用指南与避坑 (Tips)

1.  **Split 的顺序**:

      * 如果你要切出区间 $[l, r]$。
      * 第一刀 `split(root, l - 1, x, y)`：把 $x$ 变成前缀。
      * 第二刀 `split(y, r - l + 1, y, z)`：从剩下的部分切出长度为 $len$ 的段。
      * **切记不要弄反变量名**，建议统一变量名风格 (比如 `x` 永远是左边, `z` 永远是右边, `y` 或 `target` 是中间)。

2.  **PushDown 的位置**:

      * **必须写在**：`split` 的开头，`merge` 的开头（或者访问子节点前），以及输出/遍历函数的开头。
      * **常见 Bug**：忘了在 `merge` 里面写 `push_down`，导致标记在树形结构改变后滞留在错误的地方。

3.  **PushUp 的位置**:

      * **必须写在**：`split` 结束前（递归回来后），`merge` 结束前。
      * 主要用于维护 `size` 和 `min_val`。

4.  **随机种子**:

      * 在 Codeforces 上，可以使用 `mt19937` 配合 `uniform_int_distribution` 来生成更强的随机数，防止针对性数据把你的 Treap 卡成链（虽然 FHQ-Treap 被卡的概率很低）。
      * 简单写法 `tr[idx].rnd = rand()` 在大多数情况下足够。

这套代码你可以保存为 `Snippet`，遇到这类题目直接把 `reverse_range` 或 `cyclic_shift` 部分粘贴进去即可。祝 AC！


