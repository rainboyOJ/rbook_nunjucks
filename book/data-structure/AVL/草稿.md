
1. 平衡因子
2. AVL树的高度为 $O(\lg n)$,保证了平衡性
  

在每个非空节点保存平衡因子

```c++

struct Node {
  Node * left;
  Node * right;
  int val;
  int δ; // 平衡因子 |r| - |l|
}
```


插入元素 x 后,包含它的子树高度最多增加  1。我们需要沿着插入路径递归地更新平衡因子

插入后得到$(Tree, \delta H)$

```
```

## 一串数学计算

1. 原来是符合AVL的定义
1. 插入一个新的节点后可能会 失衡
2. 对于插入操作：只要做了一次旋转，整棵树就恢复了平衡，回溯过程可以立即停止。


只要观察插入后新的树$\delta'$,原来树$\delta$ ,就可以得到$\Delta H$


## 平衡调整

朴素思想


## 一颗AVL树,插入一个新的节点后,会出现几种情况 ?

分类讨论

对于**任意*一个节点来说，插入一个新的节点后，会出现3种:

1. 变得更平衡了
2. 变得有点偏，但还在允许范围内
3. 彻底失衡 +2,-2

彻底失衡的情况

### 🔄 微观视角：失衡时的 4 种具体情况

如果发生了上述第 3 种情况（失衡），我们需要根据**“新节点插在哪里”**来决定用哪种旋转。

假设 **A** 是最低的失衡节点（BF 变成 ±2 的那个）：

#### 1. LL 型 (Left-Left Case)
* **描述：** 插入发生在 A 的**左孩子**的**左子树**中。
* **特征：** A 的 BF 变为 `+2`，A 的左孩子(B) BF 为 `+1`。
* **对策：** 对 A 进行 **右旋 (Right Rotation)**。

#### 2. RR 型 (Right-Right Case)
* **描述：** 插入发生在 A 的**右孩子**的**右子树**中。
* **特征：** A 的 BF 变为 `-2`，A 的右孩子(B) BF 为 `-1`。
* **对策：** 对 A 进行 **左旋 (Left Rotation)**。

#### 3. LR 型 (Left-Right Case)
* **描述：** 插入发生在 A 的**左孩子**的**右子树**中。
* **特征：** A 的 BF 变为 `+2`，A 的左孩子(B) BF 为 `-1`（呈现一种 `<` 形状的弯曲）。
* **对策：** 先对左孩子 B 进行**左旋**，再对 A 进行**右旋**（双旋）。

#### 4. RL 型 (Right-Left Case)
* **描述：** 插入发生在 A 的**右孩子**的**左子树**中。
* **特征：** A 的 BF 变为 `-2`，A 的右孩子(B) BF 为 `+1`（呈现一种 `>` 形状的弯曲）。
* **对策：** 先对右孩子 B 进行**右旋**，再对 A 进行**左旋**（双旋）。

---

### ⚡️ 总结表 (Cheat Sheet)

你在写代码或做题时，只需要判断以下逻辑：

| 原 BF (old) | 变化 | 新 BF (new) | 状态 | 动作 |
| :--- | :--- | :--- | :--- | :--- |
| `±1` | 插在矮的一边 | **0** | **平衡完美** | **停止 (Break)**，不用向上找了 |
| `0` | 插在任意一边 | **±1** | **高度增加** | **继续 (Continue)**，向上找父节点 |
| `±1` | 插在高的一边 | **±2** | **失衡** | **旋转 (Rotate)**，然后**停止 (Break)** |

AVL 树的删除操作比插入操作要**复杂**一些。

最关键的区别在于：插入操作最多只需要 1 次旋转就能修复平衡；而删除操作可能会引起**连锁反应**，导致从删除点一直到根节点的路径上发生**多次旋转**（最坏情况 $O(\log n)$ 次）。

同样地，我们从**宏观**（祖先节点的状态变化）和**微观**（旋转类型）两个角度来分析。

---

## 一颗AVL树,删除一个节点后,会出现几种情况 ?

### 🔍 宏观视角：祖先节点的状态变化

假设我们删除了一个节点，现在正在回溯更新某个祖先节点 `N`。根据 `N` 原本的 BF 和删除发生的方位，会出现以下 3 种情况：

#### 1. 变得更平衡了，但树变矮了 (Case: Continue)
* **现象：** 节点 `N` 原本 BF 为 `+1` 或 `-1`，我们删除了**较高**那一侧的一个节点。
* **结果：** `N` 的 BF 变为 `0`。
* **后果：** 这是一个**危险**的信号。虽然 `N` 自己平衡了，但 `N` 这棵子树的**高度降低了 1**。
* **下一步：** 因为高度变了，`N` 的父节点可能会因此失衡。所以必须**继续向上**回溯更新。
    *(注意：这与插入操作刚好相反。在插入时，变 0 意味着高度不变，停止；在删除时，变 0 意味着高度减小，继续。)*

#### 2. 变得稍微偏了，但树高度不变 (Case: Stop)
* **现象：** 节点 `N` 原本 BF 为 `0`，我们删除了任意一侧的一个节点。
* **结果：** `N` 的 BF 变为 `+1` 或 `-1`。
* **后果：** `N` 变得一边高一边低，但 `N` 这棵子树的总高度**没有改变**（原本左右一样高，现在一边矮了，总高度还是由没变的那一边决定）。
* **下一步：**既然高度没变，`N` 的父节点就不会受影响。**停止 (Break)** 回溯，算法结束。

#### 3. 彻底失衡 (Case: Rotate)
* **现象：** 节点 `N` 原本 BF 为 `+1` 或 `-1`，我们删除了**较矮**那一侧的一个节点（导致高的一侧显得更高了）。
* **结果：** `N` 的 BF 变为 `+2` 或 `-2`。
* **动作：** 必须进行**旋转**修复。
* **后果 (复杂点)：** 旋转后，我们需要检查新子树根节点的高度：
    * **情况 A：** 如果旋转后，子树高度**降低了** -> **继续向上 (Continue)**。
    * **情况 B：** 如果旋转后，子树高度**保持不变** -> **停止 (Break)**。

---

### 🔄 微观视角：失衡时的具体旋转 (有一个特殊情况)

当节点 `A` 失衡（比如左边太高，BF=+2）时，我们需要看 `A` 的**高个子孩子** `B`（左孩子）的状态。

在删除操作中，除了标准的 LL、LR 情况外，多了一种**“BF=0”**的特殊情况：

1.  **LL 型 (同插入):**
    * `B` 的 BF 为 `+1`。
    * **操作：** 单次右旋。
    * **结果：** 旋转后高度降低 -> **继续向上回溯**。

2.  **LR 型 (同插入):**
    * `B` 的 BF 为 `-1`。
    * **操作：** 先左旋后右旋 (双旋)。
    * **结果：** 旋转后高度降低 -> **继续向上回溯**。

3.  **特殊情况 (仅删除存在):**
    * `B` 的 BF 为 `0` (这意味着 B 的左右子树一样高)。
    * 这只可能发生在删除操作中（插入操作不可能让 B 的 BF 为 0 时 A 却失衡）。
    * **操作：** 执行**单次旋转**（和 LL 一样，右旋）。
    * **结果：** 旋转后的图形中，新根 `B` 的 BF 会变成 `-1`，原根 `A` 的 BF 变成 `+1`。
    * **关键点：** 这种旋转**不会降低树的高度**。因此，处理完这种情况后，可以**停止回溯 (Stop)**。

---

### ⚡️ 总结表 (Cheat Sheet) - 删除版

对比插入操作，请仔细看“动作”一栏的区别：

| 原 BF (old) | 动作 | 新 BF (new) | 高度变化 | 下一步 (Action) |
| :--- | :--- | :--- | :--- | :--- |
| `0` | 删了一边 | **±1** | **不变** | **停止 (Stop)** ✅ |
| `±1` | 删了高边 | **0** | **变矮 ⬇** | **继续向上 (Continue)** ⚠️ |
| `±1` | 删了矮边 | **±2** | **失衡** | **旋转 (Rotate)** 🔄 |

**旋转后的下一步：**
* 如果旋转类型是“特殊情况”（孩子 BF=0）：高度不变 -> **停止**。
* 如果是其他旋转（LL/RR/LR/RL）：高度变矮 -> **继续向上**。

### 一句话概括

AVL 树的删除操作就像**“拆积木”**，拆掉一块可能会导致整座塔的高度降低，这个高度降低的信息可能会一路向上传递，甚至导致从底到顶的每一个节点都需要做一次旋转来重新平衡。

