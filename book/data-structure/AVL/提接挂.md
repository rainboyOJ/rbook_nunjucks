
一个rotate 实现 rotateleft and rotateRight
```cpp
// pushup 维护 size 
void pushup(int u) {
    sz[u] = 1 + sz[ch[u][0]] + sz[ch[u][1]];
}

// 这里的 &u 非常关键，它代表“父节点指向 u 的那个指针/下标”
void rotate(int &u, int d) {
    int k = ch[u][d];      // 1. 抓住想要提上来的儿子 k
    ch[u][d] = ch[k][d^1]; // 2. 把 k 的内侧儿子过继给 u
    ch[k][d^1] = u;        // 3. 把 u 变成 k 的内侧儿子
    pushup(u);             // 4. 先更新旧爹 u
    pushup(k);             // 5. 再更新新爹 k
    u = k;                 // 6. 修改“钩子”，现在的根是 k 了
}
```

## 解释

是的，**这三行代码就是灵魂**。

你只需要记住一个核心概念：**“过继” (Adoption)**。

为了让你彻底不用死记硬背，我画了一张通用的\*\*“三角形旋转图”\*\*。只要脑子里有这个三角形，这三行代码就是自然流露的。

-----

### 视觉记忆图示：三角形法则

假设我们要进行 **右旋**（即 `d=0`，把左儿子 `K` 提起来）。

#### 1\. 初始状态 (Before)

请看这三个节点的关系：

  * **U (User/Up)**: 当前的根节点。
  * **K (King/Kid)**: `U` 的儿子（方向 `d`），我们要把它提起来当新王。
  * **M (Middle)**: `K` 的**内侧**儿子（方向 `d^1`）。它是最关键的“过继者”。

<!-- end list -->

```text
      U
     / \
(d) K   ...
   / \
 ...  M (d^1)
```

**重点看 M**：
在数值上，**K \< M \< U**。
所以 M 既可以在 K 的右边，也可以在 U 的左边。这就是旋转的物理基础。

-----

### 2\. 三步拆解图示 (Step-by-Step)

现在对应那三行代码，看图的变化：

#### 第一行：锁定主角

`int k = ch[u][d];`

> **心法**：先抓住未来的新王 `K`。

```text
      U  <-- 此时 u 指向这里
     /
    K    <-- 记住了 k
   / \
 ...  M
```

#### 第二行：过继 (最关键的一步)

`ch[u][d] = ch[k][d^1];`

> **心法**：`U` 的手（`d`方向）空出来了（因为 `K` 要上位），所以 `U` 伸手去接管 `K` 的内侧孩子 `M`。
> **结果**：`M` 被过继给了 `U`。

```text
      U
     / 
    M    <-- M 变成了 U 的儿子(d)
         
    K    <-- K 现在的一只手(d^1)空了
   / 
 ...
```

#### 第三行：上位

`ch[k][d^1] = u;`

> **心法**：`K` 的内侧手（`d^1`方向）刚才把 `M` 给交出去了，现在空着。正好把旧王 `U` 抓过来放在下面。

```text
      K     <-- 现在的根是 K
     / \
   ...  U   <-- U 变成了 K 的儿子(d^1)
       /
      M     <-- M 依然被 U 抓着
```

-----

### 总结记忆口诀

把这三行代码翻译成人话，就是\*\*“提、接、挂”\*\*：

1.  **提 (Lift)**: `k = ch[u][d]`
      * 把儿子 `K` 提出来。
2.  **接 (Adopt)**: `ch[u][d] = ch[k][d^1]`
      * 父亲 `U` 这一侧空了，赶紧接管 `K` 的内侧儿子（也就是图中的 M）。
3.  **挂 (Hang)**: `ch[k][d^1] = u`
      * 儿子 `K` 的内侧空了，把旧父亲 `U` 挂在这个位置。

### 为什么用 d 和 d^1 极好？

你看上面的图，如果是**左旋**（`d=1`）：

  * `U` 在左，`K` 在右。
  * `M` 是 `K` 的**左**孩子（`d^1 = 0`）。
  * 过继时，`M` 依然是夹在 `U` 和 `K` 中间的那个节点。

**无论左旋还是右旋，永远都是中间那个节点 `M` 换了父亲。** 只要写了 `d` 和 `d^1`，代码就自动匹配了这个几何性质。

**Next Step:**
这就是旋转的全部秘密。你现在对这个图示有感觉了吗？如果这个理解了，是否需要我接着讲解 **“如何利用这个 rotate 函数写出一个极简的 Splay 核心操作 (Splay to Root)”**？那个也有一个很简单的双旋规律。