分块算法（Square Root Decomposition）的时间复杂度分析通常分为 **预处理** 和 **单次操作**（修改或查询）两个部分。

我们设定：
* $N$：数组元素的总个数。
* $M$：操作的总次数（修改 + 查询）。
* $B$：块的大小（Block Size）。在你的代码中 $B = \sqrt{N}$。

---

### 1. 结论

* **单次操作复杂度**：$O(\sqrt{N})$
* **总时间复杂度**：$O(M\sqrt{N})$
* **空间复杂度**：$O(N)$

---

### 2. 详细推导过程

分块算法的核心思想是将线性结构分为 $\sqrt{N}$ 个块，结合了“暴力法”和“标记法”的优点。

#### 预处理 (Init)
代码中遍历了 $1$ 到 $N$ 来初始化 `pos` 数组和 `sum` 数组。
* **复杂度**：$O(N)$

#### 区间修改 / 区间查询 (Update / Query)
无论是 `update` 还是 `query`，对于一个区间 $[L, R]$，在最坏的情况下（区间跨越了多个块），处理逻辑都分为三个部分：

1.  **左侧散块（Left Partial Block）**
    * 指区间左端点 $L$ 所在的块，但不是完整的一整块（即从 $L$ 到该块的结尾）。
    * **处理方式**：暴力遍历元素。
    * **最大代价**：块的大小 $B$。
    * **复杂度**：$O(B)$

2.  **右侧散块（Right Partial Block）**
    * 指区间右端点 $R$ 所在的块，同样不是完整的一整块（即从该块的开头到 $R$）。
    * **处理方式**：暴力遍历元素。
    * **最大代价**：块的大小 $B$。
    * **复杂度**：$O(B)$

3.  **中间整块（Middle Full Blocks）**
    * 指位于 $L$ 和 $R$ 之间所有完整的块。
    * **处理方式**：直接修改 `addflag` 或累加 `sum`，不遍历具体元素。
    * **最大块数**：总块数 $N/B$。
    * **复杂度**：$O(N/B)$

#### 单次操作总耗时
将上述三部分相加，单次操作的复杂度 $T(N)$ 为：
$$T(N) = O(B) + O(B) + O(\frac{N}{B}) = O(B + \frac{N}{B})$$

---

### 3. 为什么要取 $B = \sqrt{N}$？

为了让上述式子 $B + \frac{N}{B}$ 的值最小，根据均值不等式（或简单的微积分求导），当且仅当两项相等时，和最小：

$$B = \frac{N}{B} \implies B^2 = N \implies B = \sqrt{N}$$

此时，单次操作的复杂度为：
$$O(\sqrt{N} + \frac{N}{\sqrt{N}}) = O(\sqrt{N} + \sqrt{N}) = O(\sqrt{N})$$

因此，对于 $M$ 次操作，总的时间复杂度就是 **$O(M\sqrt{N})$**。

---

### 4. 与线段树的对比

| 特性 | 分块算法 (Block Decomposition) | 线段树 (Segment Tree) |
| :--- | :--- | :--- |
| **单次复杂度** | $O(\sqrt{N})$ | $O(\log N)$ |
| **常数因子** | 小（数组访问，逻辑简单） | 大（递归、指针或由下标计算带来的开销） |
| **实现难度** | 简单，直观 | 较复杂 |
| **适用场景** | 某些难以合并信息的复杂操作（如弹飞绵羊、区间众数） | 满足结合律的区间操作（如求和、最值） |
| **$N=10^5$ 时** | $\sqrt{N} \approx 316$ | $\log_2 N \approx 17$ |

**总结**：虽然在理论上 $O(\sqrt{N})$ 慢于 $O(\log N)$，但在数据规模 $N \le 10^5$ 左右时，分块算法依然非常高效，且往往比线段树更容易处理一些奇怪的非结合律问题。