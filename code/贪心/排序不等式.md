这是一个非常棒的数学问题！**排序不等式 (Rearrangement Inequality)** 是高中数学竞赛和 ACM 算法竞赛中处理“最值问题”的一把利器。

既然你已经能熟练使用 C++ 和算法，我们可以用**代数推导**和**直观逻辑**两种方式来彻底搞定它。

------

### 1. 什么是排序不等式？

假设有两个长度为 $n$ 的序列，我们把它们从小到大排好序：

- $a_1 \le a_2 \le \dots \le a_n$
- $b_1 \le b_2 \le \dots \le b_n$

我们将这两个序列中的数字两两配对相乘，然后求和。会有三种典型的情况：

1. 同序和 (Sequential Sum)：大的配大的，小的配小的。

   

   $$S_{max} = a_1b_1 + a_2b_2 + \dots + a_nb_n$$

2. 乱序和 (Random Sum)：随意打乱顺序配对。

   

   $$S_{random} = a_1b_{p_1} + a_2b_{p_2} + \dots + a_nb_{p_n}$$

   

   (其中 $p$ 是 $1 \dots n$ 的一个随机排列)

3. 反序和 (Reversed Sum)：最大的配最小的，最小的配最大的。

   

   $$S_{min} = a_1b_n + a_2b_{n-1} + \dots + a_nb_1$$

排序不等式的结论是：



$$\text{同序和} \ge \text{乱序和} \ge \text{反序和}$$

$$\sum_{i=1}^n a_i b_i \ge \sum_{i=1}^n a_i b_{p_i} \ge \sum_{i=1}^n a_i b_{n-i+1}$$

> **简单记忆**：
>
> - 想求**最大值**：这就叫“强强联合”。
> - 想求**最小值**：这就叫“损耗最大化”（或者上一题里的“为了让差值项最小”）。

------

### 2. 直观证明（生活中的例子）

想象你有两堆东西：

- **钱堆**：有一张 **10元**，有一张 **100元**。 (即 $a_1=10, a_2=100$)
- **倍数卡**：有一张 **x1卡**，有一张 **x10卡**。 (即 $b_1=1, b_2=10$)

你也只有两种搭配方法：

**方案 A（同序 - 强强联合）：**

- 100元 $\times$ 10倍 = 1000
- 10元 $\times$ 1倍 = 10
- **总和 = 1010**

**方案 B（反序 - 强弱搭配）：**

- 100元 $\times$ 1倍 = 100
- 10元 $\times$ 10倍 = 100
- **总和 = 200**

**道理很明显**：既然你有“放大器”（倍数卡），你肯定希望那个最大的放大器去放大那个**本来就最大**的数。把超级放大器用在小树苗上是浪费，用在参天大树上才能获得最大收益。

------

### 3. 严格数学证明（微扰分析法 / Exchange Argument）

在算法证明中，我们常用**“微扰分析”**（假如我不按规矩来，结果会不会变差？）来证明贪心策略。

我们只需要证明 $n=2$ 的情况，所有 $n>2$ 的情况都可以分解为无数次 $n=2$ 的交换。

设定：

已知 $a_1 < a_2$ 且 $b_1 < b_2$。

**对比：**

- 同序和：$S_1 = a_1b_1 + a_2b_2$
- 反序和：$S_2 = a_1b_2 + a_2b_1$

我们要证明 $S_1 > S_2$。

作差法证明：



$$S_1 - S_2 = (a_1b_1 + a_2b_2) - (a_1b_2 + a_2b_1)$$

重新组合各项（合并同类项）：



$$= a_2b_2 - a_2b_1 - a_1b_2 + a_1b_1$$

$$= a_2(b_2 - b_1) - a_1(b_2 - b_1)$$

提取公因式 $(b_2 - b_1)$：



$$= (a_2 - a_1)(b_2 - b_1)$$

**分析符号：**

1. 因为我们设定了 $a_1 < a_2$，所以 $(a_2 - a_1)$ 是**正数**。
2. 因为我们设定了 $b_1 < b_2$，所以 $(b_2 - b_1)$ 是**正数**。
3. 正数乘以正数，结果恒为**正数**。

结论：



$$S_1 - S_2 > 0 \implies S_1 > S_2$$

即：**同序和 > 反序和**。

对于任意乱序的情况，只要我们发现有一对下标 $i, j$ 是“逆序”的（即大的配了小的），我们就可以交换它们的配对对象。根据上面的证明，**每次交换都会让总和变大**。直到所有配对都变成“同序”，总和就达到了最大值。

------

### 4. 回到“小跳蛙”题目

在上一题《跳跳！》中，我们的目标是让 $S = \sum (h_i - h_{next})^2$ 最大。

展开后其中有一项是减去交叉项：$- 2 \sum h_i h_{next}$。

- 我们要让整个式子最大，就要让被减去的这一项**最小**。
- 根据排序不等式，要让乘积和最小，必须是**反序和**。
- 也就是：**序列中最大的数，必须和序列中最小的数相乘（相邻）。**

这就是为什么我们要把石头排序后，用“最大配最小”的方式来安排跳跃顺序。

------

### 5. 总结

- **同序和最大**（$a \uparrow, b \uparrow$）：想要最大收益，好马配好鞍。
- **反序和最小**（$a \uparrow, b \downarrow$）：想要最小代价（或最小化某个中间项），好马配劣鞍。

这个数学原理是很多贪心算法（比如“排队打水问题”、“最小生成树的某些性质”）的基石。

**接下来你想了解如何用这个原理解决“排队接水问题”（使得所有人平均等待时间最短），还是想回到 C++ 编程实现上？**