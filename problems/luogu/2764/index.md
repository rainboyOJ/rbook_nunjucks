---
oj: "luogu"
problem_id: "P2764"
title: "最小路径覆盖问题"
date: 2025-12-26 14:36
toc: true
tags: ["网络流","二分图"]
desc: "DAG 最小路径覆盖"
source: https://www.luogu.com.cn/problem/P2764
pre:
 - luogu,P1314
book:
 - bookid
---

[[TOC]]

## 题目解析


完整的解析与思维过程,参考本仓库的目录  `problems/luogu/2664/_DAG 最小路径覆盖解析.md`


# 图论详解：DAG 最小路径覆盖问题的网络流解法

在图论问题中，**最小路径覆盖**（Minimum Path Cover）是一个非常经典的模型。它通常出现在二分图匹配或网络流的练习题中（例如 P2764）。

很多同学初学时虽然能背下公式，但往往对“为什么要拆点”、“为什么要用二分图匹配”以及“最大匹配数和最长链的区别”感到困惑。

本文将剥离复杂的代码实现，通过图解和逻辑推导，带你彻底理解这个问题背后的数学直觉。

## 1. 问题定义

给定一个 **有向无环图 (DAG)** $G=(V,E)$。
我们需要找出最少数量的路径，使得图中的**每一个顶点**都恰好属于其中的一条路径（顶点不相交）。

路径长度不限，可以是单独一个点（长度为0）。

**举个栗子：**
假设 DAG 为 $1 \to 2$ 和 $3 \to 4$（两段互不相连的线段）。
那么最小路径覆盖就是 2 条：$\{1 \to 2\}$ 和 $\{3 \to 4\}$。

## 2. 核心公式

解决这个问题的金科玉律是：

$$
\text{最小路径覆盖数} = \text{顶点总数 } (n) - \text{最大二分匹配数}
$$

或者在网络流语境下：

$$
\text{最小路径覆盖数} = n - \text{最大流 (Max Flow)}
$$

看到这个公式，我们自然会产生三个疑问：
1. 这个二分图是怎么建出来的？
2. 为什么减去匹配数就是路径数？
3. 最大匹配数等于图上的最长链吗？

我们一一解答。

## 3. 建模方法：拆点法

在一个 DAG 中，每个节点 $u$ 其实有两个“身份”：
1. **作为起点的身份**：它可能指向别人（例如 $u \to v$）。
2. **作为终点的身份**：它可能被别人指向（例如 $k \to u$）。

为了在网络流/二分图中体现这两个身份的互斥性，我们使用**拆点法**：
将原图中的每一个点 $i$ 拆成两个点：**左部点 $X_i$** 和 **右部点 $Y_i$**。

### 建图步骤（网络流版）：

1.  **设立源汇**：建立源点 $S$ 和汇点 $T$。
2.  **限制出度**：从 $S$ 向所有的左部点 $X_i$ 连边，容量为 1。
    * *含义：点 $i$ 作为路径的前驱，只能使用一次。*
3.  **限制入度**：从所有的右部点 $Y_i$ 向 $T$ 连边，容量为 1。
    * *含义：点 $i$ 作为路径的后继，只能被使用一次。*
4.  **连接原图边**：如果原图中有边 $u \to v$，则连接 $X_u \to Y_v$，容量为 1。
    * *含义：尝试把 $u$ 和 $v$ 拼接在一起，u 做头，v 做尾。*

---

## 4. 深度解析：为什么这样转化？

这是理解本题最关键的一步。

**最小路径覆盖的本质，其实是一场“积木拼接游戏”。**

* 最开始，图上有 $n$ 个点，它们都是孤立的。此时我们有 $n$ 条路径（每个点自成一条路径）。
* 我们的目标是让路径数量变少。怎么变少呢？
* 每当我们把两个点“拼”在一起（比如把 $u$ 和 $v$ 连成 $u \to v$），原本两条独立的路径就合并成了一条。
* **每成功拼接一次，总路径数就减少 1。**

### “路径性质”与“匹配限制”的完美对应

为什么可以用二分图匹配来做拼接？因为二分图匹配的规则完美复现了简单路径的约束：

| 路径的约束 (原图) | 二分图匹配的约束 (新图) |
| :--- | :--- |
| **一个点只能走向一个点** <br> (不能 $1\to2$ 且 $1\to3$) | **左部点 $X$ 出度限 1** <br> $X_1$ 只能匹配一条边，要么连 $Y_2$，要么连 $Y_3$。 |
| **一个点只能被一个点连接** <br> (不能 $1\to3$ 且 $4\to3$) | **右部点 $Y$ 入度限 1** <br> $Y_3$ 只能接受一条边，要么来自 $X_1$，要么来自 $X_4$。 |

因此，**求最大流（最大匹配）**，就是在求**“全图最多能进行多少次合法的拼接”**。

拼接次数越多，剩下的独立路径就越少。
所以：$\text{路径数} = \text{初始点数} - \text{拼接次数 (Max Flow)}$。

## 5. 常见误区：最大匹配 = 最长链？

很多同学会误以为最大匹配数就是 DAG 上最长那条链的长度。
**这是错误的。**

**反例：**
考虑图：$1 \to 2$ 和 $3 \to 4$。
* **最长链**：长度为 1（只有一条边）。
* **最大匹配**：2（我们可以选 $X_1 \to Y_2$ 和 $X_3 \to Y_4$）。

**结论**：
* **最长链**关注的是**局部**（单条路径的最长延伸）。
* **最大匹配**关注的是**全局**（整个图一共能连多少条边）。
只有当最小路径覆盖数为 1 时，两者才在数值上相等。

## 6. 路径还原 (Output)

求出最小路径数只是第一步，题目通常要求输出具体路径。我们可以在跑完网络流（Dinic/匈牙利）后，检查残量网络。

1.  **寻找匹配边**：遍历所有 $X_u \to Y_v$ 的边。如果该边的容量变为了 0（或者反向边有流量），说明这条边被选中了。
    * 记录 `next_node[u] = v`。
    * 同时标记 `has_incoming[v] = true`（说明 v 不是龙头）。
2.  **寻找路径头**：遍历 $1 \dots n$，所有 `has_incoming[i] == false` 的点，就是一条路径的起点。
3.  **打印**：从起点开始，顺着 `next_node` 数组递归输出，直到没有后继。

## 7. 总结

DAG 最小路径覆盖问题的解题模板如下：

1.  **拆点**：$1 \dots n$ 为左部，$n+1 \dots 2n$ 为右部。
2.  **连边**：
    * $S \to X_i$
    * $Y_i \to T$
    * 若 $u \to v$，则 $X_u \to Y_{v}$
3.  **跑最大流**：得到 `max_flow`。
4.  **计算答案**：$ans = n - max\_flow$。
5.  **还原路径**：利用残量网络构建链表。

这个问题完美展示了如何将**几何/拓扑约束**（路径不可分叉）转化为**代数/流量约束**（容量为1），是网络流建模思想的极佳入门案例。


## 代码 

@include-code(./1.cpp, cpp)

