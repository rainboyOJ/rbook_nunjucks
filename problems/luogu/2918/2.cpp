#include <cstdio>
#include <cstring>
#include <algorithm> // 建议加上这个头文件以使用 min 等函数

// 定义全局变量
// h: 需要购买的干草总量 (目标重量)
// n: 干草的种类数
int h, n;

// p[i]: 第i种干草的重量 (Pounds)
// c[i]: 第i种干草的价格 (Cost)
int p[50010]; 
int c[50010];

// f[j]: 凑够重量 j 所需要的最小花费
// 数组大小开得比 h 大，因为我们允许重量超过 h
int f[55050]; 

int main(){
    // 读入 n (种类) 和 h (目标重量)
    scanf("%d%d", &n, &h);

    int i, j;
    // 读入每种干草的重量和价格
    for (i = 1; i <= n; i++){
        scanf("%d%d", &p[i], &c[i]);
    }

    // 1. 初始化
    // 因为要求“最小”花费，所以先把 DP 数组全部初始化为一个很大的数 (0x7f 表示很大)
    // 这样在取 min 的时候才会被覆盖
    memset(f, 0x7f, sizeof(f));
    
    // 边界条件：凑够 0 重量不需要花钱
    f[0] = 0; 

    // 2. 确定背包容量上限
    // 这是一个关键点！
    // 题目要求至少 h。如果最后一次选了一个很大的包（比如重量5000），
    // 那么总重量可能会达到 h + 5000 左右。
    // 所以我们把背包上限设为 h + 5000 (题目中单捆干草最大重量是5000)
    int m = h + 5010; 

    // 3. 开始 DP (完全背包模型)
    for(i = 1; i <= n; i++) { // 枚举每种干草
        // 枚举当前重量 j
        // 注意：这里 j 从 p[i] 开始从小到大枚举 (j++)
        // 这代表“完全背包”，意味着每种干草可以被选无限次
        for(j = p[i]; j <= m; j++){
            // 状态转移方程：
            // f[j] = min(f[j], f[j - p[i]] + c[i])
            // 如果“当前的最小花费” 比 “之前的重量状态(j-p[i]) 加上这捆干草的花费” 还要大
            // 那就更新为更小的花费
            if( f[j] > f[j-p[i]] + c[i])
                f[j] = f[j-p[i]] + c[i];
        }
    }

    // 4. 寻找答案
    // 题目要求重量 >= h。
    // 所以我们在 [h, m] 这个范围内扫描，找一个花费最小的作为答案。
    int mm = 0x7f7f7f7f; // 初始化为一个很大值

    for(i = h; i <= m; i++){
        if( mm > f[i])
            mm = f[i];
    }

    // 输出找到的最小花费
    printf("%d", mm);

    return 0;
}
