---
oj: "luogu"
problem_id: "P3128"
title: "[USACO15DEC] Max Flow P"
date: 2026-01-03 21:13
toc: true
tags: ["树上差分","lca"]
desc: "树上差分模板题目"
source: https://www.luogu.com.cn/problem/P3128
---

[[TOC]]

## 题目解析

## 核心思路解析：树上差分 (Tree Difference)

这道题是 **树上点差分** 的经典模板题。

题目要求我们将 $K$ 条路径上的所有点权值 +1，最后问哪个点的权值最大。如果直接模拟每条路径，复杂度是 $O(N \times K)$，会超时。

我们需要使用 **树上差分** 将单次路径修改的复杂度降为 $O(1)$（不含 LCA 的时间）。

### 1. 差分原理

在数组中，要给区间 $[L, R]$ 加上 $v$，我们做 d[L]+=v, d[R+1]-=v。

在树上，要给路径 $u \to v$ 上的所有点加上 $1$，我们需要利用 LCA (最近公共祖先) 来进行差分操作。

设 $l = \text{LCA}(u, v)$，操作如下：

1. `diff[u]++`
2. `diff[v]++`
3. `diff[l]--`
4. `diff[parent[l]]--`

**原理图解：**

- `u` 和 `v` 的 `+1` 会在统计子树和的时候，顺着树枝向上累加。
- 这两股 `+1` 的洪流会在 $l$ 处汇聚。
- 如果我们不做处理，$l$ 会被加 2 次，且 $l$ 的祖先们也会被加 2 次。
- 所以我们在 $l$ 处 `-1`，抵消掉多余的一次（使得 $l$ 只加 1）。
- 我们在 `parent[l]` 处再 `-1`，使得 $l$ 上面的祖先节点的增量总和为 0（因为路径只到 $l$ 为止，不包括 $l$ 的父亲）。

### 2. 统计答案

所有操作做完后，从根节点开始做一次 DFS。

每个点的最终权值 = 该点子树内所有 diff 值的和。

即：val[u] = diff[u] + sum(val[child])。

------



## 关键点检查

1. **数组大小**: `maxn` 设为 50005，符合 $N \le 50000$。
2. **黑洞特性**: 当 LCA 是根节点时，`lca.f[l][0]` 返回 `0`。代码执行 `diff[0]--`。因为最后 `dfs_calc` 从 1 开始遍历，且不会访问 0，所以这个操作是安全的，省去了特判。
3. **统计逻辑**: `diff[u] += diff[v]` 必须放在递归 `dfs_calc(v, u)` **之后**（回溯阶段），这样才能把子树的值汇总上来。

## 代码 

@include-code(./1.cpp, cpp)

