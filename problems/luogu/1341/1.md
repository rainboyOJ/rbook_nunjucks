---
oj: "luogu"
problem_id: "P1341"
title: "无序字母对"
date: 2025-12-19 08:07
toc: true
tags: ["欧拉路"]
desc: "欧拉路入门题目"
source: https://www.luogu.com.cn/problem/P1341
---

[[TOC]]




这道题是 **欧拉路 (Euler Path)** 的经典应用。

简而言之：**把字母看作“点”，把给定的字母对看作“边”。题目就是要求一笔画走完所有边。**

## 核心解题逻辑

### 1 建模 (Mapping)

* **节点**：ASCII 字符（'A'-'Z', 'a'-'z'）。
* **边**：输入的两个字母之间连一条无向边。
* **目标**：找一条路径，经过每条边恰好一次（欧拉路/欧拉回路）。

### 2 判别条件 (Existence)

图必须连通，且满足度数要求：

* **欧拉回路**（起点回到起点）：所有点的度数都是偶数。
* **欧拉路**（起点终点不同）：只有 **2个** 点的度数是奇数，其余全为偶数。
* **无解**：奇数度点的个数不是 0 也不是 2，或者图不连通。

### 3 字典序最小 (Lexicographical Order)

题目要求字典序最小，包含两层含义：

1 **起点选择**：
* 如果有奇点，必须从**ASCII码较小**的那个奇点出发。
* 如果是回路（全偶点），从**ASCII码最小**的有边节点出发。


2 **路径选择**：
* 在 DFS 过程中，优先走 ASCII 码小的邻居（使用邻接矩阵枚举即可自然满足）。



### 4 算法流程 (Hierholzer's Algorithm 变体)

* **DFS 遍历**：每走过一条边，就**删除**这条边（防止走回头路）。
* **入栈时机**：**回溯时记录节点**（当一个点没有路可走时，将其加入栈/结果集）。
* *为什么？* 因为DFS会先钻到底，最后回溯的顺序才是正确的拼接顺序（逆序）。


* **输出**：将记录的节点倒序输出。

---

## C++ 代码实现 (精简版)

```cpp
#include <iostream>
#include <string>
#include <stack>
#include <algorithm>

using namespace std;

// 邻接矩阵存图，G[u][v]=1 表示有边，自动满足字典序遍历
int G[150][150]; 
int du[150]; // 记录度数
stack<char> st; // 存路径
int n; // 边数

// 核心 DFS：Hierholzer 算法
void dfs(int u) {
    // 按 ASCII 顺序从小到大遍历邻居
    for (int v = 0; v < 150; v++) {
        if (G[u][v]) {
            G[u][v]--; // 删边 (无向图删两边)
            G[v][u]--;
            dfs(v); // 递归
        }
    }
    stpush(u); // 【关键】无路可走时入栈
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        string s; cin >> s;
        G[s[0]][s[1]] = G[s[1]][s[0]] = 1; // 建边
        du[s[0]]++; du[s[1]]++; // 统计度数
    }

    int start_node = 0;
    int odd_count = 0;
    
    // 1 找起点 & 检查度数
    for (int i = 0; i < 150; i++) {
        if (du[i] % 2 != 0) odd_count++;
    }

    if (odd_count != 0 && odd_count != 2) {
        cout << "No Solution";
        return 0;
    }

    // 确定起点：
    // 如果有奇点，找最小的奇点；
    // 如果全偶，找最小的有度数的点。
    for (int i = 0; i < 150; i++) {
        if (du[i]) { // 这是一个存在的点
            if (odd_count == 2) {
                if (du[i] % 2 != 0) {
                    start_node = i;
                    break;
                }
            } else { // odd_count == 0
                start_node = i;
                break;
            }
        }
    }

    // 2 开始搜索
    dfs(start_node);

    // 3 检查连通性 (防止图不连通的情况)
    // 欧拉路径的点数应该是 边数 + 1
    if (stsize() != n + 1) {
        cout << "No Solution";
        return 0;
    }

    // 4 输出
    while (!stempty()) {
        cout << (char)sttop();
        stpop();
    }

    return 0;
}

```

## 记忆要点

1 **奇点数**：必须是 0 或 2。
2 **删边**：DFS 走过就拆桥。
3 **回溯入栈**：走到死胡同再记录，最后倒序输出。
4 **贪心**：邻居从小到大找。
