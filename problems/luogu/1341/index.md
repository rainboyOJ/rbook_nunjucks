---
oj: "luogu"
problem_id: "P1341"
title: "无序字母对"
date: 2025-12-19 08:07
toc: true
tags: ["欧拉路"]
desc: "欧拉路入门题目"
source: https://www.luogu.com.cn/problem/P1341
---

[[TOC]]




这道题是 **欧拉路 (Euler Path)** 的经典应用。

简而言之：**把字母看作“点”，把给定的字母对看作“边”。题目就是要求一笔画走完所有边。**

## 核心解题逻辑

### 1 建模 (Mapping)

* **节点**：ASCII 字符（'A'-'Z', 'a'-'z'）。
* **边**：输入的两个字母之间连一条无向边。
* **目标**：找一条路径，经过每条边恰好一次（欧拉路/欧拉回路）。

### 2 判别条件 (Existence)

图必须连通，且满足度数要求：

* **欧拉回路**（起点回到起点）：所有点的度数都是偶数。
* **欧拉路**（起点终点不同）：只有 **2个** 点的度数是奇数，其余全为偶数。
* **无解**：奇数度点的个数不是 0 也不是 2，或者图不连通。

### 3 字典序最小 (Lexicographical Order)

题目要求字典序最小，包含两层含义：

1 **起点选择**：
* 如果有奇点，必须从**ASCII码较小**的那个奇点出发。
* 如果是回路（全偶点），从**ASCII码最小**的有边节点出发。


2 **路径选择**：
* 在 DFS 过程中，优先走 ASCII 码小的邻居（使用邻接矩阵枚举即可自然满足）。



### 4 算法流程 (Hierholzer's Algorithm 变体)

* **DFS 遍历**：每走过一条边，就**删除**这条边（防止走回头路）。
* **入栈时机**：**回溯时记录节点**（当一个点没有路可走时，将其加入栈/结果集）。
* *为什么？* 因为DFS会先钻到底，最后回溯的顺序才是正确的拼接顺序（逆序）。


* **输出**：将记录的节点倒序输出。

---

## 代码实现

@include-code(./right.cpp,cpp)


但是这个代码M L E了

问题出在 dfs 函数中删除边的逻辑上。

题目中提到“无序字母对”，并没有明确禁止 自环（即两个字母相同，如 AA）。虽然题目说“各不相同的无序字母对”，但通常测试数据中可能会包含 AA 这样的合法输入（或者即使没有，代码逻辑也应严谨）。

看看上面的代码：

```cpp
if (G[u][v]) {
    G[u][v]--; // 第一步：减 1
    G[v][u]--; // 第二步：再减 1
    dfs(v); 
}
```

假设输入中有一个自环 `X X`：

1. 建图时：G['X']['X'] = 1。
2. 进入 dfs('X')，遍历到 v = 'X'。
3. G['X']['X'] 是 1，进入 if。
4. G['X']['X']--，此时值变为 0。
5. G['v']['u']-- （因为 $u=v$，还是操作同一个位置），此时值变为 -1。
6. 递归调用 dfs('X')。在下一层递归中，检查 if (G['X']['X'])。
7. 在 C++ 中，非 0 值（包括 -1）都为真。
8. 条件成立，继续递归，值变为 -2, -3... 导致无限递归，最终爆栈。

@include-code(./2.cpp,cpp)


## 记忆要点

1 **奇点数**：必须是 0 或 2。
2 **删边**：DFS 走过就拆桥。
3 **回溯入栈**：走到死胡同再记录，最后倒序输出。
4 **贪心**：邻居从小到大找。
