**当然可以。**

虽然带修莫队是解决这类问题最直观、代码相对较短的方法，但它在时间复杂度上（$O(N^{5/3})$）其实并不是最优的。

如果不使用莫队，解决“带修改的区间不同颜色计数”问题，目前最主流、效率更高的解法是结合 **Pre 数组转化** 使用 **CDQ 分治** 或者 **分块/树套树**。

其中，**CDQ 分治** 是最标准的非莫队解法，理论复杂度为 $O(N \log^2 N)$，通常比带修莫队跑得更快。

-----

### 核心转化思想：$Pre$ 数组

无论是 CDQ 分治还是分块，不使用莫队的关键在于把“**数颜色**”的问题转化为“**二维数点**”的问题。

1.  **定义**：设 $pre[i]$ 表示第 $i$ 个位置的颜色上一次出现的位置。如果这是该颜色第一次出现，则 $pre[i] = 0$。
2.  **性质**：对于询问区间 $[L, R]$，如果位置 $i$ 上的颜色是该区间内第一次出现，那么必然满足 $pre[i] < L$。
3.  **转化**：
      * 问题变成了：在区间 $[L, R]$ 中，有多少个位置 $i$，满足 $pre[i] < L$。
      * 这是一个典型的**二维偏序/数点**问题：满足 $L \le i \le R$ 且 $0 \le pre[i] < L$ 的点数。

-----

### 方法一：CDQ 分治（推荐）

CDQ 分治擅长处理带时间维度的多维偏序问题。我们将“修改”和“询问”都看作操作序列。

#### 1\. 维护 $Pre$ 的变化（处理修改）

当我们将位置 $P$ 的颜色由 $A$ 修改为 $B$ 时，会发生连锁反应。我们需要利用 `std::set` 对每种颜色维护其出现位置的有序集合，以便快速找到前驱和后继。

  * **对于旧颜色 $A$**：
      * 位置 $P$ 不再是颜色 $A$。我们需要删除点 $(P, pre[P])$。
      * 如果 $P$ 后面还有颜色 $A$（设位置为 $next\_pos$），那么 $next\_pos$ 的前驱将不再是 $P$，而是 $P$ 之前的那个 $A$。我们需要更新 $pre[next\_pos]$。这相当于删掉旧点 $(next\_pos, P)$，加入新点。
  * **对于新颜色 $B$**：
      * 位置 $P$ 变成了颜色 $B$。我们需要计算新的 $pre[P]$，并加入点 $(P, new\_pre)$。
      * 如果 $P$ 后面有颜色 $B$（设位置为 $next\_pos$），其前驱将变为 $P$。我们需要更新 $pre[next\_pos]$。

这样，一次单点颜色修改就被转化为了若干次**二维点的删除与插入**操作。

#### 2\. 处理询问

一个询问 $[L, R]$ 就是求下标在 $[L, R]$ 之间，数值小于 $L$ 的元素个数。
这可以转化为二维平面求和：求矩形区域 $x \in [L, R], y \in [0, L-1]$ 内的权值和。

#### 3\. CDQ 流程

我们将所有操作（修改产生的加点/删点、询问）按时间排序，然后进行分治：

1.  **分治**：将操作序列一分为二。
2.  **处理**：考虑左半边的“修改”操作对右半边“询问”的影响。
      * 将左半边的修改和右半边的询问按下标 $i$（第一维）排序。
      * 遍历排序后的序列：如果是左半边的修改，在树状数组（BIT）的 $pre[i]$ 位置（第二维）进行单点加减。
      * 如果是右半边的询问，在树状数组上查询 $[0, L-1]$ 的和。
3.  **递归**：递归处理左右子区间。
4.  **撤销**：清空树状数组，还原现场。

#### 复杂度

  * 时间复杂度：$O(N \log^2 N)$。
  * 空间复杂度：$O(N)$。

-----

### 方法二：分块 + Pre 数组

如果你不想写 CDQ 分治，也可以用分块，这比莫队稍微难写一点点，但也是一种思路。

1.  **预处理**：维护 $pre$ 数组。
2.  **分块**：将序列分成 $\sqrt{N}$ 块。
3.  **块内排序**：对每个块，将其中的 $pre$ 值进行排序，拷贝一份存起来。
4.  **询问 $[L, R]$**：
      * 对于中间的完整块：在块内排序后的数组上二分查找，统计 $< L$ 的数的个数。
      * 对于两端的不完整块：暴力遍历原 $pre$ 数组，统计 $< L$ 的个数。
5.  **修改**：
      * 利用 `std::set` 找到受影响的 $pre$ 值（同 CDQ 里的逻辑，涉及 $P$ 本身以及 $P$ 后面同颜色的点）。
      * 直接修改原数组的 $pre$ 值。
      * **重构块**：由于修改了 $pre$ 值，受影响的块（最多2个）需要重新排序。

#### 复杂度

  * 时间复杂度：$O(M \sqrt{N \log N})$ 或 $O(M \sqrt{N})$（取决于块内维护方式）。
  * 这种方法比莫队更稳定，因为它不依赖询问分布。

-----

### CDQ 分治 代码结构示例

这是 CDQ 分治解法的核心逻辑框架（省略了部分细节）：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

const int MAXN = 200005;
const int MAXC = 1000005;

struct Op {
    int type; // 1: 修改(加点/删点), 2: 询问
    int x, y, val; // 修改: x位置, y=pre值, val=+1/-1
                   // 询问: x=R, y=L, val=id (询问编号), 实际上我们要拆成 query(x)-query(y)
    int id; // 询问的ID
    int time; // 原始时间顺序
};

// 树状数组 (BIT)
int bit[MAXN];
int n, m;
void add(int x, int v) { for (; x <= n; x += x & -x) bit[x] += v; }
int ask(int x) { int res = 0; for (; x; x -= x & -x) res += bit[x]; return res; }

// 颜色位置集合
set<int> pos_set[MAXC];
int a[MAXN], pre[MAXN];
vector<Op> ops;

// 辅助函数：构造修改操作
void modify(int p, int old_c, int new_c, int time) {
    // 这里需要精细操作 set，找到 p 的前驱后继
    // 产生“删除旧pre关系”和“添加新pre关系”的 Op 加入 ops 向量
    // 注意：不仅 p 的 pre 变了，p 后面那个同色点的 pre 也变了！
}

// CDQ 分治
void solve(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    solve(l, mid);
    solve(mid + 1, r);

    // 归并过程：计算左边修改对右边询问的影响
    // 这里我们要按 x 坐标排序
    vector<Op> temp;
    int i = l, j = mid + 1;
    while (j <= r) {
        while (i <= mid && ops[i].x <= ops[j].x) {
            if (ops[i].type == 1) add(ops[i].y + 1, ops[i].val); // y可能为0，BIT要+1
            i++;
        }
        if (ops[j].type == 2) {
            // 询问：统计 pre < L (即 y < L) 的数量
            // ops[j].y 存的是 L
            ans[ops[j].id] += ask(ops[j].y); 
        }
        j++;
    }
    
    // 撤销 BIT 操作（还原由0变为0，比memset快）
    for (int k = l; k < i; k++) {
        if (ops[k].type == 1) add(ops[k].y + 1, -ops[k].val);
    }
    
    // 按 x 排序归并 (为了下一层递归或者当前层的有序性)
    // sort(ops.begin() + l, ops.begin() + r + 1, cmp_by_x); 
    // 或者直接使用 inplace_merge
}

int main() {
    // 1. 读入数据
    // 2. 初始化 set 和 pre 数组，生成初始的 Add 操作
    // 3. 读入 M 个指令，生成 Modify 和 Query 操作
    // 4. solve(0, ops.size() - 1)
    // 5. 输出答案
}
```

### 总结

  * **能不用莫队吗？** 能。
  * **如果不卡常数**：带修莫队最好写。
  * **如果追求效率/正解**：**CDQ 分治**（配合 Pre 数组转化）是这道题的“标准”高级解法，效率 $O(N \log^2 N)$。