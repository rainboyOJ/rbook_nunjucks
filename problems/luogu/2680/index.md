---
oj: "luogu"
problem_id: "P2680"
title: "[NOIP 2015 提高组] 运输计划"
date: 2026-01-04 11:19
toc: true
tags: ["lca","noip","树上差分","二分"]
desc: "不算很难的noip题目"
source: https://www.luogu.com.cn/problem/P2680
---

[[TOC]]

这个题目的前置题 :　 为了彻底拿下 P2680 运输计划，建议的做题路线是：

- P3128 Max Flow P (你已经搞定，点差分基础)
- CF191C Fools and Roads (边差分基础，学会映射边 ID)
- P6869 Putovanje (边差分进阶，学会统计覆盖次数后做决策，这题做完就可以直接去杀 P2680 了)
- (可选) P3258 松鼠的新家 (磨练细节处理能力)
- P2680 运输计划 (最终 BOSS：边差分 + 二分答案)

## 题目解析

### 错误想法

- 求出每条路径的时间(长度),然后减去路径上的最长边,答案是这些值的最小值

### 1. “全局唯一” vs “各自为政”

**题目限制**：你**只能**把全图中的**某一条边**变成虫洞（权值为 0）。这意味着，这条被选中的边，必须对所有需要缩短的路径生效。

你的思路：

“每条路径减去该路径上的最长边”。

这隐含了一个假设：你可以为每一条路径单独指定一个虫洞。

- 路径 A 可以删掉它自己的最长边 $E_a$。
- 路径 B 可以删掉它自己的最长边 $E_b$。

现实情况：

如果 $E_a$ 和 $E_b$ 不是同一条边，你不可能同时删掉它们。你只能二选一（或者选一条它们共用的其他边）。如果你删了 $E_a$，路径 B 的长度可能完全没变，导致最终的最大值依然很大。

### 2. “木桶效应”：我们要的是 Min-Max

**题目目标**：所有运输计划**同时**结束，取决于**最慢**的那一个。我们要让这个**最慢的时间**尽可能短（Minimize the Maximum）。

你的思路：

“答案是这些值的最小值”。

这意味着你求的是：“在理想情况下，跑得最快的那条路径能有多快”。

现实情况：

最快的路径跑得再快也没用，系统完成时间取决于最慢的那条路径（瓶颈）。你需要关心的是那些“超长路径”能不能被同一条边切断并缩短。

### 暴力想法

枚举每条边为0,然后dfs找出所有路路径的长度,求出最大小值,

TLE

### 二分

求最大时间最小,显然是二分答案啊. 所以从二分开始考虑

- $T_i$ 表示路径 `i`  的总时间

枚举一个答案时间 $T_a$ ,把 $T_i$ 分成两类

- $T_i <= T_a$ 合法,不用管
- $T_i > T_a$ 不合法,超标, 

问题变成: **怎么能让(或者是否可以) 超标的路合法 ? **, 可以想到,

- 一定是删除(置0)所有超标路的公共边中最大的那条边, 不删除公共边,没有意义
- 找到公共边: 树上差分

思考二分性: 

- 如果$T_a$ 成立: $T_a$ 条件下$\forall T_i \leqslatn T_a$, 则%T_a + 1% 成立

我们显然要要找到第一个成立的 $T_a$

## 解析2

核心目标：

在树上选定一条边，将其权值变为 0，使得所有给定路径中，最长的那条路径的长度最小。

**思维导图**：

1. **“最大值最小” $\rightarrow$ 二分答案**
   - 这类问题通常具备单调性：如果能在 $T$ 时间内完成，那么在 $T+1$ 时间肯定也能完成。
   - 我们可以二分一个时间限制 $T$。
2. **如何检查时间 $T$ 是否可行？ (`check(T)`)**
   - 找出所有长度 $> T$ 的路径（我们称之为“超标路径”）。
   - 如果**没有**超标路径，说明 $T$ 可行，直接返回 True。
   - 如果有，我们需要找到一条边，满足以下两个条件：
     1. **这条边被所有“超标路径”共同经过**（只有切断所有超标路径的公用边，才能把它们都缩短）。
     2. **最长的**那条超标路径减去这条边的权值后，长度 $\le T$。
   - 如果能找到这样的边，说明 $T$ 可行。
3. **如何快速找到被所有超标路径经过的边？ $\rightarrow$ 树上边差分**
   - 假设有 $cnt$ 条超标路径。
   - 对于每条超标路径 $(u, v)$，我们在树上做差分：`diff[u]++`, `diff[v]++`, `diff[lca(u,v)] -= 2`。
   - 做完后，从下往上统计前缀和。如果某个点 $u$ 的权值 `sum[u] == cnt`，说明 $u$ 到其父亲的这条边被所有 $cnt$ 条路径经过。

**算法流程**：

1. 预处理：计算 LCA，计算每个点到根的距离 `dist`，把所有路径的长度、LCA 都算好存起来（避免二分时重复算）。
2. 二分答案：范围 $[0, \text{最长路径长度}]$。
3. Check 函数：利用树上差分判断。


### 2. 代码实现

基于你的模板，我做了以下适配：

1. **内存调整**：$N=300,000$，数组大小设为 `300005`。
2. **LCA 增强**：在 DFS 过程中顺便计算 `dist`（节点到根距离）和 `val`（节点到父亲的边权）。
3. **预处理**：因为二分 check 会调用很多次，所以先把 $m$ 个询问的 LCA 和原始长度算好存数组里。

### 复杂度分析

- **时间复杂度**：
  - 预处理 LCA: $O(N \log N)$
  - 预处理查询: $O(M \log N)$
  - 二分 Check: $O(\log(\text{MaxLen}) \times (N + M))$。其中 $N$ 是 DFS 的开销，$M$ 是遍历查询的开销。
  - 总时间: $O(M \log N + (N+M) \log (\text{Len})) \approx 10^7$ 级别，完全可以通过 1s 的时限。
- **空间复杂度**：
  - $O(N \times 20)$ 用于倍增数组，约为 24MB，加上其他数组，远小于 128MB。




## 代码 

@include-code(./1.cpp, cpp)

