<!DOCTYPE html>
<html lang="zh" data-darkmode="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的算法书 - [NOIP 2018 提高组] 旅行 加强版</title>
    <meta name="description" content="这是一本关于算法的书">
    <meta name="author" content="rainboy">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-web/1.520.0/style.min.css" integrity="sha512-VqbHLQtJ5icD77Z4HH8NsrtoRJlTAkOKdSrymwYZtZ1Ipbit8L/Pp8RIeHS2vpNk2bVOszUUDotVl7sK403sjw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/markdown.css">
    <link rel="stylesheet" href="/prism-theme/prism-tomorrow.css">
</head>
<body>
    <aside class="panel">
    <ul class="panel-list">
      <li><a href="/"><i class="fa fa-home"></i></a></li>
      <li><a href="javascript:void(0);" onclick="showMenuModal()"><i class="fa fa-list"></i></a></li>
    </ul>
    <ul class="panel-list">
      <li><input type="radio" class="J_darkMode" value="auto" name="darkmode" id="darkmode-auto" checked=""><label for="darkmode-auto"><i class="fa fa-adjust"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="light" name="darkmode" id="darkmode-light"><label for="darkmode-light"><i class="fa fa-sun-o"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="dark" name="darkmode" id="darkmode-dark"><label for="darkmode-dark"><i class="fa fa-moon-o"></i></label></li>
    </ul>
  </aside>
    <div id="modal-menu" class="modal-menu" style="display:none;">
  <div class="modal-menu-mask" onclick="hideMenuModal()"></div>
  <div class="modal-menu-content">
    <button class="modal-menu-close" onclick="hideMenuModal()">×</button>
    <h2>目录</h2>
    
  </div>
</div>
<script>
function showMenuModal() {
  document.getElementById('modal-menu').style.display = 'block';
}
function hideMenuModal() {
  document.getElementById('modal-menu').style.display = 'none';
}
</script>

    <main>
        
<article class="page">
    <header class="container page-header">
        <h1>[NOIP 2018 提高组] 旅行 加强版</h1>
        <div class="problem-info">
          <div class="problem-tags">
            <span>标签:</span>
            
              <span>#基环树</span>
            
              <span>#贪心</span>
            
          </div>
          <div class="problem-source">
            <span>原题目:</span>
            <a href="https://www.luogu.com.cn/problem/P5049" target="_blank"> luogu-P5049</a>
          </div>
        </div>
        <div>
          <span>简要描述:</span>
          <span>O(n)基环树dfs字典序最小问题(贪心)</span>
        </div>
    </header>
    
    <div class="container">
        <div class="heti markdown-body">
    <nav class="table-of-contents"><ol><li><a href="#%E7%AE%80%E5%8D%95%E6%80%9D%E8%80%83">简单思考</a></li><li><a href="#%E5%8E%9F%E7%89%88%E7%9A%84%E4%BB%A3%E7%A0%81">原版的代码</a></li><li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</a><ol><li><a href="#%E6%83%85%E5%86%B5-0">情况 0</a></li></ol></li><li><a href="#%E6%80%9D%E8%80%83">思考</a><ol><li><a href="#%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5">核心策略</a></li><li><a href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E5%BD%93%E5%89%8D%E2%80%9C%E6%9C%80%E4%BC%98%E8%A7%A3%E2%80%9D-(ring-edge-is-the-smallest)">情况一：环上的边是当前“最优解” (Ring edge is the Smallest)</a></li><li><a href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E2%80%9C%E4%B8%AD%E5%BA%B8%E4%B9%8B%E9%80%89%E2%80%9D-(ring-edge-is-neither-smallest-nor-largest)">情况二：环上的边是“中庸之选” (Ring edge is neither smallest nor largest)</a></li><li><a href="#%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E2%80%9C%E6%9C%80%E5%A4%A7%2F%E6%9C%80%E5%90%8E%E2%80%9D%E7%9A%84%E9%80%89%E6%8B%A9-(ring-edge-is-the-largest)">情况三：环上的边是“最大/最后”的选择 (Ring edge is the Largest)</a><ol><li><a href="#graphviz-%E5%9B%BE%E7%A4%BA%EF%BC%9A%E6%83%85%E5%86%B5%E4%B8%89">Graphviz 图示：情况三</a></li></ol></li><li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AF%B9%E5%BA%94">总结与代码对应</a></li></ol></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%8F%82%E7%9C%8B">参看</a><ol><li><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF">核心思路</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81-(c%2B%2B)">修改后的代码 (C++)</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90">代码修改要点解析</a></li></ol></li><li><a href="#%E4%BB%A3%E7%A0%81-ver-1">代码 ver 1</a><ol><li><a href="#1.-%E5%BF%85%E6%9D%80-hack-%E6%95%B0%E6%8D%AE-(input)">1. 必杀 Hack 数据 (Input)</a></li><li><a href="#2.-%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94">2. 结果对比</a></li><li><a href="#3.-%E9%94%99%E8%AF%AF%E5%9B%BE%E8%A7%A3%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90">3. 错误图解与深度分析</a></li><li><a href="#4.-%E6%9C%80%E7%BB%88%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">4. 最终修复建议</a></li></ol></li><li><a href="#%E4%BB%A3%E7%A0%81-ver-1.1">代码 ver 1.1</a></li><li><a href="#%E4%BB%A3%E7%A0%81-ver-1.2">代码 ver 1.2</a></li></ol></nav><h2 id="%E7%AE%80%E5%8D%95%E6%80%9D%E8%80%83" tabindex="-1">简单思考</h2>
<p>回退旅行法一定最后是棵树, 一定有一个有个条边没有走</p>
<ul>
<li>简单想法: 枚举端口环上的边</li>
<li>枚举超时,优化
<ul>
<li>找性质 : 只有最环上的时候才可能决定回退(不走某条边)</li>
<li>想到性质: 贪心</li>
<li>分情况讨论 + 对拍</li>
</ul>
</li>
</ul>
<h2 id="%E5%8E%9F%E7%89%88%E7%9A%84%E4%BB%A3%E7%A0%81" tabindex="-1">原版的代码</h2>
<p>枚举环上的那条边不走,然后变成一个树,然后dfs</p>
<p>这个题目的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> 解法,参看 <a href="/problems/luogu/P5022/index.html" class="problem-link" target="_blank">luogu-P5022 [NOIP 2018 提高组] 旅行 tags: []</a></p>
<h2 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90" tabindex="-1">题目解析</h2>
<p><code>n = 5e5</code>,也就是说我们不能删边那枚举:</p>
<ul>
<li><strong>一定是根据某种规则,某种情况,某种条件,知道环上的那条边不走</strong>,</li>
<li>构造数据,使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> 的代码进行对拍,不停的优化代码,就出来了</li>
</ul>
<h3 id="%E6%83%85%E5%86%B5-0" tabindex="-1">情况 0</h3>
<div class="graphviz"><pre class="dot">
digraph G {
    label = "Sample 2: Unicyclic Graph (m = n)\nCycle: 2-3-4-5-2\nResult: 1 3 2 4 5 6";
    labelloc = "t";
    // 使用 neato 布局以更好地展示环
    layout = dot; 
    
    node [shape=circle, style=filled, fillcolor=lightyellow];
    
    // 节点
    1 [xlabel="Start"];
    3;
    2;
    4;
    5;
    6;

    // 路径：1 -> 3
    1 -> 3 [color=red, label="①", fontcolor=red, penwidth=2.0];

    // 路径：3 -> 2 (因为 2 < 4)
    3 -> 2 [color=red, label="②", fontcolor=red, penwidth=2.0];

    // 在节点 2，虽然有边连向 5，但为了更早访问到 4 (从3那边)，
    // 我们选择不走 2->5，而是回溯。
    // 这条边 (2, 5) 在 DFS 树中没有被使用（或者理解为回边）
    2 -> 5 [dir=none, style=dashed, color=grey, label="Backtracking\nDecision:\n4 < 5", fontcolor=grey];

    // 回溯到 3 后，走 3 -> 4
    3 -> 4 [color=red, label="③", fontcolor=red, penwidth=2.0];

    // 在节点 4，先走 5 (5 < 6)
    4 -> 5 [color=red, label="④", fontcolor=red, penwidth=2.0];

    // 回溯到 4 后，走 4 -> 6
    4 -> 6 [color=red, label="⑤", fontcolor=red, penwidth=2.0];

    // 物理连接关系补充说明：
    // 实际上 2-5 是相连的，4-5 也是相连的。
    // 在这里 4->5 是树边，2->5 是非树边。
}
</pre></div>
<p>根据样例,可以得知: 如果环上的下一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span></eq>, 比 dfs回溯 的环上的另外一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></eq> 大,就回溯,</p>
<blockquote>
<p>最简单的情况, 环上没有子树, 显然 : 环上的下一个点,比回溯后的子树(环上的另一个点)大的时间,就断开这个边</p>
</blockquote>
<div class="graphviz"><pre class="dot">
graph {
  node [shape=circle, style=filled, fillcolor=lightyellow];
  5[fillcolor=grey]
  3[fillcolor=blue]
  1--2;
  2--x[style=dashed color=grey];
  x--5[color=red penwidth=3 style=dashed label="cut"];
  2--3;
  3--4;
  5--4;
  {
  rank = same; 5; 4;
  }
}
</pre></div>
<h2 id="%E6%80%9D%E8%80%83" tabindex="-1">思考</h2>
<p>现在考虑如果环上的点有子树怎么办:</p>
<blockquote>
<p>[规则1] !!! 一个重要的规则: u 是环上的点, 如果 从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 回溯(也就是 <code>(u,v)</code>边是断开的,v也在环上) ,那么一定会把u的子树上的点 遍历完,才会回溯.</p>
</blockquote>
<p>这份解析是基于你提供的博客图片（洛谷 P5049 题解）进行的详细重构。</p>
<p>这道题的难点在于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq> 的情况，也就是<strong>基环树</strong>。
基环树 = 树 + 1条边 = <strong>含有一个环</strong>。</p>
<h3 id="%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5" tabindex="-1">核心策略</h3>
<p>对于基环树，我们的策略是：<strong>在环上找到一条边断开，使其变成一棵树，并且这条断开的边能让剩下的 DFS 序字典序最小。</strong></p>
<p>由于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq> 很大 (<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">5 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></eq>)，我们不能枚举断哪条边（那样是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>）。我们需要在 DFS 遍历环的过程中，使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 的贪心策略<strong>动态决定</strong>是否断开当前环上的边。</p>
<p>当我们处于环上的某个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq>，准备走向环上的下一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 时，我们将 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 与其他邻居的关系分为<strong>三种情况</strong>。</p>
<hr>
<h3 id="%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E5%BD%93%E5%89%8D%E2%80%9C%E6%9C%80%E4%BC%98%E8%A7%A3%E2%80%9D-(ring-edge-is-the-smallest)" tabindex="-1">情况一：环上的边是当前“最优解” (Ring edge is the Smallest)</h3>
<p><strong>描述</strong>：
当我们到达环上节点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 时，它连接着若干个点。如果<strong>环上的下一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 的编号</strong>比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 所有其他未访问的邻居（子树节点）都要<strong>小</strong>。</p>
<p><strong>决策</strong>：
根据贪心原则，为了字典序最小，我们<strong>必须</strong>立刻走环上的这条边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>。没有任何理由回溯或去别的点。</p>
<ul>
<li>当前点：<strong>3</strong></li>
<li>邻居：<strong>4</strong> (环上下一站), <strong>6</strong> (子树), <strong>7</strong> (子树)</li>
<li>比较：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>&lt;</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4 &lt; 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span></eq> 且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">4 &lt; 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq></li>
<li><strong>动作</strong>：毫不犹豫，走 <strong>4</strong>。</li>
</ul>
<blockquote>
<p>因为如果要 断开 <code>E(3,4)</code>这个边, 那么根据 <code>[规则1]</code>, 那么 dfs序的这个位置就是 <code>6</code>, 显然不如 <code>4</code> 好</p>
<p>^–反证法</p>
</blockquote>
<div class="graphviz"><pre class="dot">
digraph Case1 {
    label = "情况一：环边最小 (Case 1)\n3的邻居中，环上的4最小，必须走环";
    labelloc = "t";
    node [shape=circle, style=filled, fillcolor=white];

    // 结构
    1 [label="1\n(Pre)"];
    3 [label="3\n(Current)", fillcolor=lightblue];
  
    // 邻居
    6 [label="6\n(Subtree)"];
    7 [label="7\n(Subtree)"];
    4 [label="4\n(Ring Next)", style=filled, fillcolor=lightgreen];

    // 连接
    1 -> 3 [label="来自"];
    3 -> 4 [label="① min!", color=red, penwidth=2.5];
    3 -> 6;
    3 -> 7;
    3 -> 2;
    2[label="2\nat ring" fillcolor = lightblue]
    
    4->2[constraint=false tailport=s, headport=s style=dashed];

    // 辅助布局
    {rank=same; 4; 6; 7}
}
</pre></div>
<hr>
<h3 id="%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E2%80%9C%E4%B8%AD%E5%BA%B8%E4%B9%8B%E9%80%89%E2%80%9D-(ring-edge-is-neither-smallest-nor-largest)" tabindex="-1">情况二：环上的边是“中庸之选” (Ring edge is neither smallest nor largest)</h3>
<p><strong>描述</strong>：
在节点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq>，环上的下一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> <strong>不是最小的，但也绝对不是最大的</strong>。这意味着 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 至少有一个比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 小的邻居（先走它），也至少有一个比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 大的邻居。</p>
<p><strong>决策</strong>：</p>
<ol>
<li>先访问比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 小的邻居（显然）。</li>
<li>轮到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 时，我们还剩下一个比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> <strong>大</strong>的邻居 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></eq> 等待访问。</li>
<li><strong>关键点</strong>：由于 DFS 的性质，如果我们此时不走 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 而选择回溯，我们并没有真的“离开”节点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq>，因为还有一个更大的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></eq> 没访问呢！我们必须把 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 的所有边处理完才能回溯给父亲。</li>
<li>所以，摆在我们面前的只有两条路：先走 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 还是先走 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></eq>。因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>&lt;</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v &lt; w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></eq>，贪心策略告诉我们：<strong>继续走环，访问 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq></strong>。</li>
</ol>
<p><strong>结论</strong>：只要当前节点还有比环上边更大的子树节点，我们就不能回溯，必须走环。</p>
<ul>
<li>当前点：<strong>3</strong></li>
<li>邻居：<strong>2</strong> (子树), <strong>6</strong> (环上下一站), <strong>7</strong> (子树)</li>
<li>顺序：
<ol>
<li>先走 <strong>2</strong> (最小)。</li>
<li>剩下 <strong>6</strong> (环) 和 <strong>7</strong> (子树)。</li>
<li>必须走 <strong>6</strong>。因为如果想回溯，必须先处理完 <strong>7</strong>，但 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">6 &lt; 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq>，所以先走 6。</li>
</ol>
</li>
</ul>
<blockquote>
<p>还是根据 <code>[规则1]</code>, 如果断开边 <code>E(3,6)</code>,那么 dfs序的这个位置就是 <code>7</code>, 显然不如 <code>6</code> 好</p>
<p>^–反证法</p>
</blockquote>
<div class="graphviz"><pre class="dot">
digraph Case2 {
    label = "情况二：环边居中 (Case 2)\n3的邻居: 2(小) < 6(环) < 7(大)\n必须走环，因为后面还有个更大的7挡着不能回溯";
    labelloc = "t";
    rankdir = LR;
    node [shape=circle, style=filled, fillcolor=white];

    // 结构
    1 [label="1\n(Pre)"];
    3 [label="3\n(Current)", fillcolor=lightblue];
  
    // 邻居
    2 [label="2\n(Subtree)", style=filled, fillcolor=lightgrey];
    6 [label="6\n(Ring Next)", style=filled, fillcolor=lightgreen];
    7 [label="7\n(Subtree)", style=filled, fillcolor=lightgrey];

    // 连接
    1 -> 3;
    3 -> 2 [label="① small", color=green];
    3 -> 6 [label="② mid", color=red, penwidth=2.5];
    3 -> 7 [label="③ large"];

    // 顺序逻辑
    edge[style=invis];
    2 -> 6 -> 7;
}
</pre></div>
<hr>
<h3 id="%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E7%8E%AF%E4%B8%8A%E7%9A%84%E8%BE%B9%E6%98%AF%E2%80%9C%E6%9C%80%E5%A4%A7%2F%E6%9C%80%E5%90%8E%E2%80%9D%E7%9A%84%E9%80%89%E6%8B%A9-(ring-edge-is-the-largest)" tabindex="-1">情况三：环上的边是“最大/最后”的选择 (Ring edge is the Largest)</h3>
<p><strong>描述</strong>：
在节点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq>，我们要么没有其他邻居了，要么其他邻居（子树节点）都比环上的点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 小，并且都已经访问完了。
现在只剩下：<strong>走环上的点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq></strong> 还是 <strong>结束节点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 的访问并回溯</strong>？</p>
<p><strong>决策</strong>：
这是唯一可能“断开环”的地方。我们需要“向后看”。
假设我们<strong>回溯</strong>（即断开 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>），我们将会沿着树往回走。在回溯路径上，我们会遇到的<strong>第一个未访问的节点</strong>是多少？设这个值为 <code>Backtrack_Val</code> (代码中通常用一个变量维护)。</p>
<ul>
<li>如果 <strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>&lt;</mo><mtext>Backtrack_Val</mtext></mrow><annotation encoding="application/x-tex">v &lt; \text{Backtrack\_Val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">Backtrack_Val</span></span></span></span></span></eq></strong>：
走环更划算（字典序更小）。<strong>继续走环</strong>。</li>
<li>如果 <strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>&gt;</mo><mtext>Backtrack_Val</mtext></mrow><annotation encoding="application/x-tex">v &gt; \text{Backtrack\_Val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">Backtrack_Val</span></span></span></span></span></eq></strong>：
回溯更划算。<strong>断开环边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>，立刻回溯</strong>。</li>
</ul>
<h4>Graphviz 图示：情况三</h4>
<ul>
<li>当前点：<strong>3</strong></li>
<li>邻居：<strong>2</strong> (子树, 已访问), <strong>7</strong> (环上下一站)</li>
<li>回溯潜能：假设 1 号点还有个分支连着 <strong>4</strong>。</li>
<li><strong>比较</strong>：
<ul>
<li>选项 A：走环去 <strong>7</strong>。序列：<code>... 3 7 ...</code></li>
<li>选项 B：回溯去 <strong>4</strong>。序列：<code>... 3 (回溯) 4 ...</code></li>
</ul>
</li>
<li><strong>结果</strong>：因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>&gt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">7 &gt; 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></eq>，我们选择 <strong>断开</strong> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>→</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">3 \to 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq>，回溯去找 4。</li>
</ul>
<div class="graphviz"><pre class="dot">
digraph Case3 {
    label = "情况三：环边最大 (Case 3)\n剩环边7 vs 回溯后遇到的4\n因为 7 > 4，所以断开环，回溯！";
    labelloc = "t";
    rankdir = LR;
    node [shape=circle, style=filled, fillcolor=white];

    // 祖先与回溯目标
    1 [label="1\n(Root)"];
    4 [label="4\n(Backtrack\nTarget)", style=filled, fillcolor=yellow];

    // 当前环境
    3 [label="3\n(Current)", fillcolor=lightblue];
    2 [label="2\n(Visited)", style=filled, fillcolor=grey];
  
    // 环的选择
    7 [label="7\n(Ring Next)", style=filled, fillcolor=lightpink];

    // 路径
    1 -> 3;
    1 -> 4 [style=dashed, label="Backtrack\nPath", color=blue];
  
    3 -> 2 [label="① Done", color=grey];
  
    // 关键决策
    3 -> 7 [label="7 > 4\nCUT!", color=red, style=dotted, penwidth=3];
    3 -> 1 [label="Backtrack", color=blue];

    {rank=same; 3; 4}
}
</pre></div>
<h3 id="%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AF%B9%E5%BA%94" tabindex="-1">总结与代码对应</h3>
<ul>
<li><strong>情况一 &amp; 二</strong>：对应代码中 <code>dfs</code> 正常遍历部分。只要有比环边大的子树存在，或者环边本来就很小，就正常进。</li>
<li><strong>情况三</strong>：对应代码中 <code>dfs</code> 里的特殊判断。
<ul>
<li>代码逻辑：在进入环之前，会记录一个 <code>tmp</code>（或者叫 <code>min_future</code>），这个 <code>tmp</code> 是我们在之前的节点（比如父节点）放弃走的那个“稍大一点的子树节点”。</li>
<li>当我们在环上走到只剩环边时，比较 <code>Ring_Node</code> 和 <code>tmp</code>。</li>
<li>如果 <code>Ring_Node &gt; tmp</code>，标记 <code>flag = true</code>（表示环已断开），并 <code>break</code>（不再走环边，回溯）。</li>
</ul>
</li>
</ul>
<p>这就是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 解决基环树字典序最小问题的核心逻辑：<strong>只在环边是当前节点最大选择，且比回溯后的“备胎”还要大时，才执行断边操作。</strong></p>
<blockquote>
<p>!!! 注意 ⚠️</p>
<p>最终的代码, 根本不需要: <strong>只在环边是当前节点最大选择，且比回溯后的“备胎”还要大时，才执行断边操作。</strong>
因为这个条件太复杂</p>
<p>真时的代码上的使用条件: 环上的点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 的下一个点 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> ,比回溯备胎大的时候,就回溯</p>
</blockquote>
<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>
<p>一个考查细心程度的题目,想象力,画图能力</p>
<h2 id="%E4%BB%A3%E7%A0%81" tabindex="-1">代码</h2>
<h2 id="%E5%8F%82%E7%9C%8B" tabindex="-1">参看</h2>
<ul>
<li><a href="https://www.luogu.com.cn/article/1g2bdbj2">题解 P5049 【旅行（数据加强版）】 - 洛谷专栏</a></li>
</ul>
<p>这是一个非常好的尝试。你原来的代码使用的是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 的暴力删边法（枚举每一条环上的边，删掉，然后跑一次 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 的 DFS），这对于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>5005</mn></mrow><annotation encoding="application/x-tex">N \le 5005</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5005</span></span></span></span></eq> 的普通版是可行的，但对于 <strong>加强版 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>500</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">N \le 500,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">500</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></eq></strong> 肯定会超时 (TLE)。</p>
<p>为了通过加强版，我们需要使用 <strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 的贪心策略</strong>。</p>
<h3 id="%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF" tabindex="-1">核心思路</h3>
<p>我们不需要真的枚举删除每一条边。我们只需要在 <strong>第一次 DFS 遍历</strong> 的过程中，<strong>动态地</strong> 决定哪条边需要被“断开”。</p>
<p>根据刚才图片的解析，决策逻辑如下：</p>
<p>当我们在环上，从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 准备走向 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 时：</p>
<ol>
<li>计算如果我们<strong>不走</strong> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>（即回头），紧接着能访问到的最小点是谁？记为 <code>next_candidate</code>。</li>
<li>如果 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>&gt;</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">v &gt; next\_candidate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></eq>，说明现在的路不如回头的路，<strong>断开 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq></strong>，并且把 <code>broken</code> 标记设为 <code>true</code>（之后不再进行断边判断）。</li>
<li>否则，继续走 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>。</li>
</ol>
<h3 id="%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81-(c%2B%2B)" tabindex="-1">修改后的代码 (C++)</h3>
<p>为了适应 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>500</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">500,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">500</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></eq> 的数据量，我做了一些必要的优化：</p>
<ol>
<li><strong>数组大小</strong>：改为 <code>500005</code>。</li>
<li><strong>邻接表</strong>：去掉了 <code>edge</code> 结构体中的 <code>id</code>，因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 做法不需要边的 ID，只需要知道点是否在环上。</li>
<li><strong>流程</strong>：
<ul>
<li><code>init()</code>: 建图并排序。</li>
<li><code>find_ring()</code>: 标记哪些点在环上 (<code>on_ring</code> 数组)。</li>
<li><code>dfs()</code>: 一边遍历输出，一边进行贪心断边判断。</li>
</ul>
</li>
</ol>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br></div>
        <code><span class="token comment">/**
 * Author by Rainboy blog: https://rainboylv.com github : https://github.com/rainboylvx
 * Optimized for P5049 Travel Enhanced
 */</span>
#include <span class="token operator">&lt;</span>bits<span class="token operator">/</span>stdc<span class="token operator">++</span><span class="token punctuation">.</span>h<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>
using namespace std<span class="token punctuation">;</span>

<span class="token comment">// 1. 数据范围必须开大到 500005</span>
const int maxn <span class="token operator">=</span> <span class="token number">500005</span><span class="token punctuation">;</span> 

int n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>int<span class="token operator">></span> adj<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 邻接表，只需要存点即可</span>
bool on_ring<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 标记点是否在环上</span>
int parent<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 找环用的父节点记录</span>
bool vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 访问标记</span>
bool found_loop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 是否找到环的标记</span>
bool broken <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token comment">// 标记是否已经执行过“断边”操作</span>
vector<span class="token operator">&lt;</span>int<span class="token operator">></span> ans<span class="token punctuation">;</span>         <span class="token comment">// 存储最终序列</span>

void <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cin <span class="token operator">></span><span class="token operator">></span> n <span class="token operator">></span><span class="token operator">></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>
        cin <span class="token operator">></span><span class="token operator">></span> u <span class="token operator">></span><span class="token operator">></span> v<span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 关键：对邻接表排序，保证优先访问编号小的点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 第一步：找环并标记 on_ring 数组</span>
void <span class="token function">get_ring_dfs</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span> int fa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>found_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> fa<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int v <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 找到返祖边，说明发现环了</span>
            found_loop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            int curr <span class="token operator">=</span> u<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                on_ring<span class="token punctuation">[</span>curr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                curr <span class="token operator">=</span> parent<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            on_ring<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 别忘了 v 也是环上的点</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">get_ring_dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>found_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 第二步：贪心 DFS
 * u: 当前节点
 * outside_target: 如果从 u 回溯（或者在 u 的所有子树遍历完后），
 * 紧接着会访问的那个“备胎”节点的值。
 */</span>
void <span class="token function">dfs</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span> int outside_target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录路径</span>

    int sz <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int v <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 计算 next_candidate (回溯后的最佳备胎)</span>
        <span class="token comment">// 1. 如果 v 不是 u 的最后一个邻居，那么如果不走 v (或走完 v)，下一个备选是 adj[u][i+1]</span>
        <span class="token comment">// 2. 如果 v 是 u 的最后一个邻居，那么就要看 u 的父亲传下来的 outside_target</span>
        int next_candidate<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            next_candidate <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            next_candidate <span class="token operator">=</span> outside_target<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// --- 核心贪心断边逻辑 ---</span>
        <span class="token comment">// 1. 我们还没有断过边 (!broken)</span>
        <span class="token comment">// 2. 这条边在环上 (on_ring[u] &amp;&amp; on_ring[v])</span>
        <span class="token comment">// 3. 走 v 导致的值 > 回头的最佳备选值 (v > next_candidate)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>broken <span class="token operator">&amp;&amp;</span> on_ring<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> on_ring<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">></span> next_candidate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            broken <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记断边：假装这条边不存在</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token comment">// 跳过 v，不再 dfs(v)，直接进入下一次循环或函数结束(回溯)</span>
        <span class="token punctuation">}</span>

        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> next_candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况一：树，不需要找环，直接 DFS</span>
        <span class="token comment">// 0x3f3f3f3f 是一个无穷大的数，表示没有回溯限制</span>
        <span class="token function">fill</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span> vis <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况二：基环树</span>
        <span class="token comment">// 1. 先找环，标记 on_ring</span>
        <span class="token function">fill</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span> vis <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">get_ring_dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. 清空 vis 数组，准备正式遍历</span>
        <span class="token function">fill</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span> vis <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 3. 贪心 DFS</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 输出结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<h3 id="%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90" tabindex="-1">代码修改要点解析</h3>
<ol>
<li><strong>数据结构</strong>：
<ul>
<li>我将 <code>maxn</code> 增加到了 <code>500005</code>，防止数组越界。</li>
<li>移除了 <code>adj</code> 中的 <code>id</code> 和 <code>del_edge</code> 变量，因为我们不是物理删除边，而是逻辑“跳过”。</li>
</ul>
</li>
<li><strong>找环逻辑 (<code>get_ring_dfs</code>)</strong>：
<ul>
<li>你的原代码 <code>vis[u] = 2</code> 的思路是对的，但我换成了更通用的 <code>parent</code> 数组回溯法。</li>
<li>当遇到 <code>vis[v] == true</code> 时，说明找到了环的闭合处，此时利用 <code>parent</code> 数组一路往回找，直到遇到 <code>v</code>，把路径上所有点标记为 <code>on_ring = true</code>。</li>
</ul>
</li>
<li><strong>贪心 DFS (<code>dfs</code>)</strong>：
<ul>
<li>引入了 <code>outside_target</code> 参数。这是实现 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 算法的关键。它代表“如果不走当前这条路，或者走完这条路后，我们要去哪里”。</li>
<li><strong>断边判断</strong>：<code>if (!broken &amp;&amp; on_ring[u] &amp;&amp; on_ring[v] &amp;&amp; v &gt; next_candidate)</code>。
<ul>
<li>这行代码直接对应了图片解析中的 <strong>情况三</strong>。</li>
<li>一旦触发，<code>broken = true</code>，并且 <code>continue</code>，相当于这辈子不再走 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 这条边了，实现了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 复杂度的最优解查找。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="%E4%BB%A3%E7%A0%81-ver-1" tabindex="-1">代码 ver 1</h2>
<p>此代码有bug</p>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br><span class="line-number">205</span><br></div>
        <code><span class="token comment">/**
 * Author by Rainboy blog: https://rainboylv.com github : https://github.com/rainboylvx
 * rbook: -> https://rbook.roj.ac.cn  https://rbook2.roj.ac.cn
 * date: 2026-01-10 08:58:46
 */</span>
#include <span class="token operator">&lt;</span>algorithm<span class="token operator">></span>
#include <span class="token operator">&lt;</span>bits<span class="token operator">/</span>stdc<span class="token operator">++</span><span class="token punctuation">.</span>h<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>
using namespace std<span class="token punctuation">;</span>
typedef  long long ll<span class="token punctuation">;</span>
typedef  unsigned long long ull<span class="token punctuation">;</span>

const int maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
const int maxe <span class="token operator">=</span> <span class="token number">3e6</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
const int mod <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>


int n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>
int a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
int del_edge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//枚举删除的边</span>

typedef std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>int<span class="token punctuation">,</span>int<span class="token operator">></span> edge<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> adj<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> edges<span class="token punctuation">;</span>

<span class="token comment">// 边是否在环上</span>
bool on_ring_edge<span class="token punctuation">[</span>maxe<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bool on_ring_node<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>


void <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> n <span class="token operator">></span><span class="token operator">></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->m</span>
    <span class="token punctuation">{</span>
        int u<span class="token punctuation">,</span>v<span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> u <span class="token operator">></span><span class="token operator">></span> v<span class="token punctuation">;</span>
        <span class="token comment">// debug</span>
        #ifdef DEBUG
        
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"id : "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" -> "</span>  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> v <span class="token punctuation">;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
        #endif

        <span class="token comment">//next点 ,边的编号</span>
        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>u<span class="token punctuation">,</span>v<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>v<span class="token punctuation">,</span>i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>u<span class="token punctuation">,</span>i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->n</span>
    <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sort</span><span class="token punctuation">(</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> ans<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> tmp_ans<span class="token punctuation">;</span>

<span class="token comment">// 回溯法找环: 原理: 找到环上的点,立刻回溯</span>

struct p <span class="token punctuation">{</span>int fa<span class="token punctuation">,</span>eid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
p parent<span class="token punctuation">[</span>maxe<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bool vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
bool find_loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
void <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> find_loop <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; "dfs " &lt;&lt; u &lt;&lt; "\n";</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>eid<span class="token punctuation">]</span> <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            find_loop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

            int cur <span class="token operator">=</span> u<span class="token punctuation">;</span>

            on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                int eid <span class="token operator">=</span> parent<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>eid<span class="token punctuation">;</span>
                on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                cur <span class="token operator">=</span> parent<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>fa<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>u<span class="token punctuation">,</span>eid<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> find_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


void <span class="token function">dfs</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    tmp_ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span> auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>id<span class="token punctuation">]</span> <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> id <span class="token operator">==</span> del_edge<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 找倒要删除的边</span>
bool <span class="token function">find_del_edge</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">,</span>int target<span class="token punctuation">)</span> <span class="token punctuation">{</span>

#ifdef DEBUG
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" target "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> target <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
#endif
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这个时候,</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> del_edge <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> del_edge <span class="token operator">=</span> eid<span class="token punctuation">;</span>

            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 是不是最大的点</span>
        bool last_v <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">==</span> v<span class="token punctuation">;</span>

        <span class="token comment">// 记录 下一个回溯会到达的点</span>
        int next_point <span class="token operator">=</span> target<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring_node<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>last_v <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            next_point <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
            <span class="token comment">// std::cout &lt;&lt; u &lt;&lt; " next_point " &lt;&lt; next_point &lt;&lt; "\n";</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//找到删除的边</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> last_v <span class="token operator">&amp;&amp;</span> on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">></span> next_point<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            del_edge <span class="token operator">=</span> eid<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">find_del_edge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span>next_point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

signed main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 找环上的边</span>
    <span class="token comment">// 1. topsort</span>
    <span class="token comment">// 2. dfs法 -- >这里使用</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> m <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> tmp_ans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// cout &lt;&lt; " on_ring_edge: ";</span>


    <span class="token comment">// 记录在环上的点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->m</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
#ifdef DEBUG
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
#endif
            auto <span class="token punctuation">[</span>u<span class="token punctuation">,</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            on_ring_node<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            on_ring_node<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

#ifdef DEBUG
    
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

    <span class="token comment">// debug: 输出环上的边</span>
    <span class="token comment">// for( auto &amp; i : loop ) {</span>
    <span class="token comment">//     std::cout &lt;&lt; "id : "  &lt;&lt; i &lt;&lt;   endl;</span>
    <span class="token comment">// }</span>
#endif
    <span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">find_del_edge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#ifdef DEBUG
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"del_edge = "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> del_edge  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
#endif

    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> tmp_ans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    

    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<p>使之错误的数据如下:</p>
<p>这个数据的构造逻辑是：利用你代码中 adj 包含父节点这一特性，构造一个场景，使得 父节点编号 &gt; 环上的下一个节点编号，从而导致 last_v 判定失效，跳过了本该进行的“断边”判断。</p>
<pre><code>5 5
1 5
5 2
5 3
5 4
2 4
</code></pre>
<p>这是一个 <strong><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">N=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span></eq></strong> 的精简数据，可以 100% 稳定卡掉你的代码。</p>
<p>你之前的测试之所以通过，是因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></eq> 的数据有些巧合，或者你的代码在特定分支顺序下碰巧蒙对了。</p>
<p>但这个数据利用了 <strong><code>fa &gt; v</code></strong> 的特性，构造了一个完美的陷阱。</p>
<h3 id="1.-%E5%BF%85%E6%9D%80-hack-%E6%95%B0%E6%8D%AE-(input)" tabindex="-1">1. 必杀 Hack 数据 (Input)</h3>
<p>Plaintext</p>
<pre><code>5 5
1 5
5 2
5 3
5 4
2 4
</code></pre>
<h3 id="2.-%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94" tabindex="-1">2. 结果对比</h3>
<ul>
<li>
<p><strong>期望输出 (Correct Output)</strong>:</p>
<p>Plaintext</p>
<pre><code>1 5 2 3 4
</code></pre>
<p><em>(最优策略：在 2 处断开 2-4，回溯到 5，先走 3，最后走 4)</em></p>
</li>
<li>
<p><strong>你的代码输出 (Your Output)</strong>:</p>
<p>Plaintext</p>
<pre><code>1 5 2 4 3
</code></pre>
<p><em>(错误策略：没有断开 2-4，直接走了 4，导致第 4 位是 4，比正确答案的 3 大)</em></p>
</li>
</ul>
<hr>
<h3 id="3.-%E9%94%99%E8%AF%AF%E5%9B%BE%E8%A7%A3%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">3. 错误图解与深度分析</h3>
<p>这个图的结构非常简单，但杀伤力极大。</p>
<p><strong>图结构</strong>：</p>
<ul>
<li><strong>入口</strong>：<code>1</code> 连接到枢纽 <code>5</code>。</li>
<li><strong>枢纽 5</strong>：连接了 <code>2</code>、<code>3</code>、<code>4</code>。</li>
<li><strong>环路</strong>：<code>5 - 2 - 4 - 5</code>。</li>
</ul>
<p><strong>代码执行流程分析</strong>：</p>
<ol>
<li><strong>DFS(1)</strong>：直接走向 <code>5</code>。</li>
<li><strong>DFS(5)</strong>：
<ul>
<li>邻居有 <code>2, 3, 4</code>（1 已访问）。</li>
<li>按贪心顺序，先走最小的 <strong><code>2</code></strong>。</li>
<li><strong>回溯目标 (Target)</strong>：如果在 <code>2</code> 处断边回溯，<code>5</code> 的下一个邻居是 <strong><code>3</code></strong>。</li>
</ul>
</li>
<li><strong>事故现场：节点 2</strong>
<ul>
<li>当前节点 <code>u = 2</code>。</li>
<li>父节点 <code>fa = 5</code>。</li>
<li>环上邻居 <code>v = 4</code>。</li>
<li><strong>adj[2] 排序后</strong>：<code>{4, 5}</code> （因为 <code>4 &lt; 5</code>）。</li>
</ul>
</li>
<li><strong>你的代码逻辑漏洞</strong>：
<ul>
<li>遍历到 <code>v = 4</code>。</li>
<li>检查 <code>last_v</code>：<code>adj[2].back()</code> 是 <code>5</code> (父节点)。</li>
<li><code>4 != 5</code>，所以 <strong><code>last_v</code> 为 <code>false</code></strong>。</li>
<li><strong>致命错误</strong>：你的代码直接 <code>continue</code> 跳过了断边判断！</li>
<li><strong>正确逻辑</strong>：应该比较 <code>v(4)</code> 和 <code>target(3)</code>。因为 <code>4 &gt; 3</code>，应该<strong>断开 2-4</strong>。</li>
</ul>
</li>
<li><strong>结局</strong>：
<ul>
<li><strong>你的代码</strong>：走了 <code>2 -&gt; 4</code>。路径变成 <code>1-5-2-4...</code>，最后才访问 <code>3</code>。</li>
<li><strong>最优解</strong>：断开 <code>2-4</code>，回溯到 5，走 <code>3</code>，再走 <code>4</code>。路径 <code>1-5-2-3-4</code>。</li>
</ul>
</li>
</ol>
<h3 id="4.-%E6%9C%80%E7%BB%88%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE" tabindex="-1">4. 最终修复建议</h3>
<p>请彻底删除 <code>last_v</code>。只要是环上的边，就必须判断。</p>
<h2 id="%E4%BB%A3%E7%A0%81-ver-1.1" tabindex="-1">代码 ver 1.1</h2>
<blockquote>
<p>修复了 ver 1 的 环上的点是last(是父亲的最大的一个孩子), 但实际adj存储的里面含有fa</p>
</blockquote>
<blockquote>
<p>不好的地方: 基环树 找环的代码 太复杂, 啰唆的on_ring_edge</p>
</blockquote>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br><span class="line-number">205</span><br><span class="line-number">206</span><br><span class="line-number">207</span><br><span class="line-number">208</span><br><span class="line-number">209</span><br></div>
        <code><span class="token comment">/**
 * Author by Rainboy blog: https://rainboylv.com github : https://github.com/rainboylvx
 * rbook: -> https://rbook.roj.ac.cn  https://rbook2.roj.ac.cn
 * date: 2026-01-10 08:58:46
 */</span>
#include <span class="token operator">&lt;</span>algorithm<span class="token operator">></span>
#include <span class="token operator">&lt;</span>bits<span class="token operator">/</span>stdc<span class="token operator">++</span><span class="token punctuation">.</span>h<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>
using namespace std<span class="token punctuation">;</span>
typedef  long long ll<span class="token punctuation">;</span>
typedef  unsigned long long ull<span class="token punctuation">;</span>

const int maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
const int maxe <span class="token operator">=</span> <span class="token number">3e6</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
const int mod <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>


int n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>
int a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
int del_edge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//枚举删除的边</span>

typedef std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>int<span class="token punctuation">,</span>int<span class="token operator">></span> edge<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> adj<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> edges<span class="token punctuation">;</span>

<span class="token comment">// 边是否在环上</span>
bool on_ring_edge<span class="token punctuation">[</span>maxe<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bool on_ring_node<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>


void <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> n <span class="token operator">></span><span class="token operator">></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->m</span>
    <span class="token punctuation">{</span>
        int u<span class="token punctuation">,</span>v<span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> u <span class="token operator">></span><span class="token operator">></span> v<span class="token punctuation">;</span>
        <span class="token comment">// debug</span>
        #ifdef DEBUG
        
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"id : "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" -> "</span>  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> v <span class="token punctuation">;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
        #endif

        <span class="token comment">//next点 ,边的编号</span>
        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>u<span class="token punctuation">,</span>v<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>v<span class="token punctuation">,</span>i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>u<span class="token punctuation">,</span>i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->n</span>
    <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sort</span><span class="token punctuation">(</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> ans<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> tmp_ans<span class="token punctuation">;</span>

<span class="token comment">// 回溯法找环: 原理: 找到环上的点,立刻回溯</span>

struct p <span class="token punctuation">{</span>int fa<span class="token punctuation">,</span>eid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
p parent<span class="token punctuation">[</span>maxe<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bool vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
bool find_loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
void <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> find_loop <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; "dfs " &lt;&lt; u &lt;&lt; "\n";</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>eid<span class="token punctuation">]</span> <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            find_loop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

            int cur <span class="token operator">=</span> u<span class="token punctuation">;</span>

            on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                int eid <span class="token operator">=</span> parent<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>eid<span class="token punctuation">;</span>
                on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                cur <span class="token operator">=</span> parent<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>fa<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>u<span class="token punctuation">,</span>eid<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> find_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


void <span class="token function">dfs</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    tmp_ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span> auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>id<span class="token punctuation">]</span> <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> id <span class="token operator">==</span> del_edge<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 找倒要删除的边</span>
bool <span class="token function">find_del_edge</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">,</span>int target<span class="token punctuation">)</span> <span class="token punctuation">{</span>

#ifdef DEBUG
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" target "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> target <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
#endif
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        auto <span class="token punctuation">[</span>v<span class="token punctuation">,</span>eid<span class="token punctuation">]</span> <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这个时候,</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> del_edge <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> del_edge <span class="token operator">=</span> eid<span class="token punctuation">;</span>

            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 是不是最大的点</span>
        <span class="token comment">// bool last_v = adj[u].back().first == v;</span>
        <span class="token comment">// fix: 不要 last_v 只要是环上的边都要判断</span>

        <span class="token comment">// 记录 下一个回溯会到达的点</span>
        int next_point <span class="token operator">=</span> target<span class="token punctuation">;</span>

        <span class="token comment">// u 在环上</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring_node<span class="token punctuation">[</span>u<span class="token punctuation">]</span>  <span class="token operator">&amp;&amp;</span> i <span class="token operator">+</span> <span class="token number">1</span>  <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> vis<span class="token punctuation">[</span>adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            next_point <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
            <span class="token comment">// std::cout &lt;&lt; u &lt;&lt; " next_point " &lt;&lt; next_point &lt;&lt; "\n";</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 环上的点都要判断</span>
        <span class="token comment">//找到删除的边</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring_edge<span class="token punctuation">[</span>eid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">></span> next_point<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            del_edge <span class="token operator">=</span> eid<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">find_del_edge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span>next_point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

signed main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 找环上的边</span>
    <span class="token comment">// 1. topsort</span>
    <span class="token comment">// 2. dfs法 -- >这里使用</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span> m <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> tmp_ans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// cout &lt;&lt; " on_ring_edge: ";</span>


    <span class="token comment">// 记录在环上的点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->m</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
#ifdef DEBUG
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
#endif
            auto <span class="token punctuation">[</span>u<span class="token punctuation">,</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            on_ring_node<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            on_ring_node<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

#ifdef DEBUG
    
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

    <span class="token comment">// debug: 输出环上的边</span>
    <span class="token comment">// for( auto &amp; i : loop ) {</span>
    <span class="token comment">//     std::cout &lt;&lt; "id : "  &lt;&lt; i &lt;&lt;   endl;</span>
    <span class="token comment">// }</span>
#endif
    <span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">find_del_edge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#ifdef DEBUG
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"del_edge = "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> del_edge  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
#endif

    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> tmp_ans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    

    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>
<h2 id="%E4%BB%A3%E7%A0%81-ver-1.2" tabindex="-1">代码 ver 1.2</h2>
<blockquote>
<ol>
<li>去除啰唆的 on_ring_edge</li>
<li>简化了 find_loop</li>
<li>添加详细的注释</li>
</ol>
</blockquote>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br></div>
        <code><span class="token comment">/**
 * Author by Rainboy blog: https://rainboylv.com github : https://github.com/rainboylvx
 * rbook: -> https://rbook.roj.ac.cn  https://rbook2.roj.ac.cn
 * date: 2026-01-10 21:18:55
 * desc: 对1.1.cpp 的复刻: 优化, 不用 on_ring_edge, 
 * 使用最简单的dfs 找环上所有点的代码
 * * 核心思路：
 * 1. 对于树 (m=n-1)，贪心策略是每次走编号最小的子节点。
 * 2. 对于基环树 (m=n)，需要断掉环上的一条边使其变为树。
 * 3. 策略：当我们在环上从 u 走向 v 时，如果 v 的值比“如果我们此时回头能访问到的最小点(target)”还要大，
 * 说明走 v 这条路不划算，应该在这里断开 (u, v)。
 */</span>
#include <span class="token operator">&lt;</span>bits<span class="token operator">/</span>stdc<span class="token operator">++</span><span class="token punctuation">.</span>h<span class="token operator">></span>
using namespace std<span class="token punctuation">;</span>
typedef  long long ll<span class="token punctuation">;</span>
typedef  unsigned long long ull<span class="token punctuation">;</span>

const int maxn <span class="token operator">=</span> <span class="token number">5e5</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token comment">// --- 存图</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> adj<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 添加无向边</span>
void <span class="token function">add_edge</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// --- 存图 -- end</span>

int n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>
bool on_ring<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 标记点u是否在环上</span>
int del_edge<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 记录最终决定逻辑删除的边 (del_edge[0], del_edge[1])</span>

<span class="token comment">// 判断当前边 (u, v) 是否是被标记为删除的那条边</span>
inline bool <span class="token function">is_del_edge</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> u <span class="token operator">==</span> del_edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">==</span> del_edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> u <span class="token operator">==</span> del_edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">==</span> del_edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 初始化函数：读入并预处理</span>
void <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> n <span class="token operator">></span><span class="token operator">></span> m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->m</span>
    <span class="token punctuation">{</span>
        int u<span class="token punctuation">,</span>v<span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cin <span class="token operator">></span><span class="token operator">></span> u <span class="token operator">></span><span class="token operator">></span> v<span class="token punctuation">;</span>
        <span class="token function">add_edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 关键步骤：对每个点的邻接表进行排序</span>
    <span class="token comment">// 保证在 DFS 遍历时，总是优先尝试访问编号更小的节点，满足字典序最小的要求</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->n</span>
    <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sort</span><span class="token punctuation">(</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


int parent<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 记录 DFS 路径上的父节点，用于回溯找环</span>
bool finded_loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 标记是否已经找到了环</span>
bool vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 访问标记</span>

<span class="token comment">// 找环函数：利用 DFS 找到基环树中唯一的环，并标记环上的点</span>
void <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> finded_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span> auto v <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa <span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 防止走回头路</span>

        <span class="token comment">// 如果访问到了已经访问过的点，说明找到了环（返祖边）</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            finded_loop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

            int cur <span class="token operator">=</span> u<span class="token punctuation">;</span>
            on_ring<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标记 v 在环上</span>
            <span class="token comment">// 回溯 parent 数组，将环路径上的点全部标记</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span> cur <span class="token operator">!=</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                on_ring<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                cur <span class="token operator">=</span> parent<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span> <span class="token comment">// 记录父节点</span>
        <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> finded_loop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> ans<span class="token punctuation">;</span> <span class="token comment">// 存储最终的遍历序列</span>
<span class="token comment">// 最终的遍历函数：生成答案序列</span>
void <span class="token function">dfs</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span> auto v <span class="token punctuation">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果遇到被标记删除的边，则跳过不走（物理断边效果）</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">is_del_edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 * 核心贪心函数：寻找应该断开哪条环边
 * u: 当前节点
 * fa: 父节点
 * target: “后悔药”值。即如果我不走当前的 v，而是回溯(回头)，紧接着能访问到的最小节点值是多少。
 */</span>
bool <span class="token function">find_del_edge</span><span class="token punctuation">(</span>int u<span class="token punctuation">,</span>int fa<span class="token punctuation">,</span>int target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        int v <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 特殊情况：如果再次访问到了已访问过的点（说明绕环一圈回到了环的另一端）</span>
        <span class="token comment">// 此时默认这条边就是最后闭合环的边，暂时标记为删除对象</span>
        <span class="token comment">// 如果后面没有触发更优的断边条件，就断这一条</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            del_edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
            del_edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 计算新的 target (回溯后能到达的最佳备选点)</span>
        <span class="token comment">// 初始继承自父节点传下来的 target</span>
        int next_point <span class="token operator">=</span> target<span class="token punctuation">;</span>

        <span class="token comment">// 只有当前点在环上时，才需要更新 target</span>
        <span class="token comment">// 因为只有在环上我们才有“回头”的选择权</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 u 还有下一个邻居（且不是父节点），那么如果不走 v，回头后紧接着就会走这个邻居</span>
            <span class="token comment">// 注意：adj 已经排序过，所以 adj[u][i+1] 是比 v 大的最小邻居</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> i<span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> fa<span class="token punctuation">)</span>
                next_point <span class="token operator">=</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// --- 贪心决策核心 ---</span>
        <span class="token comment">// 1. 当前边 (u, v) 是环上的边 (u和v都在环上)</span>
        <span class="token comment">// 2. 目标点 v 的值 > 回溯后的备选点 next_point</span>
        <span class="token comment">// 含义：眼前这条路(v)太大了，不如回头去走那个更小的(next_point)，所以在这里断开最划算。</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>on_ring<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>  on_ring<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> v <span class="token operator">></span> next_point<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            del_edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
            del_edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 找到了最优断点，直接返回</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 继续递归寻找</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">find_del_edge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span> next_point<span class="token punctuation">)</span> <span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    
<span class="token punctuation">}</span>

signed main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 情况1：这是一棵普通的树 (边数 = 点数 - 1)</span>
    <span class="token comment">// 直接 DFS 即可，因为不需要断边</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> n <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> ans<span class="token punctuation">)</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 情况2：基环树 (边数 = 点数)</span>
    
    <span class="token comment">// 第一步：找出环上的所有点</span>
    <span class="token function">dfs_find_loop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    #ifdef DEBUG
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"on_ring node :"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span><span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token comment">// i: 1->n</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> on_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    #endif

    <span class="token comment">// 第二步：运行贪心逻辑，找到需要断开的那条边</span>
    <span class="token comment">// 初始 target 设为无穷大，因为根节点无法回溯</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">find_del_edge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">// 第三步：利用找到的 del_edge，逻辑断开该边，进行最终的 DFS 输出序列</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> auto u <span class="token punctuation">:</span> ans<span class="token punctuation">)</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> u <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code>
    </pre>
</div>

</div>

<script type="module">
  import { instance } from "/js/viz.js";

  // Viz.instance().then(viz => {
  //   document.body.appendChild(viz.renderSVGElement("digraph { a -> b }"))
  // });
  // 假设你通过 npm 安装并打包了，或者直接引用 CDN
  // 如果是本地文件: import { instance } from "./path/to/viz-js/index.js";
  // import { instance } from "https://cdn.jsdelivr.net/npm/@viz-js/viz@3.2.4/+esm";

  async function renderAllGraphs() {
    try {
      // 1. 初始化 Viz 实例 (加载 WASM)
      const viz = await instance();

      // 2. 选择所有需要渲染的代码块
      // markdown-it 默认生成 <pre><code class="language-dot">...</code></pre>
      const codes = document.querySelectorAll('pre.dot, pre.graphviz');

      // 3. 遍历并处理
      codes.forEach(codeElement => {
        const preElement = codeElement.parentElement; // 获取外层的 <pre>
        const sourceCode = codeElement.textContent;   // 获取 DOT 源码

        try {
          // 4. 渲染 SVG DOM 元素
          const svgElement = viz.renderSVGElement(sourceCode);

          // 5. 原位替换：用生成的 SVG 替换掉原本的 <pre> 标签
          // 这样图表就会出现在原本代码所在的位置
          codeElement.replaceWith(svgElement);

        } catch (renderError) {
          console.error("Graphviz 渲染失败:", renderError);

          // 可选：在页面上显示错误信息，而不是让它崩溃
          const errorDiv = document.createElement('div');
          errorDiv.className = 'viz-error';
          errorDiv.innerText = `渲染错误: ${renderError.message}`;
          preElement.replaceWith(errorDiv);
        }
      });

    } catch (err) {
      console.error("Viz 实例初始化失败:", err);
    }
  }

  // 执行渲染
  renderAllGraphs();
</script> 
    </div>

</article>

    </main>
    
    <footer class="site-footer">
    <div class="footer-content">
        <p>&copy; 2024 rainboy. All rights reserved. last build time </p>
        <p class="license">内容遵循 <a style="text-decoration:none;" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
            <img decoding="async" loading="lazy" src="/ccbyncsa.png" width="65" height="auto" style="display:inline-block;">
        </a> 协议</p>
        <p class="powered-by">Powered by <a href="https://github.com/rainboyOJ/rbook_nunjucks" target="_blank"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTIgMkExMCAxMCAwIDAgMCAyIDEyYzAgNC40MiAyLjg3IDguMTcgNi44NCA5LjVjLjUuMDguNjYtLjIzLjY2LS41di0xLjY5Yy0yLjc3LjYtMy4zNi0xLjM0LTMuMzYtMS4zNGMtLjQ2LTEuMTYtMS4xMS0xLjQ3LTEuMTEtMS40N2MtLjkxLS42Mi4wNy0uNi4wNy0uNmMxIC4wNyAxLjUzIDEuMDMgMS41MyAxLjAzYy44NyAxLjUyIDIuMzQgMS4wNyAyLjkxLjgzYy4wOS0uNjUuMzUtMS4wOS42My0xLjM0Yy0yLjIyLS4yNS00LjU1LTEuMTEtNC41NS00LjkyYzAtMS4xMS4zOC0yIDEuMDMtMi43MWMtLjEtLjI1LS40NS0xLjI5LjEtMi42NGMwIDAgLjg0LS4yNyAyLjc1IDEuMDJjLjc5LS4yMiAxLjY1LS4zMyAyLjUtLjMzczEuNzEuMTEgMi41LjMzYzEuOTEtMS4yOSAyLjc1LTEuMDIgMi43NS0xLjAyYy41NSAxLjM1LjIgMi4zOS4xIDIuNjRjLjY1LjcxIDEuMDMgMS42IDEuMDMgMi43MWMwIDMuODItMi4zNCA0LjY2LTQuNTcgNC45MWMuMzYuMzEuNjkuOTIuNjkgMS44NVYyMWMwIC4yNy4xNi41OS42Ny41QzE5LjE0IDIwLjE2IDIyIDE2LjQyIDIyIDEyQTEwIDEwIDAgMCAwIDEyIDIiLz48L3N2Zz4="/>
         rbook</a></p>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
    <script src="/assets/js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.6/heti-addon.min.js" integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        //const heti = new Heti('.heti');
        // error 自动挤压,增加空格 在Katex 公式中
        //heti.autoSpacing(); // 自动进行中西文混排美化和标点挤压
    </script>
      <script type="module">
        import mermaid from 'https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.12.0/mermaid.esm.mjs';
        mermaid.initialize({ startOnLoad: true });
      </script>
</body>
</html>