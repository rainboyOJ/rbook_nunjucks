---
oj: "luogu"
problem_id: "P1659"
title: "[国家集训队] 拉拉队排练"
date: 2025-12-14 10:13
toc: true
tags: ["manacher","dp"]
desc: "manacher算法➕贡献思维"
source: https://www.luogu.com.cn/problem/P1659
---

[[TOC]]

## 题目分析

### 问题转化
题目要求找到所有"和谐小群体"，即：
- 连续的一段女生，有奇数个
- 她们手中的牌子字母从左到右和从右到左读起来一样

这实际上就是寻找字符串中的所有**奇数长度回文子串**。

### 核心思路
1. **统计所有奇数长度回文子串的数量**
2. **按长度降序排序，取前K个长度的乘积**
3. **处理模运算和不足K个的情况**

## 算法设计

### 第一步：Manacher算法找所有回文
使用Manacher算法可以在$O(n)$时间内找到以每个位置为中心的最长回文半径。

对于每个中心位置，如果我们得到半径为`r`，那么以该为中心的奇数回文子串有：
- 长度为1, 3, 5, ..., 2r-1
- 共`r`个回文子串

### 第二步：统计各长度回文数量
使用`cnt[i]`表示长度为`i`的回文子串数量。

**朴素做法的问题**：
如果直接遍历每个中心，然后枚举所有可能的回文长度，时间复杂度为$O(n^2)$。

**优化思路 - 贡献法**：
观察到回文的嵌套性质：
- 长度为`i`的回文内部包含长度为`i-2`的回文
- 长度为`i-2`的回文内部包含长度为`i-4`的回文
- ...

因此，我们可以：
1. 先统计每个中心的最长回文长度
2. 然后从大到小累加贡献：
   ```cpp
   for(int i = n; i-2 >= 0; i--) {
       cnt[i-2] += cnt[i];
   }
   ```

这样每个长度为`i`的回文会向所有更小的奇数长度贡献1个回文。

### 第三步：计算答案
从大到小遍历长度，累乘前K个：
```cpp
ll ans = 1;
for(int i = n; i >= 1; i--) {
    if(i % 2 == 1) {  // 只考虑奇数长度
        if(k >= cnt[i]) {
            ans *= quick_pow(i, cnt[i]);
            ans %= mod;
            k -= cnt[i];
        } else {
            ans *= quick_pow(i, k);
            ans %= mod;
            k = 0;
            break;
        }
    }
}
```

## 复杂度分析
- **Manacher算法**：$O(n)$
- **贡献统计**：$O(n)$  
- **答案计算**：$O(n)$
- **总时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$

## 关键点
1. **Manacher算法的正确应用**：理解变换后的字符串与原字符串的对应关系
2. **贡献法的巧妙运用**：避免$O(n^2)$的暴力统计
3. **模运算和快速幂**：处理大数乘法
4. **边界情况处理**：不足K个时输出-1

@include-code(./1.cpp,cpp)
