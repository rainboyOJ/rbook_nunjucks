<!DOCTYPE html>
<html lang="zh" data-darkmode="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的算法书 - 遍历问题</title>
    <meta name="description" content="这是一本关于算法的书">
    <meta name="author" content="rainboy">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-web/1.520.0/style.min.css" integrity="sha512-VqbHLQtJ5icD77Z4HH8NsrtoRJlTAkOKdSrymwYZtZ1Ipbit8L/Pp8RIeHS2vpNk2bVOszUUDotVl7sK403sjw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/markdown.css">
    <link rel="stylesheet" href="/prism-theme/prism-tomorrow.css">
</head>
<body>
    <aside class="panel">
    <ul class="panel-list">
      <li><a href="/"><i class="fa fa-home"></i></a></li>
      <li><a href="javascript:void(0);" onclick="showMenuModal()"><i class="fa fa-list"></i></a></li>
    </ul>
    <ul class="panel-list">
      <li><input type="radio" class="J_darkMode" value="auto" name="darkmode" id="darkmode-auto" checked=""><label for="darkmode-auto"><i class="fa fa-adjust"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="light" name="darkmode" id="darkmode-light"><label for="darkmode-light"><i class="fa fa-sun-o"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="dark" name="darkmode" id="darkmode-dark"><label for="darkmode-dark"><i class="fa fa-moon-o"></i></label></li>
    </ul>
  </aside>
    <div id="modal-menu" class="modal-menu" style="display:none;">
  <div class="modal-menu-mask" onclick="hideMenuModal()"></div>
  <div class="modal-menu-content">
    <button class="modal-menu-close" onclick="hideMenuModal()">×</button>
    <h2>目录</h2>
    
  </div>
</div>
<script>
function showMenuModal() {
  document.getElementById('modal-menu').style.display = 'block';
}
function hideMenuModal() {
  document.getElementById('modal-menu').style.display = 'none';
}
</script>

    <main>
        
<article class="page">
    <header class="container page-header">
        <h1>遍历问题</h1>
        <div class="problem-info">
          <div class="problem-tags">
            <span>标签:</span>
            
              <span>#二叉树</span>
            
          </div>
          <div class="problem-source">
            <span>原题目:</span>
            <a href="https://www.luogu.com.cn/problem/P1229" target="_blank"> luogu-P1229</a>
          </div>
        </div>
        <div>
          <span>简要描述:</span>
          <span>思维难度高,编码简单</span>
        </div>
    </header>
    
    <div class="container">
        <div class="heti markdown-body">
    <nav class="table-of-contents"><ol><li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90">核心思路解析</a><ol><li><a href="#1.-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%9F">1. 为什么会不确定？</a></li><li><a href="#2.-%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F">2. 计算公式</a></li><li><a href="#3.-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%A3%80%E6%B5%8B%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F">3. 如何在字符串中检测这种情况？</a></li></ol></li><li><a href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">算法步骤</a></li><li><a href="#c%2B%2B-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">C++ 代码实现</a></li><li><a href="#%E4%B8%BE%E4%BE%8B%E5%9B%BE%E8%A7%A3%E9%AA%8C%E8%AF%81">举例图解验证</a></li></ol></nav><h2 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90" tabindex="-1">题目解析</h2>
<blockquote>
<p>本质是思维题,找规律.
本题就是那种思维难道很大,但是编码简单的题目.</p>
<p>核心: 找到规律,单子结点模式的确定</p>
</blockquote>
<p>这是一个非常经典的二叉树计数问题。要解决这个问题，我们需要理解为什么“前序遍历 + 后序遍历”无法唯一确定一棵二叉树，以及这种“不确定性”是如何产生的。</p>
<h2 id="%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90" tabindex="-1">核心思路解析</h2>
<h3 id="1.-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%9F" tabindex="-1">1. 为什么会不确定？</h3>
<ul>
<li><strong>前序遍历 (Preorder)</strong>：根 -&gt; 左 -&gt; 右</li>
<li><strong>后序遍历 (Postorder)</strong>：左 -&gt; 右 -&gt; 根</li>
</ul>
<p>如果一个节点 <code>Root</code> 有<strong>两个孩子</strong>（左孩子 <code>L</code> 和 右孩子 <code>R</code>）：</p>
<ul>
<li>前序：<code>Root L... R...</code></li>
<li>后序：<code>L... R... Root</code>
我们可以清晰地分辨出 <code>L</code> 结束和 <code>R</code> 开始的边界，结构是唯一的。</li>
</ul>
<p>但是，如果一个节点 <code>Root</code> <strong>只有一个孩子</strong> <code>Child</code>：</p>
<ul>
<li>
<p>情况 A（<code>Child</code> 是左孩子）：</p>
</li>
<li>
<p>前序：<code>Root Child...</code></p>
</li>
<li>
<p>后序：<code>Child... Root</code></p>
</li>
<li>
<p>情况 B（<code>Child</code> 是右孩子）：</p>
</li>
<li>
<p>前序：<code>Root Child...</code></p>
</li>
<li>
<p>后序：<code>Child... Root</code></p>
</li>
</ul>
<p><strong>关键发现</strong>：当节点只有一个孩子时，无论是作为左孩子还是右孩子，它的前序和后序遍历序列是<strong>完全一样</strong>的。
这意味着，每一个“只有一个孩子的节点”，都会带来两种可能性（左或右）。</p>
<h3 id="2.-%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F" tabindex="-1">2. 计算公式</h3>
<p>如果我们在整棵树中发现了  个这样的“只有一个孩子的节点”，那么可能的中序遍历总数就是：</p>
<p>（因为每个这样的节点都有 2 种选择，根据乘法原理，总数是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></eq>）。</p>
<h3 id="3.-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%A3%80%E6%B5%8B%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F" tabindex="-1">3. 如何在字符串中检测这种情况？</h3>
<p>我们需要在前序和后序字符串中找到这种特征：</p>
<ul>
<li>在前序中：<code>A</code> 紧跟着 <code>B</code> （即 <code>AB</code>），表示 <code>A</code> 是 <code>B</code> 的父节点。</li>
<li>在后序中：<code>B</code> 紧跟着 <code>A</code> （即 <code>BA</code>），表示 <code>A</code> 的子树是以 <code>B</code> 结尾的。</li>
</ul>
<p><strong>判据</strong>：
如果在前序遍历中出现了 <code>... A B ...</code>，且在后序遍历中出现了 <code>... B A ...</code>，这就意味着 <code>B</code> 是 <code>A</code> 的<strong>唯一</strong>直接子节点（或者更准确地说，我们无法区分 <code>A</code> 到底只有左孩子 <code>B</code> 还是只有右孩子 <code>B</code>，但这正是我们需要计数的歧义点）。</p>
<p><strong>反证</strong>：
如果 <code>A</code> 有两个孩子 <code>B</code>（左）和 <code>C</code>（右）：</p>
<ul>
<li>前序：<code>... A B ... C ...</code></li>
<li>后序：<code>... B ... C A ...</code>
此时前序是 <code>AB</code>，但后序是 <code>CA</code>。<code>B</code> 和 <code>A</code> 在后序中不相邻。</li>
</ul>
<h2 id="%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" tabindex="-1">算法步骤</h2>
<ol>
<li>读取前序字符串 <code>s1</code> 和后序字符串 <code>s2</code>。</li>
<li>初始化答案 <code>ans = 1</code>。</li>
<li>遍历前序字符串 <code>s1</code>，考察每一对相邻字符 <code>s1[i]</code> 和 <code>s1[i+1]</code>。</li>
<li>在后序字符串 <code>s2</code> 中找到这两个字符的位置。</li>
<li>如果它们在 <code>s2</code> 中也是相邻的（顺序相反，即 <code>s1[i+1]</code> 在 <code>s1[i]</code> 的前一位），说明发现了一个“单子节点”结构。</li>
<li>每发现一个，<code>ans</code> 乘以 2。</li>
<li>输出 <code>ans</code>。</li>
</ol>
<h2 id="c%2B%2B-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" tabindex="-1">C++ 代码实现</h2>
<div class="language-clike line-numbers-mode">
    <div class="code-info-header">
        <span>cpp</span>
        <div class="zeroclipboard-container">
            <div class="clipboard-copy">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon">
                    <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-fg-success">
                    <path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path>
                </svg>
                copy
            </div>
        </div>
    </div>
    <pre class="language-clike">
        <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div>
        <code>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>string<span class="token operator">></span>
#include <span class="token operator">&lt;</span>cstdio<span class="token operator">></span>

using namespace std<span class="token punctuation">;</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    string pre<span class="token punctuation">,</span> post<span class="token punctuation">;</span>
    cin <span class="token operator">></span><span class="token operator">></span> pre <span class="token operator">></span><span class="token operator">></span> post<span class="token punctuation">;</span>

    long long ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 遍历前序字符串，注意范围是 0 到 length-2</span>
    <span class="token comment">// 因为我们要访问 pre[i] 和 pre[i+1]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pre<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        char root <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        char child <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 在后序遍历中找到 root 和 child 的位置</span>
        <span class="token comment">// 实际上我们只需要判断：在 post 中，child 是否紧挨在 root 之前</span>
        
        <span class="token comment">// 找到 root 在 post 中的位置</span>
        int rootIdx <span class="token operator">=</span> post<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 找到 child 在 post 中的位置</span>
        int childIdx <span class="token operator">=</span> post<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 如果 child 正好在 root 的前一位</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootIdx <span class="token operator">==</span> childIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ans <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> ans <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code>
    </pre>
</div>
<h2 id="%E4%B8%BE%E4%BE%8B%E5%9B%BE%E8%A7%A3%E9%AA%8C%E8%AF%81" tabindex="-1">举例图解验证</h2>
<p>输入：</p>
<pre><code>pre: abc
post: cba

</code></pre>
<ol>
<li><strong>i=0</strong>: <code>pre[0]='a'</code>, <code>pre[1]='b'</code>. (对 <code>a</code> 和 <code>b</code> 关系进行检查)</li>
</ol>
<ul>
<li>在 <code>post</code> 中，<code>b</code> 的下标是 1，<code>a</code> 的下标是 2。</li>
<li><code>2 == 1 + 1</code>，满足条件！<code>ans</code> 变 2。</li>
<li><em>解释</em>：<code>a</code> 只有一个孩子 <code>b</code>，<code>b</code> 可以是左或是右。</li>
</ul>
<ol start="2">
<li><strong>i=1</strong>: <code>pre[1]='b'</code>, <code>pre[2]='c'</code>. (对 <code>b</code> 和 <code>c</code> 关系进行检查)</li>
</ol>
<ul>
<li>在 <code>post</code> 中，<code>c</code> 的下标是 0，<code>b</code> 的下标是 1。</li>
<li><code>1 == 0 + 1</code>，满足条件！<code>ans</code> 变 4。</li>
<li><em>解释</em>：<code>b</code> 只有一个孩子 <code>c</code>，<code>c</code> 可以是左或是右。</li>
</ul>
<ol start="3">
<li>输出 4。正确。</li>
</ol>

</div> 
    </div>

</article>

    </main>
    
    <footer class="site-footer">
    <div class="footer-content">
        <p>&copy; 2024 rainboy. All rights reserved. last build time </p>
        <p class="license">内容遵循 <a style="text-decoration:none;" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
            <img decoding="async" loading="lazy" src="/ccbyncsa.png" width="65" height="auto" style="display:inline-block;">
        </a> 协议</p>
        <p class="powered-by">Powered by <a href="https://github.com/rainboyOJ/rbook_nunjucks" target="_blank"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTIgMkExMCAxMCAwIDAgMCAyIDEyYzAgNC40MiAyLjg3IDguMTcgNi44NCA5LjVjLjUuMDguNjYtLjIzLjY2LS41di0xLjY5Yy0yLjc3LjYtMy4zNi0xLjM0LTMuMzYtMS4zNGMtLjQ2LTEuMTYtMS4xMS0xLjQ3LTEuMTEtMS40N2MtLjkxLS42Mi4wNy0uNi4wNy0uNmMxIC4wNyAxLjUzIDEuMDMgMS41MyAxLjAzYy44NyAxLjUyIDIuMzQgMS4wNyAyLjkxLjgzYy4wOS0uNjUuMzUtMS4wOS42My0xLjM0Yy0yLjIyLS4yNS00LjU1LTEuMTEtNC41NS00LjkyYzAtMS4xMS4zOC0yIDEuMDMtMi43MWMtLjEtLjI1LS40NS0xLjI5LjEtMi42NGMwIDAgLjg0LS4yNyAyLjc1IDEuMDJjLjc5LS4yMiAxLjY1LS4zMyAyLjUtLjMzczEuNzEuMTEgMi41LjMzYzEuOTEtMS4yOSAyLjc1LTEuMDIgMi43NS0xLjAyYy41NSAxLjM1LjIgMi4zOS4xIDIuNjRjLjY1LjcxIDEuMDMgMS42IDEuMDMgMi43MWMwIDMuODItMi4zNCA0LjY2LTQuNTcgNC45MWMuMzYuMzEuNjkuOTIuNjkgMS44NVYyMWMwIC4yNy4xNi41OS42Ny41QzE5LjE0IDIwLjE2IDIyIDE2LjQyIDIyIDEyQTEwIDEwIDAgMCAwIDEyIDIiLz48L3N2Zz4="/>
         rbook</a></p>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
    <script src="/assets/js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.6/heti-addon.min.js" integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        //const heti = new Heti('.heti');
        // error 自动挤压,增加空格 在Katex 公式中
        //heti.autoSpacing(); // 自动进行中西文混排美化和标点挤压
    </script>
</body>
</html>