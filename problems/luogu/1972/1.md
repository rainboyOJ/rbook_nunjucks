---
oj: "luogu"
problem_id: "P1972"
title: "[SDOI2009] HH 的项链"
date: 2025-12-01 13:01
toc: true
tags: ["树状数组","可持久化线段树","莫队"]
desc: "求区间内不同数的个数"
source: https://www.luogu.com.cn/problem/P1972
---

[[TOC]]


显然可以使用 [[problem: hdu,5919]] 的方法来做: **求区间内不同数的个数**

## 莫队

交错区间

$$
[2 6],[4,8]
[x_1,y_1] ,[x_2,y_2]
$$

$x_1 \leqslant x_2 ,y_1 \leqslant y_2$


经过我的尝试,莫队算法能的40分吧,因为常数太大

@include-code(./mo-algo.cpp, cpp)

## bit 树状数组


核心时间流动: `pre[i]`表示前第i个元素,前面出现的位置,`pre[i]= 0 `表示没有出现过

```cpp
int quer_range(int l,int r){
  int ans = 0;
  for(int i = l; i <= r; i++)
    if( pre[i] < l ) ans++;
  return ans;
}
```

于是发现`quer_range(2,4)`,那么就是查询区间内`pre[i] <= 2-1`成立的数量

如果我把`pre[i] <= 2-1`的数字标记为1,其余标记为0,那么, 想要查询`[2,6]`区间的不同的数字,可以这样做

```cpp

void _true_arr[100];
// 创建 pre[i] <=l 的 01 数组
for init_true_arr(int l) {
  for(int i = 1; i <= n; i++)
    if( pre[i] <= l ) _true_arr[i] = 1;
    else _true_arr[i] = 0;
}

int quer_range(int l,int r){
  int ans = 0;
  init_true_arr(l-1);
  // 求区间内 1 的个数,也就是区间和
  for(int i = l; i <= r; i++) if( _true_arr[i] == 1 ) ans++;
  return ans;
}
```

问题转化成: **在对应的 true false 数组上求区间和**

那么`_true_arr[i-1]`与`_true_arr[i]`的关系是怎样的呢?

如果 `pre[i] <= l-1` 成立,那么 `pre[i] <= l` 也成立,

也就是说: 如果位置i在`_true_arr[l-1]`上是1,那么在`_true_arr[l]`上也是1,这其实利用性质的是**单调性**

那我们就是可直接在`_true_arr[l-1]`上的基础上直接修改得到`_true_arr[l]`的值.总时间`O(n)`, 因为: `pre`数组总共只有n个元素,每个元素最多导致一次修改.

那么现在只需要优化求区间和的问题, 也就是求`_true_arr[l]`上`[l,r]`区间内1的个数
```cpp
  for(int i = l; i <= r; i++) if( _true_arr[i] == 1 ) ans++;
```

可以想到: 1. 树状数组 2. 线段树

这个使用树状数组更方便,因为树状数组代码简单一点:,

@include-code(./1.cpp, cpp)

### 方法二: 

> 来在:
> 这个题用树状数组，线段树等等都可以做，不过用树状数组写起来更方便。
> 
> 此题首先应考虑到这样一个结论：
> 
> 对于若干个询问的区间[l,r]，如果他们的r都相等的话，那么项链中出现的同一个数字，一定是只关心出现在最右边的那一个的，例如：
> 
> 项链是：1 3 4 5 1
> 
> 那么，对于r=5的所有的询问来说，第一个位置上的1完全没有意义，因为r已经在第五个1的右边，对于任何查询的[L,5]区间来说，如果第一个1被算了，那么他完全可以用第五个1来替代。
> 
> 因此，我们可以对所有查询的区间按照r来排序，然后再来维护一个树状数组，这个树状数组是用来干什么的呢？看下面的例子：
> 
> 1 2 1 3
> 
> 对于第一个1，insert(1,1)；表示第一个位置出现了一个不一样的数字，此时树状数组所表示的每个位置上的数字（不是它本身的值而是它对应的每个位置上的数字）是：1 0 0 0
> 
> 对于第二个2，insert(2,1)；此时树状数组表示的每个数字是1 1 0 0
> 
> 对于第三个1，因为之前出现过1了，因此首先把那个1所在的位置删掉insert(1,-1),然后在把它加进来insert(3,1)。此时每个数字是0 1 1 0
> 
> 如果此时有一个询问[2,3]，那么直接求sum(3)-sum(2-1)=2就是答案。
> 
> 题解清楚么？


## 可持久化线段树


参考 [[problem: hdu, 5919]] 可持久化线段树的实现
