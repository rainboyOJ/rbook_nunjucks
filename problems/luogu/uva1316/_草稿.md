没问题，我们把刚才讨论的逻辑落实到代码中。

这里有一个关键的实现细节：并在哪里？

当我们使用了第 $r$ 天后，这一天就变“实”了。下次如果还要找第 $r$ 天，应该直接跳转到 $r$ 的左边（即 $r-1$）。所以，我们的合并操作其实非常简单粗暴：直接将 $r$ 的父节点设为 $r-1$。

即：`fa[r] = r - 1;`

这样，下次 `find(r)` 的时候，就会通过路径压缩直接找到 $r-1$（或者 $r-1$ 的父节点，如果 $r-1$ 也被占用了的话）。

下面是完整的 C++ 代码，包含了详细注释：

C++

```
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 商品结构体
struct Item {
    int p; // 利润 (profit)
    int d; // 截止日期 (deadline)
};

// 比较函数：按利润从大到小排序
bool compare(const Item &a, const Item &b) {
    return a.p > b.p;
}

const int MAX_DAY = 10005; 
int fa[MAX_DAY]; // 并查集数组

// 并查集查找函数（带路径压缩）
// 作用：找到第 x 天对应的“最近可用空闲日子”
int find(int x) {
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]); // 路径压缩，直接连到根节点
}

void solve() {
    int n;
    // 处理多组输入 (UVa 题目常见格式)
    while (cin >> n) {
        vector<Item> items(n);
        int max_d = 0; // 记录题目中出现的最大天数，用于初始化并查集

        for (int i = 0; i < n; ++i) {
            cin >> items[i].p >> items[i].d;
            max_d = max(max_d, items[i].d);
        }

        // 1. 贪心策略第一步：按利润从大到小排序
        sort(items.begin(), items.end(), compare);

        // 2. 初始化并查集
        // 刚开始每一天都是独立的，fa[i] 指向自己，表示第 i 天空闲
        for (int i = 0; i <= max_d; ++i) {
            fa[i] = i;
        }

        int total_profit = 0;

        // 3. 遍历每个商品
        for (int i = 0; i < n; ++i) {
            // 查找该商品截止日期 d 对应的可用日子
            // find(d) 会返回 <= d 的最大的空闲日子
            int available_day = find(items[i].d);

            // 如果找到的日子 > 0，说明有空位
            if (available_day > 0) {
                total_profit += items[i].p;

                // 关键操作：占用这一天
                // 将 available_day 的父节点指向 available_day - 1
                // 这样下次再查 available_day 时，就会自动跳到左边去了
                fa[available_day] = available_day - 1; 
            }
            // else: available_day == 0，说明从 1 到 d 全满了，该商品只能丢弃
        }

        cout << total_profit << endl;
    }
}

int main() {
    // 优化 I/O 速度
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    solve();
    return 0;
}
```

### 代码复盘

这段代码里最核心的一行就是 `fa[available_day] = available_day - 1;`。

如果不使用并查集，而是用普通的循环去检查空位，你觉得在最坏情况下（比如所有商品截止日期都是 10000，且有 10000 个商品），时间复杂度会是多少？相比之下，用了并查集后又是多少？



> 在并查集的做法中，我们是按照**利润从大到小**排序，优先把最赚钱的订单安排好
>
> 





**并查集解法**：

- **排序**：按利润从大到小。
- **核心逻辑**：这个最赚钱的能不能塞进去？能塞就占坑，不能塞就扔。
- **复杂度**：$O(N \alpha(N))$，非常接近线性，通常更快。
- **优点**：不需要证明复杂的交换逻辑，直观对应“时间槽”。

## 反悔贪心

**时间顺序**（截止日期）来逐个查看商品，是不是更容易判断当前有没有“超时”？





踢掉10. 可以知道,集合(购物车) 里面现有的(d) 值一定小于 新加入的50的d值(2),



也就是说,购物车最多放2个物品, 这个时候必然踢掉10, 无论10对应的d是1还是2.





**前提：** 我们假设所有的商品是按照**过期时间 $d_i$ 从小到大** 排序进行处理的。



对于一个新的放入集合(购物车) 的值$(d_i,v_i)$,那么此时: 购物车里的物品,我们称为集合A(没有放$d_i$, $B = A \cup {d_i}$,



那么集合$A$里的元素$\forall d_x \in A , d_x <= v_i$,那么此时购物车最多可以有$d_i$个物品,



分情况考虑



1. 如果 $|A| < d_i$ ,那么A里面的所有的元素都对于上一个$d_i-1$都是合法的.,此时$d_i$,可以直接加入这个购物车
2. $|B| > d_i$, 那么此时新加入的$d_i$ ,不可能在安排在$d_i$天,需要删除最小的一个v(如何证明,删除一个后,剩下的每个元素的d都是合法的呢?),





核心: 证明删除一个后,剩下的每个元素的d都是合法



证明法 : 归纳法 + 交换验证







**二叉堆解法**：

- **排序**：按截止日期从小到大。
- **核心逻辑**：先塞进去再说，超载了就踢掉最便宜的。
- **复杂度**：$O(N \log N)$。
- **优点**：是标准的“反悔贪心”模板，很多类似的“带有时限/容量限制的选择问题”都可以用这个思路。



## 证明思路





这是一个非常经典的反悔贪心（Regret Greedy / Priority Queue Greedy）问题。你的直觉非常敏锐，**归纳法 + 交换论证（Exchange Argument）** 确实是证明这个算法正确性的核心。

为了完成你的证明，我们需要明确一个很重要的**前提条件**，这通常是使用这种堆（Priority Queue）贪心策略的基础：

> **前提：** 我们假设所有的商品是按照**过期时间 $d_i$ 从小到大** 排序进行处理的。







**核心证明：坑位继承法**

1. **前提**：商品按过期时间 $d$ **从小到大**处理。

2. **现状**：假设当前购物车里的 $k$ 个商品都占好了合法的坑位（时间点 $1$ 到 $k$）。

3. **冲突**：新来一个商品 $X$（截止时间 $d_X$），但 $k = d_X$，坑位满了。

4. **替换**：如果 $X$ 比购物车里最垃圾的商品 $Y$ 值钱，我们就扔掉 $Y$，换上 $X$。(可以扔掉 $Y$,其他元素前移,然后X放最后) (交换验证)

5. 合法性证明（一句话）：

   因为是按 $d$ 排序，$X$ 的截止时间一定比 $Y$ 晚 ($d_X \ge d_Y$)。

   所以，$Y$ 能坐的坑位（时间点），$X$ 一定也能坐。

**结论**：用更贵的 $X$ 继承 $Y$ 的坑位，方案依然合法且总价值更高。





于是我们的问题就变成了:



1. 求集合大小
2. 求集合的最值