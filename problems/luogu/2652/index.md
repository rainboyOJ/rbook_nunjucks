---
oj: "luogu"
problem_id: "P2652"
title: "同花顺"
date: 2026-01-01 21:24
toc: true
tags: ["离散化","思维"]
desc: ""
source: https://www.luogu.com.cn/problem/P2652
---

[[TOC]]

## 题目解析

题目要求“最少更换多少张牌”，我们可以运用逆向思维：

$$\text{最少更换数} = \text{总牌数 } n - \text{最多能保留的牌数}$$

所以，问题转化成了：在 $n$ 张牌中，最多能找出多少张牌，使得它们属于同一种花色，且数字可以包含在一个长度为 $n$ 的连续区间内。

> 4个花色存在4个 vector 里, 每个花色单独做(这里有误,题目的花色不止4种) 
> 显然是枚举, 固定结尾j, 问j 最多能配对多少个牌(数字可以包含在一个长度为n的区间内, a[j] - a[i] <= n-1)
> 双指针 或者 单调队列 ,或 二分

将 4 种花色分开处理

我们真正需要的是：**在一个有序数组中，找出一个最长的子段，使得子段内 `最大值 - 最小值 <= n - 1`**。

用 `std::vector` 分开存储 + `std::upper_bound` (二分查找) 来代替双指针，代码会非常优雅。


## 解释: 最大值 - 最小值 <= n - 1

这是用 **“相框模型”** 最直观的解释：

### 1. 想象一个固定大小的相框

想象你有一个 **长度为 $n$** 的相框。这个相框正好有 **$n$ 个格子**，每个格子只能放一张牌。

### 2. 规则：能被“框住”才能保留

你想保留的一组牌，必须能 同时 被这个相框框住。

如果牌太分散，超过了相框的长度，相框就盖不住它们了。

### 3. 为什么是 $n-1$？

我们来看相框的**内部距离**：

- 相框的第 $1$ 个格子，和第 $n$ 个格子（最后一个格子），中间隔了多少步？
  - 答案是：**$n - 1$ 步**。
  - 就像你有 5 个手指（$n=5$），但只有 4 个指缝（$n-1=4$）。

### 4. 结论

如果你选的 **最大牌 (Max)** 和 **最小牌 (Min)** 之间的距离超过了 **$n-1$**，说明它们离得太远了：

- **Max - Min > $n-1$** $\rightarrow$ **相框不够长**（首尾够不着），必须扔掉其中一张。
- **Max - Min $\le$ $n-1$** $\rightarrow$ **相框够长**，可以把它们都框进去，中间缺的牌补上就行。

## 代码思路

**离散化** 正是为了解决“数值很大（$10^9$），但有效数据很少（$10^5$）”导致无法使用数组下标的问题。

通过离散化花色，我们可以把 $10^9$ 范围的花色映射到 $0 \sim N-1$ 的小整数范围，这样就可以重新使用 **`vector<int> piles[N]`** 这种高效的数组结构

### 核心步骤

1. **收集**：读入时，把所有花色存入一个临时数组 `alls`。
2. **离散化模板操作**：对 `alls` 进行 `sort` 和 `unique`。
3. **映射**：使用 `lower_bound` 算出每个原始花色对应的“排名”（ID）。
4. **分桶**：用这个 ID 作为数组下标，把牌放入对应的 `vector` 中。

1. **独立处理**：对每个 `vector` 进行单独计算，取最大值。
2. **核心逻辑**：
   - 排序 + 去重。
   - 遍历每个数字 $x$ 作为**同花顺的起点**。
   - 同花顺的理论终点应该是 $x + n - 1$。
   - 用 `upper_bound` 快速找出第一个 **大于** 终点的数字位置。
   - 两个下标一减，就是在 $n$ 范围内的牌的数量。

### 复杂度

- **时间**：排序 $O(N \log N)$ + 遍历查找 $O(N \log N)$。总复杂度依然是 $O(N \log N)$，可以通过 $10^5$ 的数据。
- **空间**：$O(N)$


### 代码

@include-code(./1.cpp,cpp)

## 思路2

> 还可以这样 ,直接按花色排序, 花色相同的从小到大排序, 每次处理一个花色的牌(一个区间内),只使用一个 vector ,来存牌, 然后在这个vector上,进行 二分查找 

这是**最节省空间**且**逻辑最顺畅**的写法。

利用了 **排序 (Sort)** 的特性：只要按“花色第一关键字、数字第二关键字”排序，相同花色的牌自然会聚在一起，并且数字已经是通过排序有序的了。

这样我们就不需要开 `map`，也不需要开 $N$ 个 `vector` 数组，只需要**一个临时 vector** 反复利用即可。

### 核心逻辑

1. **全局排序**：让所有牌排好队，花色相同的在一起，数字也从小到大。
2. **双指针分组**：用一个循环找到当前花色的 `start` 和 `end` 下标。
3. **提取处理**：把这一个区间的数字放入 vector（此时天然有序），去重，算二分。
4. **清空复用**：处理完当前花色，清空 vector，处理下一组。

### 这个版本的优点

1. **极度省内存**：
   - 不需要 `map` 节点开销。
   - 不需要 `piles[N]` 这种大数组。
   - 只有一个 `cur_nums`，最大长度也不会超过 $N$，用完就清空，内存反复横跳利用。
2. **速度优化**：
   - 利用了全局 `sort` 的结果，在 `solve()` 函数内部省去了一次 `sort`。虽然总复杂度还是 $O(N \log N)$，但常数小了很多。
3. **代码结构清晰**：
   - 这就是典型的 **"分组循环" (Grouping Loop)** 写法，是处理序列分段问题的标准模板。

### 代码

@include-code(./2.cpp,cpp)

