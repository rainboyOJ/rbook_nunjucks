---
oj: "luogu"
problem_id: "P1419"
title: "寻找段落"
date: 2025-12-24 16:16
toc: true
tags: ["二分","单调队列"]
desc: "给定一个长度为n的序列，求出在所有长度在[S,T]之间的连续子序列中，平均值最大的那个子序列的平均值。"
source: https://www.luogu.com.cn/problem/P1419
---

[[TOC]]

## 题目描述

给定一个长度为 $n$ 的序列 $a_1, a_2, \ldots, a_n$，以及两个整数 $S$ 和 $T$。求出在所有长度在 $[S,T]$ 之间的连续子序列中，平均值最大的那个子序列的平均值。

## 解题思路

### 问题分析

显然可以暴力,你可以先写一个暴力代码

`n = 1e5`,暗示我们这个题目是$O(n)$或$O(nlogn)$

显然这里用到了平均数的性质,所有我们需要看看这个性质是什么,需要去算. 

### 二分答案的可行性

可以想到

1. 答案是上下界的.o

现在思考,答案是否具有**二分性**

```

---------------- Real_ANS ---------------------
              ^
              |
              |
估算的值est --+
```

Estimate: 估算

如果估算的值 `est` 在Real_ANS的左边,则必然存在段区间 $len \in [S,T]$ 使得平均值大于等于 `est`。

如果我们能在$O(n)$ 的时间内知道,`est` 是在 `Real_ANS`的左侧,还是右侧,那么这个题目就可以是用二分。

### 数学变换

因为我们不知道  `Real_ANS`是多少,
那么我们在 不知道`Real_ANS`的值的情况下判断 `est` 的左侧还是右侧吗?  

$$
P(l,r) :  ( \text{est} < \frac{sum(l,r) }{ r-l+1} ) \\
\exist l,r \quad P(l,r)
$$

那么关键就在$P(l,r)$ 这个公式了,如果枚举$l,r$,时间还是$O(n^2)$,那么把公式变形:

- $\text{est} < \frac{sum(l,r) }{ r-l+1}$
- $est \times (r-l+1) < sum(l,r)$
- $sum(l,r) - est \times (r-l+1) > 0$
- $(a_l + a_{l+1} + \cdots + a_r) - est \times (r-l+1) > 0$
- $(a_l - est) + (a_{l+1} - est) + \cdots + (a_r - est) > 0$

然后创建一个数组 `b[i]`: $b[i] = a[i] - est$

通过构造这个新数组 $b$，我们的问题就从"寻找平均值 $\ge est$ 的段落"转化成了：在数组 $b$ 中，是否存在一个长度在 $[S, T]$ 之间的段落，且该段落的元素和 $\ge 0$

如果存在这样的段落，说明这个 `est` 是可行的（甚至还可以更大）；如果不存在，说明 `est` 太大了。为了快速判断是否存在这样的段落，我们需要频繁计算一段区间 $[i, j]$ 的和。这就引出了下一个问题：有什么常用的技巧或辅助数组，可以让我们在 $O(1)$ 的时间内算出任意一段连续区间的和呢？

显然是前缀和

结合前缀和公式，这个条件就变成了：

$$S[i] - S[j-1] \ge 0$$

即：

$$S[i] \ge S[j-1]$$

可以想到固定i,然后取枚举$j-1$, 然后取最小值, 然后看是否大于0

显然j-1的范围是$[i-S,i-T]$

那么我们可以枚举i,然后取 $[i-T,i-S]$ 的最小值,然后看是否大于0

### 直觉理解

> - 直觉: 把a数组的每个数值想象成一个柱子,柱子的高度代表 `a[i]` 的值.
> - 如果所有的柱子都削去 `est` 后, 还存在区间和 `>=0` , 说明 `est` 在 `Real_ANS` 的左边
> - 问题变成: 最大区间和, 朴素方法: 枚举
> - 区间和显然使用 : 前缀和
> - 枚举优化: 固定 结尾i,求 `S[i] - S[j-1]` 是否存在 `>=0`的 
> - 是否存在 转成 找到`S[j-1]`的最小值
> - 转成求对应区间 `[i-T,i-S]` 最小值



### 区间最值问题

问题变成的区间最值问题

- 显然我们可以用单调队列来维护这个最小值
- 也可以是用线段树来维护这个最小值
- 也可以是用ST表来维护这个最小值
- 也可以是用分块来维护这个最小值
- 也可以是用树状数组来维护这个最小值

### 单调队列优化

这里只能用 `单调队列` 因为时间. $O(n)$

### 算法步骤

1. 二分答案，设定上下界
2. 对于每个猜测的平均值 $est$：
   - 构造数组 $b[i] = a[i] - est$
   - 计算前缀和数组 $S$
   - 使用单调队列维护长度为 $T-S+1$ 的滑动窗口最小值
   - 检查是否存在合法区间使得区间和 $\geq 0$
3. 根据检查结果调整二分边界

### 时间复杂度

- 二分答案：$O(\log(\text{精度}))$
- 每次检查：$O(n)$
- 总体时间复杂度：$O(n \log(\text{精度}))$

这真是一个好问题, 最难的部分就是思维转换, 把问题变成**求区间最值问题**

## 代码实现

@include-code(./1.cpp, cpp)
