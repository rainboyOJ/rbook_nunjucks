---
oj: "luogu"
problem_id: "P3199"
title: "[HNOI2009] 最小圈"
date: 2026-01-07 15:39
toc: true
tags: ["负环","分数规划"]
desc: ""
source: https://www.luogu.com.cn/problem/P3199
---

[[TOC]]


## 1. 核心推导：从求比值到判负环

### 目标

我们需要找到一个圈 $C$，使得其平均值 $\mu(C)$ 最小：



$$\text{Minimize } \mu(C) = \frac{\sum_{e \in C} w_e}{|C|}$$



其中 $|C|$ 是圈中边的数量。

### 二分答案



这里是题目的核心: 证明题目具有二分性:.

假设我们猜测最终的最小平均值是 $x$。

- 如果存在一个圈，使得它的平均值 $< x$，说明答案比 $x$ 更小，我们应该往左找（$r = mid$）。
- 如果所有圈的平均值都 $\ge x$，说明答案就是 $x$ 或者比 $x$ 更大，我们应该往右找（$l = mid$）。

洪水蔓延思考法: 边的权值 

### 公式变形 (Check 函数的灵魂)

判定条件：是否存在一个圈 $C$，满足：



$$\frac{\sum_{e \in C} w_e}{|C|} < x$$



两边同乘 $|C|$ (因为边数 $>0$，不等号方向不变)：



$$\sum_{e \in C} w_e < x \cdot |C|$$

$$\sum_{e \in C} w_e - \sum_{e \in C} x < 0$$



合并求和项：



$$\sum_{e \in C} (w_e - x) < 0$$

### 结论

二分一个 $x$ 后，我们将图中每一条边 $e$ 的权值 $w_e$ 减去 $x$，得到新边权 $w'_e = w_e - x$。

问题就变成了：在新图中，是否存在一个边权和 $< 0$ 的圈（负环）？

> 注：题目要求的是最小值，严格来说判定的是“是否存在负环”。只要存在负环，就说明存在平均值小于 $x$ 的方案。

------

## 2. 算法选择：SPFA 判负环

判断图中是否存在负环，常用的算法是 SPFA (Shortest Path Faster Algorithm)。

SPFA 有两种实现方式：

1. **BFS-SPFA**（基于广度优先）：稳定，但判负环较慢（需要入队 $N$ 次才判负）。
2. **DFS-SPFA**（基于深度优先）：**判负环极快**。一旦递归路径上重复遇到当前正在访问的节点，就说明找到了环；如果路径权值和减少了，那就是负环。

对于这道题，推荐使用 DFS-SPFA。

虽然 DFS-SPFA 在求最短路时由指数级复杂度的风险，但在判定负环的存在性上，它通常能在找到负环的那一刻立即退出，效率非常高。

------

## 3. 代码实现细节

1. **二分范围**：$[-10^7, 10^7]$。
2. **精度控制**：循环 `60` 到 `100` 次即可。
3. **图的连通性**：虽然题目说图连通，但 SPFA 判负环最稳妥的做法是把所有点都作为潜在起点扫一遍（或者建立一个超级源点）。在 DFS-SPFA 中，我们遍历 $1 \dots N$，如果该点没被访问过，就发起一次 DFS。

------

## 4. AC 代码


@include-code(./1.cpp,cpp)

## 5. 易错点与总结

1. **为什么是 $w - x$？**
   - 不等式 $\sum w \le x \cdot k$ 移项得到 $\sum (w-x) \le 0$。这意味着每一条边的边权都要减去 $x$。
2. **为什么用 DFS-SPFA？**
   - BFS-SPFA 判负环需要某个点入队次数达到 $N$ 次，效率较低，在二分内部跑容易超时。
   - DFS-SPFA 只要在递归栈里撞到自己，就立刻抓住负环，效率极高。
3. **dis 数组初始化**：
   - 这里不需要像求最短路那样初始化为 `INF`。因为我们是找负环，只要能不断变小（松弛）就行。把所有 `dis` 设为 0，相当于假设有一个虚拟源点连向所有点，边权为 0。

