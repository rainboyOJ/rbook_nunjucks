---
oj: "luogu"
problem_id: "P2731"
title: "[USACO3.3] 骑马修栅栏 Riding the Fences"
date: 2025-12-19 09:33
toc: true
tags: ["经典题","欧拉回路"]
desc: "经典题"
source: https://www.luogu.com.cn/problem/P2731
---

[[TOC]]



经典题

栅栏就是边,

1. 问使每个栅栏都恰好被经过一次
2. 输出最小的路径

我们的算法在回溯的时候输出点,这样会得到一条答案路径`a->b->c`

如果把这个路径反过来,也是一个解`c->b->a`

最直觉的想法,出发点选最小的

核心在于如何保证路径是最小的:


画个图想一下,可以知道: 每个在dfs上访问的点,都会输出:


```
a --- b
 \   /
  \ /
   c
```

我们需要做到两点：

1. 起点最小：如果有多个合法的起点，选择编号最小的那一个。
2. 过程贪心：在 DFS 过程中，当且仅当有多个邻居可以选择时，优先走编号最小的那个邻居。

欧拉路的标准算法（Hierholzer 算法或其 DFS 变体）是回溯时记录路径。

- DFS 会一直钻到底，直到无路可走才把点放入栈中。
- 这意味着：最后访问的点最先入栈，最先访问的点最后入栈。(利用栈倒序的功能)
- 所以，我们在 DFS 内部按 $1 \to 500$ 的顺序从小到大遍历邻居，这样“小”的邻居会被先递归访问。
- 最终把栈里的元素弹出来（或者倒序输出数组），就是正确的、字典序最小的顺序。


## 代码


@include-code(./1.cpp,cpp)
