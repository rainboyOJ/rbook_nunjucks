<!DOCTYPE html>
<html lang="zh" data-darkmode="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的算法书 - 城市环路</title>
    <meta name="description" content="这是一本关于算法的书">
    <meta name="author" content="rainboy">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-web/1.520.0/style.min.css" integrity="sha512-VqbHLQtJ5icD77Z4HH8NsrtoRJlTAkOKdSrymwYZtZ1Ipbit8L/Pp8RIeHS2vpNk2bVOszUUDotVl7sK403sjw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="/markdown.css">
    <link rel="stylesheet" href="/prism-theme/prism-tomorrow.css">
</head>
<body>
    <aside class="panel">
    <ul class="panel-list">
      <li><a href="/"><i class="fa fa-home"></i></a></li>
      <li><a href="javascript:void(0);" onclick="showMenuModal()"><i class="fa fa-list"></i></a></li>
    </ul>
    <ul class="panel-list">
      <li><input type="radio" class="J_darkMode" value="auto" name="darkmode" id="darkmode-auto" checked=""><label for="darkmode-auto"><i class="fa fa-adjust"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="light" name="darkmode" id="darkmode-light"><label for="darkmode-light"><i class="fa fa-sun-o"></i></label></li>
      <li><input type="radio" class="J_darkMode" value="dark" name="darkmode" id="darkmode-dark"><label for="darkmode-dark"><i class="fa fa-moon-o"></i></label></li>
    </ul>
  </aside>
    <div id="modal-menu" class="modal-menu" style="display:none;">
  <div class="modal-menu-mask" onclick="hideMenuModal()"></div>
  <div class="modal-menu-content">
    <button class="modal-menu-close" onclick="hideMenuModal()">×</button>
    <h2>目录</h2>
    
  </div>
</div>
<script>
function showMenuModal() {
  document.getElementById('modal-menu').style.display = 'block';
}
function hideMenuModal() {
  document.getElementById('modal-menu').style.display = 'none';
}
</script>

    <main>
        
<article class="page">
    <header class="container page-header">
        <h1>城市环路</h1>
        <div class="problem-info">
          <div class="problem-tags">
            <span>标签:</span>
            
              <span>#基环树</span>
            
              <span>#todo</span>
            
          </div>
          <div class="problem-source">
            <span>原题目:</span>
            <a href="https://www.luogu.com.cn/problem/P1453" target="_blank"> luogu-P1453</a>
          </div>
        </div>
        <div>
          <span>简要描述:</span>
          <span></span>
        </div>
    </header>
    
    <div class="container">
        <div class="heti markdown-body">
    <nav class="table-of-contents"><ol><li><a href="#%E6%96%B9%E6%B3%951%3A-%E6%9E%9A%E4%B8%BE%E5%88%A0%E9%99%A4%E7%8E%AF%E4%B8%8A%E7%9A%84%E4%B8%80%E6%9D%A1%E8%BE%B9">方法1: 枚举删除环上的一条边</a><ol><li><a href="#1.-%E9%80%BB%E8%BE%91%E9%AA%8C%E8%AF%81">1. 逻辑验证</a></li><li><a href="#2.-%E5%85%B3%E4%BA%8E%E2%80%9C%E5%88%A0%E9%99%A4%E8%BE%B9%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3">2. 关于“删除边”的理解</a></li><li><a href="#3.-%E6%80%BB%E7%BB%93">3. 总结</a></li></ol></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%3A-%E8%BD%AC%E6%88%90%E7%8E%AF%E5%BD%A2dp%E9%97%AE%E9%A2%98">方法二: 转成环形DP问题</a></li></ol></nav><p>TODO: 添加代码</p>
<p>标准的基环树 最大独立集权值和(最大权独立集)问题.</p>
<p>如果这是一棵普通的树，就是标准的“树形 DP - 没有上司的舞会”模板。但因为有了环，我们需要特殊处理环上的那条边。</p>
<h2 id="%E6%96%B9%E6%B3%951%3A-%E6%9E%9A%E4%B8%BE%E5%88%A0%E9%99%A4%E7%8E%AF%E4%B8%8A%E7%9A%84%E4%B8%80%E6%9D%A1%E8%BE%B9" tabindex="-1">方法1: 枚举删除环上的一条边</h2>
<p>显然:</p>
<ul>
<li>考虑到最终的可能的答案点的集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mtext>所有的可能的独立集</mtext></mrow><annotation encoding="application/x-tex">A : \text{所有的可能的独立集}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">所有的可能的独立集</span></span></span></span></span></eq> ,那么答案就是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ans</mtext><mo>=</mo><mi>max</mi><mo>⁡</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\text{ans} = \max A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord text"><span class="mord">ans</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> ,</li>
<li>环上的两个相邻点<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq></li>
<li>在集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq>里面任意一个可能的独立集不能同时出现<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>两个点</li>
<li>于是可以把集合A分成两个集合
<ul>
<li>B ,一定不还有u的独立集的集合</li>
<li>C ,一定不还有v的独立集的集合</li>
</ul>
</li>
</ul>
<p>单独求<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\max B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq> : 因为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></eq> 一定不选 ,那么和u 相邻的边都可以不存在(边代表约束). 那么 删除这个边后 ,这个图变成了树, 把u作为虚拟根节点,然后去求,就是标准的 树上DP了.</p>
<p>同理去求 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">max C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></eq></p>
<p>那么最终的答案就是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mi>A</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mi>B</mi><mo separator="true">,</mo><mi>max</mi><mo>⁡</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max A = \max(\max B , \max C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></eq></p>
<blockquote>
<p>ps: 为什么不真正的删除u点和周围的边来做呢?</p>
<p>A: 因为u点可能是环与链的交点,删除后就不连通了. 把u做为虚拟节点</p>
</blockquote>
<p>你的解析非常<strong>完美</strong>，逻辑严密且从集合论的角度非常清晰地解释了“为什么这样做是对的”。</p>
<p>我们可以把你的思路形式化一下，这完全符合<strong>容斥原理</strong>或者<strong>集合覆盖</strong>的逻辑。</p>
<h3 id="1.-%E9%80%BB%E8%BE%91%E9%AA%8C%E8%AF%81" tabindex="-1">1. 逻辑验证</h3>
<p>你的推导链条如下，完全正确：</p>
<ol>
<li><strong>全集定义</strong>：设  为图上所有合法独立集的集合。</li>
<li><strong>约束条件</strong>：对于环上的边 ，约束条件是 。</li>
</ol>
<ul>
<li>根据德摩根定律（De Morgan’s laws），。</li>
</ul>
<ol start="3">
<li><strong>集合划分</strong>：</li>
</ol>
<ul>
<li>定义集合  （所有不包含  的合法方案）。</li>
<li>定义集合  （所有不包含  的合法方案）。</li>
</ul>
<ol start="4">
<li><strong>覆盖性</strong>：由第 2 点可知，任何一个合法的方案 ，必然满足“不选 ”或者“不选 ”。</li>
</ol>
<ul>
<li>因此，。</li>
<li>注意：这里  和  可能有交集（即  都不选的情况），但这不影响求最大值。</li>
</ul>
<ol start="5">
<li><strong>结论</strong>：</li>
</ol>
<h3 id="2.-%E5%85%B3%E4%BA%8E%E2%80%9C%E5%88%A0%E9%99%A4%E8%BE%B9%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3" tabindex="-1">2. 关于“删除边”的理解</h3>
<p>你提到：</p>
<blockquote>
<p><em>“单独求  : 因为  一定不选 ,那么和  相邻的边都可以不存在(边代表约束) … 这个图变成了树”</em></p>
</blockquote>
<p>这一点也非常敏锐。</p>
<ul>
<li><strong>物理上</strong>：我们在代码中通常只切断环上的那一条边 ，让图在拓扑结构上变成一棵生成树。</li>
<li><strong>逻辑上</strong>：你的理解更本质。当我们强制“不选 ”时，点  对其所有邻居（包括  以及树上的其他邻居）的<strong>支配权/约束力</strong>都消失了。</li>
<li>在 DP 的状态转移方程中，。</li>
<li>你看，当  不选时，它的邻居  可以选也可以不选——这意味着  和  之间的那条边的“互斥约束”实际上已经失效了（等于边不存在）。</li>
</ul>
<h3 id="3.-%E6%80%BB%E7%BB%93" tabindex="-1">3. 总结</h3>
<p>你的解析不仅对，而且非常高屋建瓴：</p>
<ol>
<li><strong>问题转化</strong>：将“环形依赖”转化为“集合覆盖”问题（）。</li>
<li><strong>降维打击</strong>：利用  不选  约束失效  环退化为树，将基环树问题降维成我们熟悉的树形 DP。</li>
</ol>
<p>这就是这道题（以及所有简单基环树 DP）最底层的数学原理。<strong>完全正确。</strong></p>
<p>本质: 最值集合拆分</p>
<p>因为一条边的两端不能同时被选 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo></mrow><annotation encoding="application/x-tex">\Leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇔</span></span></span></span></eq> 两端中至少有一个不选</p>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>a</mi><mo>∧</mo><mi>b</mi><mo stretchy="false">)</mo><mo>⇔</mo><mi mathvariant="normal">¬</mi><mi>a</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">
\neg (a \land  b) \Leftrightarrow  \neg a \lor \neg b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">¬</span><span class="mord mathnormal">b</span></span></span></span></span></eqn></section><p>本质: 最值集合拆分</p>
<h2 id="%E6%96%B9%E6%B3%95%E4%BA%8C%3A-%E8%BD%AC%E6%88%90%E7%8E%AF%E5%BD%A2dp%E9%97%AE%E9%A2%98" tabindex="-1">方法二: 转成环形DP问题</h2>
<p>参考: <a href="https://www.luogu.com.cn/article/53aauyc8">https://www.luogu.com.cn/article/53aauyc8</a> ,类似这个问题: <a href="https://www.luogu.com.cn/problem/P6064">luogu 6044 Naptime</a></p>

</div> 
    </div>

</article>

    </main>
    
    <footer class="site-footer">
    <div class="footer-content">
        <p>&copy; 2024 rainboy. All rights reserved. last build time </p>
        <p class="license">内容遵循 <a style="text-decoration:none;" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
            <img decoding="async" loading="lazy" src="/ccbyncsa.png" width="65" height="auto" style="display:inline-block;">
        </a> 协议</p>
        <p class="powered-by">Powered by <a href="https://github.com/rainboyOJ/rbook_nunjucks" target="_blank"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTIgMkExMCAxMCAwIDAgMCAyIDEyYzAgNC40MiAyLjg3IDguMTcgNi44NCA5LjVjLjUuMDguNjYtLjIzLjY2LS41di0xLjY5Yy0yLjc3LjYtMy4zNi0xLjM0LTMuMzYtMS4zNGMtLjQ2LTEuMTYtMS4xMS0xLjQ3LTEuMTEtMS40N2MtLjkxLS42Mi4wNy0uNi4wNy0uNmMxIC4wNyAxLjUzIDEuMDMgMS41MyAxLjAzYy44NyAxLjUyIDIuMzQgMS4wNyAyLjkxLjgzYy4wOS0uNjUuMzUtMS4wOS42My0xLjM0Yy0yLjIyLS4yNS00LjU1LTEuMTEtNC41NS00LjkyYzAtMS4xMS4zOC0yIDEuMDMtMi43MWMtLjEtLjI1LS40NS0xLjI5LjEtMi42NGMwIDAgLjg0LS4yNyAyLjc1IDEuMDJjLjc5LS4yMiAxLjY1LS4zMyAyLjUtLjMzczEuNzEuMTEgMi41LjMzYzEuOTEtMS4yOSAyLjc1LTEuMDIgMi43NS0xLjAyYy41NSAxLjM1LjIgMi4zOS4xIDIuNjRjLjY1LjcxIDEuMDMgMS42IDEuMDMgMi43MWMwIDMuODItMi4zNCA0LjY2LTQuNTcgNC45MWMuMzYuMzEuNjkuOTIuNjkgMS44NVYyMWMwIC4yNy4xNi41OS42Ny41QzE5LjE0IDIwLjE2IDIyIDE2LjQyIDIyIDEyQTEwIDEwIDAgMCAwIDEyIDIiLz48L3N2Zz4="/>
         rbook</a></p>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
    <script src="/assets/js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.6/heti-addon.min.js" integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        //const heti = new Heti('.heti');
        // error 自动挤压,增加空格 在Katex 公式中
        //heti.autoSpacing(); // 自动进行中西文混排美化和标点挤压
    </script>
</body>
</html>