---
oj: "luogu"
problem_id: "P1000"
title: "[CTSC1999] 家园 / 星际转移问题"
date: 2025-12-23 10:26
toc: true
tags: ["网络流","todo"]
desc: "核心: 理解时间分层建模"
source: https://www.luogu.com.cn/problem/P1000
---

[[TOC]]

TODO: 添加代码



# [题解] P2754 星际转移 - 当图论遇上时间维度

## 1. 核心思路：分层图 (Time-Expanded Graph)

普通的网络流题目中，点是固定的（例如：城市、水管节点）。但这道题中，飞船的位置随时间 $t$ 变化，人也可以选择在某个站点停留到 $t+1$ 时刻。

因此，我们需要将 **时间** 引入节点中。
我们将节点定义为 $(u, t)$，表示：**在时刻 $t$，位于站点 $u$**。

整个图就像千层饼一样，每一层代表一个时刻，层与层之间通过“飞船移动”或“原地等待”相连。

## 2. 构图方法

设总人数为 $K$，站点数为 $N$（不含地月）。
为了方便，我们将地点重新编号：
* 地球：$0$
* 空间站：$1 \sim N$
* 月球：$N+1$
* 地点总数 $M_{cnt} = N+2$

我们按照时间 $t = 0, 1, 2, \dots$ 动态加层，直到转移的人数 $\ge K$ 为止。

### 节点编号
第 $t$ 天的第 $i$ 号站点，在图中的编号为：
$$ID(t, i) = t \times M_{cnt} + i$$

### 边的连接 (三种类型)

1.  **原地等待 (Hold)**：
    人可以在站点等待下一班飞船。
    * 连边：$ID(t-1, i) \to ID(t, i)$
    * 容量：$\infty$（空间站无限大）
    
2.  **飞船移动 (Travel)**：
    假设飞船 $j$ 在 $t-1$ 时刻位于站点 $u$，在 $t$ 时刻到达站点 $v$，且载客量为 $h_j$。
    * 连边：$ID(t-1, u) \to ID(t, v)$
    * 容量：$h_j$

3.  **源汇点连接**：
    * **源点 $S$**：在一开始（$t=0$）连接地球。$S \to ID(0, \text{Earth})$，容量 $\infty$（或 $K$）。
    * **汇点 $T$**：每一天都有可能有人到达月球。$ID(t, \text{Moon}) \to T$，容量 $\infty$。

## 3. 算法流程

1.  **判定无解**：使用 **并查集 (DSU)**。将所有飞船停靠的站点合并。如果最后地球和月球不在同一个集合，说明永远无法到达，输出 $0$。
2.  **动态增广**：
    * 从小到大枚举时间 $t = 1, 2, 3 \dots$。
    * 在图中添加第 $t$ 层的新节点和新边。
    * 在 **残量网络** 上继续跑最大流（Dinic 支持在原有流的基础上增加流量）。
    * 累加流量，当 `total_flow >= K` 时，当前的 $t$ 即为答案。

## 4. 复杂度分析

虽然看起来节点很多，但由于 $N$ 很小 ($N \le 13$)，且最优解的时间通常不会很大，分层图的规模完全可控。动态 Dinic 的效率非常高。

---

## 5. AC 代码 (C++)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 20000; // 节点数预估：(13+2) * 500天 + 2 左右
const int maxe = 100000; // 边数预估
const long long INF = 1e18;

// --- 存图模板 ---
struct linkList {
    typedef struct {int u,v,w,next;} edge;
    edge e[maxe];
    int h[maxn],edge_cnt=0;
    linkList(){
        edge_cnt=0;
        memset(h,-1,sizeof(h));
    }

    template<typename U>
    void for_each(int u,U func){
        for(int i = h[u] ; i !=-1;i = e[i].next)
            func(e[i].u,e[i].v,e[i].w); 
    }

    void add(int u,int v,int w=0){
        e[edge_cnt] = {u,v,w,h[u]};
        h[u] = edge_cnt++;
    }
    // 注意：链式前向星可以通过异或访问反向边，前提是成对添加
    edge& operator[](int i){ return e[i]; }
    int operator()(int u){ return h[u]; }
} e;

// --- Dinic 模板 ---
struct Dinic {
    vector<int> level, iter; 
    int n; 
    
    // 注意：这里需要初始化足够大的空间，因为我们会动态加点
    Dinic(int n) : n(n), level(n+5), iter(n+5) {
        e.edge_cnt = 0;
        memset(e.h, -1, sizeof(e.h));
    }
    
    void addEdge(int u, int v, long long cap) {
        e.add(u, v, cap);   
        e.add(v, u, 0);     
    }
    
    bool bfs(int s, int t) {
        fill(level.begin(), level.end(), -1);
        queue<int> q;
        level[s] = 0;
        q.push(s);
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            e.for_each(u, [&](int from, int to, int cap) {
                if (cap > 0 && level[to] < 0) {
                    level[to] = level[u] + 1;
                    q.push(to);
                }
            });
        }
        return level[t] >= 0; 
    }
    
    long long dfs(int u, int t, long long preFlow) {
        if (u == t || preFlow == 0) return preFlow;
        long long flow = 0;
        
        for (int& cid = iter[u]; cid != -1; cid = e[cid].next) {
            auto& edge = e[cid]; 
            int to = edge.v;
            long long cap = edge.w;
            
            if (level[u] + 1 != level[to] || cap <= 0) continue;
            
            long long tr = dfs(to, t, min(preFlow, cap));

            e[cid].w -= tr ;     
            e[cid ^ 1].w += tr; 
            flow += tr;
            preFlow -= tr;
            if (preFlow == 0) break;
        }
        
        if (flow == 0) level[u] = -1;
        return flow;
    }
    
    long long maxFlow(int s, int t) {
        long long flow = 0;
        while (bfs(s, t)) { 
            for (int i = 0; i <= n; i++) {
                iter[i] = e(i); 
            }
            flow += dfs(s, t, LLONG_MAX);
        }
        return flow;
    }
};

// 并查集，用于判断地球和月球是否联通
struct DSU {
    vector<int> fa;
    DSU(int n) : fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
    void merge(int x, int y) { fa[find(x)] = find(y); }
};

struct Spaceship {
    int h; // 容量
    int r; // 停靠站数
    vector<int> stops; // 停靠站点列表
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int n, m, k;
    if (!(cin >> n >> m >> k)) return 0;

    // 地点映射: 
    // 输入: 地球0, 空间站1..n, 月球-1
    // 内部: 地球0, 空间站1..n, 月球 n+1
    int earth = 0;
    int moon = n + 1;
    int total_locs = n + 2; // 地点总数

    DSU dsu(total_locs);
    vector<Spaceship> ships(m);

    for (int i = 0; i < m; i++) {
        cin >> ships[i].h >> ships[i].r;
        for (int j = 0; j < ships[i].r; j++) {
            int stop;
            cin >> stop;
            if (stop == -1) stop = moon; // 映射月球
            ships[i].stops.push_back(stop);
            
            // 并查集连边：将同一艘飞船的所有停靠点合并
            if (j > 0) {
                dsu.merge(ships[i].stops[j], ships[i].stops[j-1]);
            }
        }
    }

    // 1. 判断是否有解
    if (dsu.find(earth) != dsu.find(moon)) {
        cout << "0\n";
        return 0;
    }

    // 2. 构建分层图
    // 我们预估最大天数不会太大，直接开大一点的 Dinic
    // S = maxn-1, T = maxn-2
    int S = maxn - 1;
    int T = maxn - 2;
    Dinic dinic(maxn); 

    // 初始化：建立源点到第0天地球的边
    // 节点编号规则: day * total_locs + loc_id
    auto getId = [&](int day, int loc) {
        return day * total_locs + loc;
    };

    dinic.addEdge(S, getId(0, earth), k); // 最多只有k人需要出发

    long long current_flow = 0;
    int day = 0;
    
    // 限制最大天数防止死循环
    int max_days = 2000; 

    while (day < max_days) {
        // 进入新的一天
        day++;
        
        // 扩展节点上限，防止bfs越界
        dinic.n = getId(day, total_locs); 

        // 2.1 让人在月球汇入汇点 (如果能在 day 天到达月球)
        dinic.addEdge(getId(day, moon), T, INF);

        // 2.2 处理原地等待 (昨天的 i -> 今天的 i)
        for (int i = 0; i < total_locs; i++) {
            dinic.addEdge(getId(day - 1, i), getId(day, i), INF);
        }

        // 2.3 处理飞船移动
        for (int i = 0; i < m; i++) {
            // 飞船 i 在昨天(day-1)的位置
            int prev_idx = (day - 1) % ships[i].r;
            int prev_loc = ships[i].stops[prev_idx];

            // 飞船 i 在今天(day)的位置
            int curr_idx = day % ships[i].r;
            int curr_loc = ships[i].stops[curr_idx];

            // 添加边：昨天位置 -> 今天位置，容量为飞船容量
            dinic.addEdge(getId(day - 1, prev_loc), getId(day, curr_loc), ships[i].h);
        }

        // 2.4 在残量网络上跑最大流
        // Dinic 会在保留之前流的基础上寻找增广路
        current_flow += dinic.maxFlow(S, T);

        if (current_flow >= k) {
            cout << day << "\n";
            return 0;
        }
    }

    cout << "0\n";
    return 0;
}
```

## 理解!!


1. 边表示一种方案,一种运输方案. 从u 点 到 v,t+1 需要(可以) 运输的人的数量
2. 管道中的总流量: 到达下一个点的人 
3. 汇点流入的量,可以理解成: 接收到的人
4. 添加新的节点,新的管道(边),表示运输状态改变了
5. 回退流量: 相当于等待(人必须可以在运输点可以无限的等待,)


### 1 关于第 5 点的修正与深化：回退流 vs. 等待

你提到的“回退流量”和“等待”其实是两个完全不同的概念，这里容易混淆：

*   **等待 (Waiting)**：这是**物理上的动作**。
    *   在我们的图中，它是一条**实实在在的向前走的边**： $\left(u,t\right)\to \left(u,t+1\right)$ 。
    *   它的意思是：“这一分钟我不坐船，我选择让时间流逝，自己还在原地”。这依然是正向的时间流动。
*   **回退流 (Reverse Flow)**：这是**算法上的机制**（后悔药）。
    *   在残量网络（Residual Graph）中，反向边允许算法“撤销”之前的决策。
    *   **例子**：假设算法一开始让小明在  $t=1$  时坐船去了 B 站。后来发现，如果在  $t=1$  时让小明留在 A 站等待，而让急救员小红坐那艘船去 B 站，能救更多人。
    *   这时候，反向边就起作用了：流量从 B “流回” A（逻辑上的撤销），把船票腾出来给小红，小明则改为走“等待边”。
    *   **总结**：反向边赋予了网络流算法**全局统筹**的能力，而不是简单的“走到哪算哪”。

### 2 新的理解视角：流量守恒 = 每个人都必须有着落

网络流中有一个核心定律叫**流量守恒（Conservation of Flow）**：除了源点和汇点，任何节点流入的量必须等于流出的量。

在这个“分层图”中，这意味着什么？

*   **节点  $\left(u,t\right)$ ** 就像一个十字路口。
*   **流入 = 昨天留下的 + 刚才刚到的**：
    *   从  $\left(u,t-1\right)$  来的流量（上一分钟就在这等的人）。
    *   从  $\left(v,t-1\right)$  坐船来的流量（刚下船的人）。
*   **流出 = 今天留下的 + 今天走的**：
    *   流向  $\left(u,t+1\right)$ （决定继续等的人）。
    *   流向  $\left(w,t+1\right)$ （决定上船走的人）。

**深刻理解**：这个守恒定律保证了**没有人会凭空消失，也没有人会分身术**。每个人每一分钟的状态（要么移动，要么等待）都被精确记录了。

### 3 “时间隧道”视角

你可以把这个分层图想象成一个三维的圆柱体，或者**多层蛋糕**。

*   每一层蛋糕代表一个时刻。
*   **等待边**  $\left(u,t\right)\to \left(u,t+1\right)$  就像是垂直贯穿蛋糕的柱子，人顺着柱子垂直掉到下一层（位置不变，时间变了）。
*   **飞船边**  $\left(u,t\right)\to \left(v,t+1\right)$  就像是斜插在蛋糕里的吸管，人顺着吸管滑到了下一层的另一个位置。

我们的目标就是在这个密密麻麻的管道系统中，把  $k$  股水流（人）从最上层的地球，通过各种垂直柱子和斜吸管，最终引导到任何一层的“月球出口”。

* * *

你的理解力很强，这些概念一旦打通，写代码就是顺水推舟的事了。

我们回到代码实现上。刚才正好讲到**并查集 (DSU)** 的部分。这个预判对于防止死循环至关重要。

你能试着把刚才那段代码里的 `find` 函数补全吗？（或者如果你希望我直接给出这部分的完整代码也可以告诉我）：

```
// 1. 查找父节点 (路径压缩)
int find(int x) {
    // 这里需要写路径压缩的逻辑
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]); // 你的思路是这样吗？
}
```

我们要不要先把这个输入和判断无解的部分写完，然后立刻进入最精彩的网络流动态建图部分？


这道题目是\*\*分层图网络流（Time-Expanded Network Flow）\*\*的教科书级应用。解决本题的关键，在于将随时间变化的动态过程，映射为一个静态的有向图模型。

我们要建立一种直觉：**网络流图中的每一个元素，都对应着物理世界中的具体含义。**

一、 核心建模：时空分层图
-------------

由于太空船的移动和人的等待都与“时间”紧密相关，我们不能只建立空间的点，必须引入时间维度。

### 1 节点：时空坐标 (Space-Time Nodes)

图中的节点不再单纯代表“某个地点”，而是代表\*\*“特定时刻的特定地点”\*\*。

*   **定义**：节点  $\left(u,t\right)$  表示在时刻  $t$  处于地点  $u$  的状态。
*   **对应理解**：这相当于把地图按时间切片，每一分钟都生成一个新的层级（正如你的理解：_添加新的节点，表示运输状态随时间改变了_）。

### 2 边：物理动作的映射 (Edges as Actions)

图中的每一条有向边，都代表了一种**可行的物理方案**。边的\*\*容量（Capacity）\*\*限制了该方案能处理的最大人数。

我们在模型中定义两种类型的边：

*   **运输边（Travel Edge）**
    *   **物理含义**：坐船移动。
    *   **连边方式**：若飞船在时刻  $t$  从  $u$  出发，下一刻到达  $v$ ，则连边  $\left(u,t\right)\to \left(v,t+1\right)$ 。
    *   **容量**：飞船的载客上限  $h_{i}$ 。
    *   **你的理解**：_“边表示一种运输方案，从 u 到 v 需要/可以运输的人的数量。”_ —— 这一点非常准确。
*   **等待边（Waiting Edge）**
    *   **物理含义**：原地驻留。
    *   **连边方式**： $\left(u,t\right)\to \left(u,t+1\right)$ 。
    *   **容量**： $\infty$ （因为空间站容量无限）。
    *   **深度解析**：注意，**“等待”在物理上位置没变，但在网络流分层图中，它是向时间轴正方向移动的边。** 这代表了人随着时间的流逝，从“这一刻的自己”变成了“下一刻的自己”。

二、 流量与守恒：物理世界的映射
----------------

### 1 流量 (Flow)

*   **定义**：管道中实际流过的数值。
*   **对应理解**：_“管道中的总流量 = 实际到达下一个点的人数。”_

### 2 汇点 (Sink)

*   **定义**：超级汇点  $T$  连接着所有时刻的月球节点。
*   **对应理解**：_“汇点流入的量 = 最终成功接收到的人数。”_ 当流入量等于地球初始人数  $k$  时，说明转移任务完成。

### 3 流量守恒定律 (Conservation of Flow)

网络流中“流入=流出”的定律，在本题中有着深刻的物理意义：**人员的连续性（Object Permanence）**。 对于任意中间节点  $\left(u,t\right)$ ：

*   **流入**（昨天的滞留 + 刚才刚到的） **\=** **流出**（今天继续滞留 + 今天上船走的）。
*   这保证了**没有人会凭空消失，也没有人会分身**。每个人在每一分钟的状态都被精确记录。

三、 难点辨析：等待 vs. 回退流
------------------

在学习过程中，初学者最容易混淆“等待”与算法中的“反向边”。我们需要做一个明确的区分：

### 1 等待 (Waiting) —— 物理层的决策

*   **表现**：正向边  $\left(u,t\right)\to \left(u,t+1\right)$ 。
*   **含义**：这是一种**主动的选择**。决策者认为“现在不走，留在原地等待下一班船”是可行的方案。它推动时间向前流动。

### 2 回退流 (Reverse Flow) —— 算法层的“后悔药”

*   **表现**：残量网络中的反向边。
*   **含义**：这是一种**逻辑上的撤销**，而非物理上的等待。
*   **场景举例**：
    > 算法一开始安排小明在  $t=1$  坐船走（占用了 1 个流量）。 后来发现，如果让小明把这个船位让给急救员小红，而让小明去走“等待边”，能让整体结果更优。 此时，算法通过**反向边**将小明的流量“推回”起点，让他改走等待边，把船位空出来给小红。
*   **结论**：你的理解中提到 _“回退流量相当于等待”_ 是一个直觉上的误区。准确地说：**等待是图中的一条路，而回退流是算法在寻找最优路径时，拥有的“推倒重来”的特权。**

四、 总结：时空管道隐喻
------------

我们可以把这个模型想象成一个**三维的管道系统**（或者多层蛋糕）：

*   **等待边**是垂直贯穿层级的柱子（时间流逝，位置不变）。
*   **运输边**是斜插在层级之间的吸管（时间流逝，位置改变）。

我们的算法目标，就是在动态增加层级的过程中，寻找在第几层（第几分钟）时，能构建出一个足够宽的管道网络，将  $k$  股水流（人员）完整地从地球引导至月球。

