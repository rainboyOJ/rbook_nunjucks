---
oj: "luogu"
problem_id: "P2515"
title: "[HAOI2010] 软件安装"
date: 2025-12-30 17:19
toc: true
tags: ["scc","树形dp"]
desc: ""
source: https://www.luogu.com.cn/problem/P2515
pre:
 - luogu,P2014
book:
 - scc
 - tree_dp
---

[[TOC]]



## 思路大纲

本题有前置题目:  [[problem: luogu, P2014]]

本题目的核心:


1. 证明: 是一个内向基环树
2. 循环依赖的处理: 缩点
3. 证明 缩点 后 加虚拟节点 一定是一棵数,每个点的只有一个出边,缩点后一定有n-1条边,且连通,所以是树
4. 转成 luogu P2014 这个题目的问题

## 题目解析

这是一份基于你提供的大纲，为你量身定制的 **P2515 [HAOI2010] 软件安装** 详细解析。

------

# P2515 [HAOI2010] 软件安装 题目解析

**前置题目**：[[problem: luogu, P2014]] ([CTSC1997] 选课)

本题本质上是 **P2014 选课** 的 **图论加强版**。它在标准的树形背包模型之上，增加了一层**循环依赖**的处理。

## 1. 图论建模：证明图的结构

首先，我们需要理清图的形态。

建边规则：

设软件 $i$ 依赖于 $d_i$。为了方便分析依赖链，我们建立一条从依赖者指向被依赖者的有向边：$i \to d_i$。

- 如果 $d_i = 0$，则视为 $i \to 0$（指向虚拟源点）。

**性质证明（内向基环树森林）**：

1. **出度限制**：根据题意，一个软件**最多**依赖一个软件。这意味着图中每一个节点 $i$ 的**出度 $out\_degree(i) = 1$**（指向它的依赖对象，或者 0）。
2. **必然存在环**：在一个有向图中，如果每个点的出度都为 1，且点数有限，沿着边走下去，必然会遇到重复的点，从而形成**环**。
3. **基环树形态**：这种“每个点只有一条出边”的图，被称为**内向函数图 (Functional Graph)**。它的每个连通分量形状像一个“水母”或“$\rho$”字形：一个环，周围挂着若干棵指向环的树。

**结论**：原图是由若干个**内向基环树**（包含环）或**内向树**（最终指向 0）组成的森林。

## 2. 循环依赖的处理：SCC 缩点

**问题**：标准的树形 DP 只能在 DAG（有向无环图）或树上进行。如果依赖关系中存在环（例如 $A \to B \to C \to A$），意味着 $A, B, C$ 互为前置条件。

**逻辑推导**：

- 如果想安装环上的任意一个软件，必须先安装它的前置；
- 一圈推导下来，结论是：**要么整个环上的软件都安装，要么都不安装**。

解决方案：

使用 Tarjan 算法 求强连通分量 (SCC)。

- 将同一个 SCC 中的所有点**缩成一个“超点”**。
- **新重量** $W'_{scc} = \sum w_i$（环内所有点重量之和）。
- **新价值** $V'_{scc} = \sum v_i$（环内所有点价值之和）。


坑点 : 处理孤立环

这是本题最容易出错的边界情况。

在缩点后的图中，可能存在入度为 0 的 SCC。这包含两种情况：

1. 原图中依赖 $0$ 的点（显式依赖根）。
2. **孤立的环**：原图中 $A \leftrightarrow B$，且 $A, B$ 不依赖其他人。缩点后，这个 SCC 在新图中没有父亲。

处理方案：

统计所有 SCC 的入度。如果某个 SCC 的入度为 $0$，说明它没有前置依赖（或者它是一个独立的闭环系统，只要付出代价就能启动），我们必须强制将其连在虚拟根节点 0 下面。


> 经过上述处理，图变成了一个以 $0$ 为根节点，所有其他 SCC 都有且仅有一个入边的结构——即一棵树。

## 3. 证明：缩点 + 虚拟节点 = 一棵树

这是本题最关键的转化步骤。为什么缩点后，加上节点 0，就一定能跑树形 DP？

**证明过程**：

1. 缩点后的出度：

   在原图中，每个点 $u$ 只有 1 条出边 $u \to d_u$。

   缩点后，对于新的超点 $U$：

   - 如果原边 $u \to d_u$ 是环内边，则该边消失（包含在 $U$ 内部）。
   - 如果原边指向环外，那么这个超点 $U$ 依然**只有 1 条指向其他 SCC 的出边**。
   - **结论**：缩点后的图（DAG），每个节点依然满足**出度 $\le 1$**。

2. 虚拟根节点的连接：

   我们将原图中所有 $d_i=0$ 的边，视为指向虚拟节点 0。

   此时，缩点后的图中，所有原本“没有依赖”或者“依赖链终点”的节点，现在都指向了 0 号点。

3. 边的反转（依赖关系 $\to$ 也就是父子关系）：

   为了进行树形 DP，我们需要将图看作“父 $\to$ 子”的结构（选了父才能选子）。

   我们将上述分析中的边方向反转：由 $d_i \to i$。

   - **根节点**：0 号点。它没有入边（反转前没有出边），它是唯一的源头。
   - **入度唯一性**：在反转前，每个点出度为 1；反转后，除了根节点 0，每个点（或 SCC 超点）的**入度恰好为 1**。

最终结论：

一个有 $N'$ 个节点（含虚拟根）的连通图，且除了根节点外，所有节点的入度均为 1，这正是树的定义。

## 4. 转化为 P2014 选课 (树形背包 DP)

经过上述处理，问题已经完全转化：

- **节点**：缩点后的 SCC 超点。
- **结构**：一棵以 0 为根的树。
- **限制**：背包容量 $M$。
- **规则**：想选子节点（子树），必须选父节点。

这与 **P2014 [CTSC1997] 选课** 完全一致，只是物品的“体积”从 1 变成了 $W_{scc}$。

状态转移方程：

设 $dp[u][j]$ 为以 $u$ 为根的子树，花费 $j$ 容量能获得的最大价值。

$$dp[u][j] = \max_{0 \le k \le j - W_u} (dp[u][j-k] + dp[v][k]) + V_u$$

- **初始化**：对于节点 $u$，必须先花费 $W_u$ 的代价选自己，才能考虑子树。
  - $dp[u][j] = V_u \quad (\text{当 } j \ge W_u)$
  - $dp[u][j] = 0 \quad (\text{当 } j < W_u)$
- **分组背包过程**：
  - 外层枚举子节点 $v$。
  - 中层**倒序**枚举容量 $j$（从 $M$ 到 $W_u$）。
  - 内层枚举分给子树 $v$ 的容量 $k$。

### 总结流程

1. **建图**：$i \to d_i$。
2. **Tarjan**：找环，缩点，统计每个 SCC 的总重量和总价值。
3. **重构图**：
   - 建立新图，若原边 $i \to d_i$ 跨越了两个 SCC ($U \to V$)，则在新图中建立反向边 $V \to U$（父指向子）。
   - 若 $d_i = 0$，建立 $0 \to SCC_i$。
4. **树形 DP**：从 0 号点开始 DFS，跑一遍分组背包即可。
5. **答案**：$dp[0][M]$。


## 代码 

@include-code(./1.cpp, cpp)

