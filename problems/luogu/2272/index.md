---
oj: "luogu"
problem_id: "P2272"
title: "[ZJOI2007] 最大半连通子图"
date: 2025-12-29 21:29
toc: true
tags: ["scc","dag","dp"]
desc: ""
source: https://www.luogu.com.cn/problem/P2272
pre:
 - luogu,P1314
book:
 - bookid
---

[[TOC]]

## 题目解析

## 代码 

@include-code(./1.cpp, cpp)

这道题是 **强连通分量 (SCC) + 缩点 + DAG 上最长路 DP** 的经典模板题。


### 1. 什么是“半连通”？

题目定义：对于图中任意两点 $u, v$，存在 $u \to v$ 或 $v \to u$。

这个性质意味着，如果我们将图中的点按照“谁能到达谁”的关系排列，它们必须构成一条**“链”**（线性结构）。

### 2. 为什么要缩点？

- **强连通分量 (SCC) 内部**：任意两点互相可达，显然满足半连通性质。
- **性质**：如果我们选了 SCC 中的一个点进入半连通子图，为了使节点数最大，我们一定要把这个 SCC 中**所有的点**都选上（因为它们互相可达，不会破坏半连通性，且能增加点数）。
- **转化**：我们将图中的 SCC 缩成一个点，原来的图就变成了一个 **DAG (有向无环图)**。

### 3. 问题转化

在缩点后的 DAG 上，原题的“最大半连通子图”就等价于：

在 DAG 上寻找一条路径，使得路径上所有节点的权值（即该 SCC 包含的原图节点数）之和最大。

同时，题目要求计算方案数，这实际上就是**DAG 上的加权最长路计数**问题。

这显然是一个枚举问题,以点u为节点的路径,对集合进行分类,这是一个dp问题.

### 算法流程

1. **Tarjan 算法求 SCC**：
   - 计算出所有的强连通分量。
   - 记录每个 SCC 的大小 `size[i]`。
   - 记录每个原图节点 $u$ 属于哪个 SCC，记为 `id[u]`。
2. **建新图 (DAG)**：
   - 遍历原图的所有边 $u \to v$。
   - 如果 $u, v$ 不在同一个 SCC ($id[u] \neq id[v]$)，则在新图中添加一条边 $id[u] \to id[v]$。
   - **关键去重**：原图中 $u \to v$ 和 $x \to y$ 可能对应新图中同一条边 $A \to B$。为了避免 DP 重复计数，新图中的边必须**去重**。
3. **拓扑排序 / 记忆化搜索 DP**：
   - 设 `f[u]` 表示以 DAG 中节点 $u$ 为**终点**的最大点数。
   - 设 `g[u]` 表示以 DAG 中节点 $u$ 为**终点**，且达到最大点数的**方案数**。
   - 转移方程（对于边 $u \to v$）：
     - 若 `f[u] + size[v] > f[v]`：说明找到了更长的路，更新 `f[v] = f[u] + size[v]`，并重置 `g[v] = g[u]`。
     - 若 `f[u] + size[v] == f[v]`：说明长度相同，累加方案数 `g[v] = (g[v] + g[u]) % X`。
     - 显然先求`f[u]`,然后求`f[v]`
4. **统计答案**：
   - 遍历 DAG 所有节点，找到 `f[i]` 的最大值 $K$。
   - 将所有 `f[i] == K` 的节点的 `g[i]` 累加，即为总方案数 $C$。

------

### C++ 代码实现

@include-code(./1.cpp,cpp)

### 注意事项

1. **去重是关键**：在构建 DAG 时，连接两个 SCC 的边可能有多条。如果不去重，DP 累加 `num` 时会重复计算，导致方案数错误。代码中利用了 `vector + sort + unique` 的技巧来去重。
2. **Mod 的使用**：题目给定的 $X$ 不一定是质数，但只要在每次加法时取模即可。
3. **拓扑排序**：因为是求最长路，必须按照拓扑序进行更新，否则状态转移可能遗漏前驱节点。
4. **初始化**：所有 `f[i]` 初始都是 `scc_size[i]`，因为每个 SCC 自己本身就是一个合法的半连通子图。
