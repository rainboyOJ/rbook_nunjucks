---
oj: "HDU"
problem_id: "2611"
title: "Sequence two"
date: 2026-01-10 23:00
toc: true
tags: ["剪枝","todo"]
desc: ""
source: https://vjudge.net/problem/HDU-2611
---

[[TOC]]

## 题目解析

**题目大意：**
给定一个包含 $N$ ($N \le 100$) 个整数的序列。你需要找到前 $P$ 个满足“非递减”性质的子序列。
输出的排序规则如下：
1.  **长度优先**：长度短的子序列排在前面（即先输出长度为1的，再输出长度为2的……）。
2.  **字典序优先**：长度相同的子序列，按字典序（数值大小）从小到大排序。
3.  如果满足条件的子序列总数少于 $P$，则输出所有满足条件的子序列。

**输入：**
多组测试数据。每组包含 $N$ 和 $P$，随后一行是 $N$ 个整数。

**输出：**
按上述规则输出子序列，每个测试用例结束后输出一个空行。

---

## 解题思路

这就要求我们在搜索子序列时，必须严格控制搜索顺序。

1.  **确定遍历顺序（最外层）：**
    题目要求按长度排序，所以我们最外层循环应该是枚举子序列的长度 $L$，从 $1$ 到 $N$。

2.  **确定搜索策略（DFS）：**
    对于固定的长度 $L$，我们需要找到所有长度为 $L$ 的非递减子序列，并按字典序输出。
    我们可以使用 DFS（深度优先搜索）来构建子序列。
    `DFS(last_index, current_length, target_length)`：
    *   `last_index`: 上一个选中的元素在原数组中的下标。
    *   `current_length`: 当前已经选了几个数。
    *   `target_length`: 目标长度 $L$。

3.  **保证字典序和去重（关键点）：**
    在 DFS 的每一步，我们需要决定下一个元素选谁。
    假设上一个选的下标是 `last_index`，那么下一个下标 $i$ 必须满足：
    *   $i > last\_index$（下标递增）
    *   $arr[i] \ge arr[last\_index]$（数值非递减）
    *   **可行性剪枝**：以 $i$ 开头是否能凑够剩余所需的长度？这需要预处理 DP。

    为了保证字典序最小，我们在每一步选下一个数时，不能简单地按原来的下标顺序遍历，而应该**将所有合法的候选元素按数值从小到大排序**，然后依次尝试。

    同时，为了去重（例如输入 `1 2 2`，长度为1的子序列应该是 `1`, `2`，而不是 `1`, `2`, `2`），在排序后的候选列表中，如果当前元素的值与上一个尝试的元素值相同，则跳过。

4.  **可行性预处理 (DP)：**
    为了避免走进死胡同（选了某个数，结果后面凑不够长度了），我们需要先计算一个数组 `dp[i]`，表示**以第 $i$ 个元素开头的最长非递减子序列的长度**。
    *   状态转移：$dp[i] = 1 + \max( \{dp[j] \mid j > i \text{ 且 } arr[j] \ge arr[i]\} \cup \{0\} )$。
    *   在 DFS 选择下一个节点 $k$ 时，必须满足 `dp[k] >= target_length - current_length - 1`，否则选了 $k$ 也凑不够长度，直接剪枝。

## 代码实现

@include-code(./1.cpp,cpp)

## 题目难度与评价

**难度评级：中等偏下 (Medium-Low)**

1.  **考察点：**
    *   **深度优先搜索 (DFS)**：用于构建序列。
    *   **动态规划 (DP) 思想**：用于可行性剪枝（Look-ahead），判断当前节点是否有潜力构成目标长度的序列。如果没有这个剪枝，盲目搜索在最坏情况下会超时。
    *   **排序与去重**：这道题最核心的难点在于**输出顺序**。为了满足“字典序最小”，不能简单地按数组下标顺序 DFS，而必须在每一步将所有合法的“下一步”按数值排序。同时需要处理重复元素的情况。

2.  **易错点：**
    *   **输出格式**：很容易忽略题目要求的长度优先，即必须外层循环枚举长度 $1 \to N$。
    *   **字典序逻辑**：如果直接按数组下标遍历，得到的不是字典序最小的。例如 `1 3 2`，按下标遍历会先得到 `1 3`，然后回溯得到 `1 2`。但题目要求 `1 2` 在前。必须在搜索树的每一层对候选项进行排序。
    *   **空行**：Presentation Error 的常见来源。

3.  **总结：**
    这是一道非常经典的搜索题目，它结合了最基础的 LIS（最长上升子序列）的 DP 预处理思想和带有特定顺序要求的 DFS 回溯。对于训练搜索剪枝和字典序构建非常有帮助。虽然 $N$ 很小，但 $P$ 较大，考验了代码逻辑的准确性和剪枝的有效性。
