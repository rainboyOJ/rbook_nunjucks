---
oj: "HDU"
problem_id: "2874"
title: "Connections between cities"
date: 2026-01-04 15:34
toc: true
tags: ["lca"]
desc: "lca简单题"
source: https://vjudge.net/problem/HDU-2874#author=DeepSeek_zh
---

[[TOC]]



## 1. 题目解析

这道题目是上一题（树上两点距离）的 **变种和升级版**。

**关键差异与难点：**

1. **森林 (Forest) 结构**：题目明确说“大部分道路被摧毁...不存在环路”。这意味着图不再是一棵完整的树，而是由多棵树组成的**森林**。
   - 这意味着图可能不连通。
   - 我们需要处理多个根节点。
2. **连通性判断**：题目要求如果两点不可达，输出 "Not connected"。
   - 这意味着我们在查询 LCA 之前，必须先判断 $u$ 和 $v$ 是否在同一棵树上。
3. **多组测试数据**：输入包含多个实例，且没有给出具体的组数 $T$，通常需要使用 `while(cin >> n >> m >> c)` 来处理直到 EOF（文件结束）。
4. **数据范围**：
   - $N \le 10000$（比较小）。
   - $C \le 1,000,000$（查询非常多）。这要求查询必须是 $O(\log N)$ 或 $O(1)$ 的。

**算法思路：**

1. **建图**：依然使用链式前向星存储无向图。
2. **森林的处理 (LCA Init 改良)**：
   - 普通的 LCA 模板只从一个固定的 `root` 开始 DFS。
   - 对于森林，我们需要遍历所有点 $i = 1 \dots N$。
   - 如果点 $i$ 还没被访问过（深度为 0），说明它是一个新连通块（新树）的根。
   - 从这个 $i$ 开始 DFS，并给这棵树上的所有节点打上标记（例如 `belong[u] = root_id`）。
3. **查询逻辑**：
   - 输入 $u, v$。
   - 第一步：检查 `belong[u]` 是否等于 `belong[v]`。如果不等，直接输出 "Not connected"。
   - 第二步：如果相等，套用公式 $Dist(u) + Dist(v) - 2 \times Dist(LCA(u, v))$。

------

## 2. 代码实现

基于你的模板进行了以下适配：

1. **`belong` 数组**：在 `LCA` 结构体中增加此数组，用来记录每个点属于哪棵树（即该树根节点的编号）。
2. **`init` 函数改造**：增加循环检测未访问节点，处理森林情况。
3. **输入循环**：使用 `while(cin >> ...)` 处理不定量的测试数据。
4. **初始化重置**：每次循环开始前调用 `e.reset()`，且在 `init` 中注意清空 `d` 数组以正确判断访问状态。

@include-code(./1.cpp,cpp)

