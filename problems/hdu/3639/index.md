---
oj: "HDU"
problem_id: "3639"
title: "Hawk-and-Chicken"
date: 2026-01-09 12:14
toc: true
tags: ["强连通分量"]
desc: "受欢迎的牛的加强版,dag上能到达点u的点的数量"
source: https://vjudge.net/problem/HDU-3639
pre:
 - luogu,P2341
---

[[TOC]]

## 题目解析

> dag上能到达点u的点的数量

时间复杂度 $n^2$ 能过,

这是一份基于你的模板（`linkList` + `TarjanScc`）完成的 HDU 3639 Hawk-and-Chicken 的完整代码。

### 核心思路回顾

1. **Tarjan缩点**：处理循环依赖，将强连通分量缩成一个点，点权为该分量包含的原节点数。
2. **构建反向DAG**：原题求“谁被最多人指向”，反向后变为“从谁出发能指向最多人”。

* 原图：
* 反向DAG：


3. **剪枝 DFS**：在反向DAG中，只有 **入度为0** 的点（原图的汇点）才可能是最终赢家。从这些点出发 DFS 统计能覆盖的总点权。

### 代码实现


注意：HDU 3639 的输入是 0 ~ N-1，但你的 Tarjan 模板循环是从 1 ~ N。为了适配模板，我在读入时将节点编号 +1，输出时再 -1。

@include-code(./1.cpp, cpp)

## 时间复杂度

我们来详细分析一下这份“Tarjan缩点 + 反向图 + 剪枝DFS”代码的时间复杂度。

### 1. 复杂度结论

假设：

- $N$ 为点数（$N \le 5000$）
- $M$ 为边数（$M \le 30000$）
- $T$ 为数据组数（$T \le 50$）
- **$K$** 为缩点后，反向图中**入度为0**的连通分量个数（即原图中出度为0的汇点SCC数量）。

总时间复杂度为：



$$O(T \times (N + M + K \times (N + M)))$$

简化后的最坏时间复杂度（当 $K \approx N$ 时）：



$$O(T \times N \times (N + M))$$

空间复杂度为：



$$O(N + M)$$

------

### 2. 分步详细分析

#### 第一步：Tarjan 缩点

- **操作**：遍历整个图的每个点和每条边一次。
- **复杂度**：$O(N + M)$。

#### 第二步：构建反向图 (Reverse DAG)

- **操作**：遍历原图的所有边，判断是否跨越 SCC，若是则加入新图。
- **复杂度**：$O(N + M)$。
  - 注意：虽然可能有重边，但这一步是线性的。

#### 第三步：DFS 统计 (核心瓶颈)

这是决定生死的步骤。

- **单次 DFS**：在反向 DAG 上进行一次 DFS，最坏情况下会遍历整个反向图。反向图的点数 $\le N$，边数 $\le M$。复杂度 $O(N + M)$。
- **执行次数**：我们做了剪枝，**只对反向图中入度为0的点**（Candidate Roots）发起 DFS。假设这样的点有 $K$ 个。
- **Token 优化的作用**：`visit_token` 使得我们将每次 DFS 前的清空操作从 $O(N)$ 降为 $O(1)$，这非常关键，但不会改变 DFS 本身的遍历复杂度。
- **该步骤复杂度**：$O(K \times (N + M))$。

------

### 3. 为什么这个复杂度能过？(风险评估)

让我们算一下最坏情况的数据量：



$$50 \text{ (组)} \times 5000 \text{ (点)} \times 35000 \text{ (点+边)} \approx 8.75 \times 10^9 \text{ 次操作}$$

通常计算机 1秒只能处理约 $10^8$ 次操作。**理论上，这个复杂度是会超时的 (TLE)**。

**但是它能过的原因如下：**

1. **缩点 (SCC) 的威力**：
   - 如果图中有大环，缩点后 $N$ 会急剧减小。例如一个强连通图缩点后 $N=1, M=0$，复杂度瞬间变成 $O(1)$。
   - 复杂度公式里的 $N$ 和 $M$ 其实是**缩点后**的点数 $N'$ 和边数 $M'$。通常 $N' \ll N$。
2. **剪枝 ($K$) 的威力**：
   - 虽然最坏情况 $K \approx N$（例如每一层节点都指向下一层，像金字塔形状），但在随机数据或典型数据中，**汇点 (Sink Nodes)** 的数量通常不多。
   - 如果图是一个长链（$1 \to 2 \to \dots \to N$），反向后入度为0的点只有1个 ($K=1$)。此时复杂度仅为 $O(N+M)$。
   - 如果图是一个从中心向外发射的星形，反向后入度为0的点虽然有 $N-1$ 个，但每次 DFS 深度只有 1，总计算量依然很小。
3. **Token 优化**：
   - 如果不加 `visit_token`，每次 DFS 前 `memset` 清空数组，复杂度会变成 $O(K \times (N + (N+M)))$，常数变大，极大概率 TLE。Token 优化去掉了这个 $O(N)$ 的初始化开销。

### 4. 另一种更稳的算法 (Bitset)

如果这道题的数据构造得非常“恶心”（DAG 图，没有环，且有很多菱形结构导致 $K$ 很大且每次 DFS 覆盖面很广），上述算法会 TLE。

在竞赛中，处理这类 $N \le 5000$ 的**DAG可达性统计**问题，更稳定的是使用 **`std::bitset`** 优化拓扑排序：

- **原理**：$Reach[u] = \{u\} \cup Reach[v_1] \cup Reach[v_2] \dots$
- **做法**：在 DAG 上跑逆拓扑排序，用 `bitset` 做或运算（OR）。
- **复杂度**：$O(\frac{N(N+M)}{64})$。
- **计算**：$\frac{8.75 \times 10^9}{64} \approx 1.3 \times 10^8$，这在 1-2秒内是绝对安全的。

### 5. 总结

目前使用的 **DFS + Pruning** 方案：

- **平均/随机数据**：飞快。
- **特定构造数据 (Dense DAG)**：会 TLE。
- **针对 HDU 3639**：这道题的数据比较弱，且 $N=5000$ 在旧题库中往往允许 $O(N^2)$ 级别的算法通过（特别是带有大常数剪枝的）。

代码是**正确且适合该题**的标准解法之一。



