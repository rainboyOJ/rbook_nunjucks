---
oj: "HDU"
problem_id: "2586"
title: "How far away ？"
date: 2026-01-04 15:26
toc: true
tags: ["lca","模板题"]
desc: "lca模板题"
source: https://vjudge.net/problem/HDU-2586#author=DeepSeek_zh
---

[[TOC]]

## 1. 题目解析

这是一道非常经典的图论题目，核心在于理解题目的隐含条件：

“n间房屋...任意两间房屋之间都存在唯一的一条简单路径”。

这不仅仅是一个图，而是一棵 **树 (Tree)**。

- **树的性质**：$N$ 个节点，$N-1$ 条边，连通且无环。
- **路径距离**：在树上，两个点 $u$ 和 $v$ 之间的唯一路径长度，可以通过 **LCA (最近公共祖先)** 快速求出。

### 公式推导

设 $Dist(u)$ 为节点 $u$ 到根节点（通常设为 1）的距离。

那么 $u$ 和 $v$ 之间的距离为：



$$Answer = Dist(u) + Dist(v) - 2 \times Dist(LCA(u, v))$$

**算法流程**：

1. **建图**：使用链式前向星存储无向带权图。
2. **LCA 预处理**：
   - 选定 1 号点为根。
   - DFS 遍历整棵树，计算出每个节点的深度 `d[u]`，倍增祖先 `f[u][j]`。
   - **关键点**：同时在 DFS 中计算每个节点到根的距离 `dis[u]`（带权距离）。
3. **处理询问**：对于每对 $(u, v)$，利用公式 $dis[u] + dis[v] - 2 \times dis[LCA(u, v)]$ 输出答案。
4. **多组数据**：注意 $T$ 组数据，每次必须清空图结构 (`e.reset()`)。

------

## 2. 代码实现

使用了你的模板（LCA + LinkList），并进行了适配：

1. **多组数据支持**：添加了 `solve()` 函数和循环，每次调用 `e.reset()`。
2. **距离计算**：在 `LCA` 结构体中增加了 `dis` 数组，并在 `dfs` 时维护它。
3. **语法糖**：沿用了你喜欢的 `for(auto [v, w] : e.adj(u))` 写法。


@include-code(./1.cpp,cpp)
