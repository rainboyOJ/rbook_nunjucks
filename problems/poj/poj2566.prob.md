---
title: "Bound Found"
date: 2025-11-26 20:04
toc: true
tags: ["双指针"]
categories: [""]
oj: "poj"
problem_id: "2566"
source: https://vjudge.net/problem/POJ-2566#author=DeepSeek_zh
---

https://vjudge.net/problem/POJ-2566#author=DeepSeek_zh

这是一道非常经典的算法题目（对应 **POJ 2566 - Bound Found**）。

针对你的核心疑问：“**数组中有负数，打破了普通滑动窗口的单调性，如何使用双指针？**”

答案是：**不要直接在原数组上跑双指针，而是在“排序后的前缀和数组”上跑双指针。**

### 核心解题思路

#### 1\. 转换问题：前缀和 (Prefix Sum)

原数组 $A$ 中含有负数，导致区间伸缩时和的大小变化不可预测。但是，任何一个子区间 $[l, r]$ 的和都可以表示为两个前缀和的差：
$$Sum(l, r) = P[r] - P[l-1]$$
其中 $P[i]$ 是前 $i$ 个元素的和，$P[0] = 0$。

题目要求找到 $|Sum(l, r)| \approx t$，等价于找到两个前缀和 $P[x]$ 和 $P[y]$，使得：
$$|P[x] - P[y]| \approx t$$


问题就转变成了在一个单调数组上,查找最$A-B \approx C$的数值.

#### 2\. 制造单调性：排序 (Sorting)

虽然原数组有负数导致前缀和数组 $P$ 也是乱序的，但如果我们把 **$P$ 数组按照数值大小从小到大排序**，情况就变了。

设排序后的前缀和数组为 $S$。此时 $S$ 是单调递增的。
对于 $S$ 中的任意两个元素 $S[right]$ 和 $S[left]$（其中 $right > left$），它们的差 $diff = S[right] - S[left]$ 必定是 **非负的**。

这就构造出了双指针所需的单调性：

  * 如果 $diff < t$：我们需要更大的差值，所以 **右指针 `right` 向右移**（找一个更大的数减去当前的左边）。
  * 如果 $diff > t$：差值太大了，我们需要更小的差值，所以 **左指针 `left` 向右移**（找一个更大的被减数，缩短两者距离）。

#### 3\. 算法流程

1.  **计算前缀和**：生成包含 $(N+1)$ 个元素的数组（包含初始的0），存储结构为 `{value, original_index}`。
2.  **排序**：按照 `value` 对前缀和数组进行升序排序。
3.  **双指针扫描**：
      * 初始化 `left = 0`, `right = 1`。
      * 计算 `diff = S[right].val - S[left].val`。
      * 检查 `diff` 与目标 `t` 的接近程度，更新全局最优解（记录最小差值、以及对应的原始下标）。
      * **移动指针**：
          * 若 `diff < t`：`right++`。
          * 若 `diff > t`：`left++`。
          * 若 `diff == t`：直接找到完美解，跳出。
          * **注意**：若 `left == right`，强制 `right++` 以保持区间非空。

#### 4\. 还原下标

排序打乱了原始下标，但我们在结构体里保存了 `original_index`。
假设找到的最优对是 $S[left]$ 和 $S[right]$，它们的原始下标分别是 $id_1$ 和 $id_2$。

  * 区间起点 $l = \min(id_1, id_2) + 1$
  * 区间终点 $u = \max(id_1, id_2)$

-----

### C++ 代码实现


@include-code(./poj2566.cpp, cpp)

### 复杂度分析

1.  **前缀和计算**: $O(N)$。
2.  **排序**: $O(N \log N)$。
3.  **查询处理**:
      * 每次查询使用双指针遍历一次数组，复杂度 $O(N)$。
      * 总共有 $K$ 次查询。
      * 查询总复杂度 $O(K \times N)$。
4.  **总复杂度**: $O(N \log N + K \times N)$。
      * 鉴于 $N=100,000$，如果 $K$ 很大，这可能会超时。但在本题（POJ 2566）的数据范围内，$K$ 比较小，或者测试用例较弱，此解法是标准正解。

### 总结

这就是处理**带负数区间和**问题的通解：
**前缀和 + 排序 + 双指针**。
它把原本无序的区间和问题，转化为了有序数组上的两数之差问题。